<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: software | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/tag/software/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2017-12-11T00:01:53+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Windows 8 Series - Incremental Loading]]></title>
    <link href="http://rahulpnath.com/blog/windows-8-series-incremental-loading/"/>
    <updated>2012-10-28T14:41:31+00:00</updated>
    <id>http://rahulpnath.com/blog/windows-8-series-incremental-loading</id>
    <content type="html"><![CDATA[<p>Fast and fluid experience is one of the most important characteristics of a Windows 8 application. As the data becomes larger , it might not be always possible to get the entire data loaded before hand.We might want to have a incremental or sequential data loading so that the user has a better experience.
While developing windows 8 this can be easily achieved by using <a href="http://msdn.microsoft.com/en-us/library/windows/apps/Hh701916">ISupportIncrementalLoading</a>
interface which would load the data incrementally.The class that implements this should also implement the <a href="http://msdn.microsoft.com/en-us/library/system.collections.ilist.aspx">IList</a> and <a href="http://msdn.microsoft.com/en-us/library/system.collections.specialized.inotifycollectionchanged.aspx">INotifyColectionChanged</a>. A sample on how to implement this interface can be seen <a href="http://msdn.microsoft.com/en-us/library/windows/apps/Hh701916">here</a>.
Implementing these over and over for different data sources that you would want to load incrementally might soon become tedious and repetitive.So why not make up some generic classes that you could abstract away the task of loading the data incrementally. That&rsquo;s exactly what we would be looking into here.</p>

<p>First lets get the class that implements <a href="http://msdn.microsoft.com/en-us/library/windows/apps/Hh701916">ISupportIncrementalLoading</a>, IList and INotifyCollectionChanged. To keep things simple lets inherit from ObservableCollection,which in turn inherits the latter 2 interfaces</p>

<pre><code class="csharp">    public class IncrementalSource&lt;T, K&gt; : ObservableCollection&lt;K&gt;, ISupportIncrementalLoading
        where T: class
    {
        private string Query { get; set; }
        private int VirtualCount { get; set; }
        private int CurrentPage { get; set; }
        private IPagedSource&lt;T,K&gt; Source { get; set; }
        private int rpp { get; set; }

        public IncrementalSource(string query, Func&lt;T, IPagedResponse&lt;K&gt;&gt; GetPagedResponse)
        {
            this.Source = new PagedSourceLoader&lt;T, K&gt;(GetPagedResponse);
            this.VirtualCount = int.MaxValue;
            this.CurrentPage = 0;
            this.Query = query;
        }

        #region ISupportIncrementalLoading

        public bool HasMoreItems
        {
            get { return this.VirtualCount &gt; this.CurrentPage * (rpp == 0 ? 10 :rpp); }
        }

        public IAsyncOperation&lt;LoadMoreItemsResult&gt; LoadMoreItemsAsync(uint count)
        {
            CoreDispatcher dispatcher = Window.Current != null ? Window.Current.Dispatcher : Windows.ApplicationModel.Core.CoreApplication.MainView.CoreWindow.Dispatcher;
            if (count &gt; 50 || count &lt;= 0)
            {
                // default load count to be set to 50
                count = 50;
            }

            return Task.Run&lt;LoadMoreItemsResult&gt;(
                async () =&gt;
                {

                    IPagedResponse&lt;K&gt; result = await this.Source.GetPage(string.Format(this.Query,count), ++this.CurrentPage, (int)count);

                    this.VirtualCount = result.VirtualCount;
                    if (rpp == 0)
                    {
                        rpp = result.rpp;
                    }

                    await dispatcher.RunAsync(
                        CoreDispatcherPriority.Normal,
                        () =&gt;
                        {
                            foreach (K item in result.Items)
                                this.Add(item);
                        });

                    return new LoadMoreItemsResult() { Count = (uint)result.Items.Count() };

                }).AsAsyncOperation&lt;LoadMoreItemsResult&gt;();
        }

        #endregion
    }
</code></pre>

<p>Before going into the details of the code, lets understand what this class is going to do for us. We need to load data in a paged fashion from a large datasource. So we would generally be dealing with two types of object – one the type of object(<strong><em>K</em></strong>) whose list we are trying to load incrementally. Another one the type of object(<strong><em>T</em></strong>) that represents each paged request result. This object would ideally contain a property to hold list of objects of type K, the total number of items that the datasource would give us,so that we know how many pages we need to request for and also a property indicating the current page. Each datasource might return us these required properties in different property names and types. So we have a class to hold these data together for us, PagedResponse which implements IPagedResponse</p>

<pre><code class="csharp">    public interface IPagedResponse&lt;T&gt;
    {
        IEnumerable&lt;T&gt; Items { get; }
        int VirtualCount { get; }
        int rpp { get; set; } // rpp - requests per page
    }




    public class PagedResponse&lt;K&gt; : IPagedResponse&lt;K&gt;
    {
        public PagedResponse(IEnumerable&lt;K&gt; items, int virtualCount,int itemsPerPage)
        {
            this.Items = items;
            this.VirtualCount = virtualCount;
            rpp = itemsPerPage;
        }

        public int VirtualCount { get; private set; }
        public int rpp { get;  set; }
        public IEnumerable&lt;K&gt; Items { get; private set; }
    }
</code></pre>

<p>That said lets see the  <em>IncremetnalSource</em> class. It takes in the object type <strong><em>T </em></strong>and <strong><em>K.</em></strong>The constructor takes in the url where the datasource can be found.The Func&lt;T, IPagedResponse<K>> parameter represents a function that takes in the return type of the call to the url as a parameter and returns the PagedResponse type. In other words that function converts the paged request call type to the type that we use to represent it, IPagedResponse.See a sample below.</p>

<pre><code class="csharp">private PagedResponse&lt;Photo&gt; RootObjectResponse(RootObject rootObject)
{
    return new PagedResponse&lt;Photo&gt;(rootObject.photos, rootObject.total_items, rootObject.photos != null ? rootObject.photos.Count : 0);
}
</code></pre>

<p>Now we need to make the call to the datasource url. This might return us data in different formats, most popularly json or xml. So we would always want to abstract away the loading of data to another class so that we don’t get tied up with the data formats in <em>IncrementalSource.</em></p>

<p>IPagedSource&lt;T,K> will do this for us. A sample implementation of this is <em>PagedSourceLoader </em>that handles for json return type is below</p>

<pre><code class="csharp">    public interface IPagedSource&lt;R,K&gt;
    {
        Task&lt;IPagedResponse&lt;K&gt;&gt; GetPage(string query, int pageIndex, int pageSize);
    }




    public class PagedSourceLoader&lt;T,K&gt; : IPagedSource&lt;T,K&gt;
        where T:class 
    {
        private Func&lt;T, IPagedResponse&lt;K&gt;&gt; getPagedResponse;
        public PagedSourceLoader(Func&lt;T, IPagedResponse&lt;K&gt;&gt; GetPagedResponse)
        {
            getPagedResponse = GetPagedResponse;
        }

        #region IPagedSource

        public async Task&lt;IPagedResponse&lt;K&gt;&gt; GetPage(string query, int pageIndex, int pageSize)
        {
            query += "&amp;page="+pageIndex;
            HttpClient client = new HttpClient();
            HttpResponseMessage response = await client.GetAsync(query);
            var data = await response.Content.ReadAsStreamAsync();
            DataContractJsonSerializer json = new DataContractJsonSerializer(typeof(T));
            T dat = json.ReadObject(data) as T;
            return getPagedResponse(dat);
        }

        #endregion
    }
</code></pre>

<p>As you see above the <em>PagedSourceLoader</em> gets the json from the datasource url and converts to the type that we are interested in . You could always replace this class to use any other data format as you would want. Mostly you would just want one implementation for <em>IPagedSource&lt;T,K>, </em>as your data source would always return you the same data format. In case not you could inject that too into the <em>IncrementalSource</em> class.</p>

<p>I have a sample <a href="http://sdrv.ms/RdPtdL">here</a> that incrementally loads the photos from a photo site <a href="http://500px.com/flow">500px</a>. You would need to register for an to get the consumer key,which should hardly take some time <a href="http://500px.com/settings/applications?from=developers">here</a>.</p>

<p><img src="/windows8_incremental_loading.png" alt="windows8 incremental loading" /></p>

<p><a href="https://github.com/rahulpnath/Blog/tree/master/Windows8%20-%20IncrementalLoading">Download the sample source code</a></p>

<p>Keep a sample of the source code for yourself in case you wanted this specific version. I might refine this to a more usable library with couple of default <em>PagedSourceLoader.</em></p>

<p><strong>References:
</strong><a href="http://www.silverlightplayground.org/post/2012/06/10/Metro-Incrementally-load-GridView-and-ListView-with-ISupportIncrementalLoading.aspx">Metro: Incrementally load GridView and ListView with ISupportIncrementalLoading</a></p>

<p>Feel free to reuse it if you find it useful and drop a comment to refine it.</p>
]]></content>
  </entry>
  
</feed>
