<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: metro app | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/tag/metro-app/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2018-12-27T00:02:21+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Windows Phone Series – Incremental Loading]]></title>
    <link href="http://rahulpnath.com/blog/windows-phone-series-incremental-loading/"/>
    <updated>2013-03-03T08:53:45+00:00</updated>
    <id>http://rahulpnath.com/blog/windows-phone-series-incremental-loading</id>
    <content type="html"><![CDATA[<p>Some time back we had a look on doing <a href="http://rahulpnath.wordpress.com/2012/10/28/windows-8-series-incremental-loading/">Incremental Loading with a Windows 8 store app</a>. This same scenario is something that one would come across quite frequently while developing a Windows Phone application too. We have a couple of options in dealing with this while on a Windows phone application. In an ideal case while binding to a large data on a windows phone application, we might be using a <a href="http://msdn.microsoft.com/en-US/library/windowsphone/develop/microsoft.phone.controls.longlistselector(v=vs.105">LongListSelector</a>.aspx) or a Listbox control.</p>

<p>While using a LongListSelector, we can use the Link event(if you are using <a href="http://phone.codeplex.com/">Windows Phone 7.1 toolkit</a>) Or the <a href="http://msdn.microsoft.com/en-US/library/windowsphone/develop/microsoft.phone.controls.longlistselector.itemrealized(v=vs.105">ItemRealized</a>.aspx) event(if you are on Windows phone 8.0). Basically we would be doing the same thing in either of these cases, checking the current item that is getting realized and see what is the index of the item in the whole list of data that you have currently and check if its time for you to fetch the next set of data from your data source(possibly a web service). As usual for the sample we will be using the <a href="http://500px.com/popular">500px</a> api.</p>

<p>Below is the piece of code that will fetch us the photo from the <a href="http://developers.500px.com/">500px api</a> to populate the listbox data.</p>

<pre><code class="csharp">private static int requestPerPage = 20;
private int currentPage = 1;
private bool isCurrentlyLoading = false;

private ObservableCollection&lt;Photo&gt; Photos = new ObservableCollection&lt;Photo&gt;();

private string datasourceUrl="https://api.500px.com/v1/photos?feature=popular&amp;consumer_key=" 
          + consumerKey + "&amp;rpp=" + requestPerPage.ToString() + "&amp;page={0}";

private void LoadDataFromSource()
{
    isCurrentlyLoading = true;
    var query = string.Format(datasourceUrl, currentPage);
    WebClient client = new WebClient();
    client.DownloadStringCompleted += client_DownloadStringCompleted;
    client.DownloadStringAsync(new Uri(query));

}

void client_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)
{
    using (var reader = new MemoryStream(Encoding.Unicode.GetBytes(e.Result)))
    {
        var ser = new DataContractJsonSerializer(typeof(RootObject));
        RootObject obj = (RootObject)ser.ReadObject(reader);
        currentPage = obj.current_page + 1;
        if (obj != null)
        {
            this.Dispatcher.BeginInvoke(() =&gt;
                {
                    foreach (var photo in obj.photos)
                    {
                        Photos.Add(photo);
                    }
                    isCurrentlyLoading = false;
                });
        }
    }
}
</code></pre>

<p>In the ItemRealized/Link event based on whether you are developing for Windows Phone 7 or 8, below would be the code that goes into that. We need to check the current item that is realized i.e rendered on the UI and see if it is</p>

<pre><code class="csharp">private void photosList_ItemRealized_1(object sender, ItemRealizationEventArgs e)
{
    Photo photo = e.Container.Content as Photo;
    if (photo != null)
    {
        int offset = 2;
        // Only if there is no data that is currently getting loaded
        // would be initiate the loading again
        if (!isCurrentlyLoading &amp;&amp; Photos.Count - Photos.IndexOf(photo) &lt;= offset)
        {
            LoadDataFromSource();
        }
    }
}
</code></pre>

<p>In case you want to use a normal listbox, you can do that also. We would need to hook up with VisualStateGroups. This <a href="http://blogs.msdn.com/b/slmperf/archive/2011/06/30/windows-phone-mango-change-listbox-how-to-detect-compression-end-of-scroll-states.aspx">link</a> explains this in details, and I have just reused parts of it as is. We need to override the scrollviewer style to hook into this new StateGroups. We need to look for CompressionBottom state, for the currentstatechanged event of the scrollviewer.</p>

<pre><code class="csharp">private void myScrollViewer_Loaded_1(object sender, RoutedEventArgs e)
{
    SetScrollViewer();
}

private void SetScrollViewer()
{
    // Visual States are always on the first child of the control template 
    FrameworkElement element = VisualTreeHelper.GetChild(myScrollViewer, 0) 
                            as FrameworkElement;
    if (element != null)
    {
        VisualStateGroup vgroup = FindVisualState(element, "VerticalCompression");

        if (vgroup != null)
        {
            vgroup.CurrentStateChanging += 
                 new EventHandler&lt;VisualStateChangedEventArgs&gt;(vgroup_CurrentStateChanging);
        }
    }
}

private void vgroup_CurrentStateChanging(object sender, VisualStateChangedEventArgs e)
{
    if (e.NewState.Name == "CompressionTop")
    {

    }

    if (e.NewState.Name == "CompressionBottom")
    {
        if (!isCurrentlyLoading )
        {
            LoadDataFromSource();
        }
    }
    if (e.NewState.Name == "NoVerticalCompression")
    {

    }
}
</code></pre>

<p>You can use either of these two ways to incrementally load data on a windows phone app. The entire code that is used in this blog is avaialble <a href="https://github.com/rahulpnath/IncrementalLoadingPhone">here</a>. The sample app shows both these methods. The pivot header specifies the method that is used, LongListSelector and Scrollstates</p>

<p><img src="/wp_incremental_loading_longlistselector.jpg" alt="windows phone incremental loading using longlistselector" /><img src="/wp_incremental_loading_scrollstates.jpg" alt="windows phone incremental loading using scrollstates" /></p>

<p>Hope this helps you to incrementally load data on your windows phone application</p>

<p><a href="https://github.com/rahulpnath/IncrementalLoadingPhone">Download Code</a></p>
]]></content>
  </entry>
  
</feed>
