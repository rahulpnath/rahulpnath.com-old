<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 500px infinite scrolling | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/tag/500px-infinite-scrolling/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2017-07-30T00:02:04+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Windows Phone Series – Incremental Loading multiple data sources inside a Pivot]]></title>
    <link href="http://rahulpnath.com/blog/windows-phone-series-incremental-loading-multiple-data-sources-inside-a-pivot/"/>
    <updated>2014-01-21T07:55:25+00:00</updated>
    <id>http://rahulpnath.com/blog/windows-phone-series-incremental-loading-multiple-data-sources-inside-a-pivot</id>
    <content type="html"><![CDATA[<p>We had seen on how <a href="http://rahulpnath.com/blog/windows-phone-series-incremental-loading/">incremental loading can be done in a Windows phone</a>, so that data can be fetched as user scrolls down the available data. This is important for data sources that have a large amount of data and when all of these cannot be loaded at once. I have been getting queries on how to implement this for a Pivot control ,in which each pivot item would bind with multiple data sources or endpoints.</p>

<p>An ideal example for this would be the <a href="http://developers.500px.com/">500px api</a>, where we have photos categorized into different streams and each one of them can be in a pivot item. Since we have been talking about <a href="http://rahulpnath.com/blog/tag/mvvm/">mvvm</a>, all along will implement this using MVVM.</p>

<p><img src="/WP_IncrementalLoading.png" alt="image" /></p>

<p>In the sample application here, I have created 2 projects – PCL and Windows Phone project, just for showing the code separation that can be achieved using MVVM. The PCL can be reused with Windows 8 too to develop a similar application, with a few minor tweaks. We would see how we can incrementally load each of these pivot items as and when the user scrolls down on the list of photos.</p>

<p>In the MainViewModel, we create ViewModel’s for each of the PivotItem, which are instances of PhotoCollectionViewModel. Each of these PhotoCollectionViewModel represents a photo stream of 500px, which is defined as a static collection of string. You can add on to this the other streams available in the 500px api to have them displayed too.</p>

<pre><code class="csharp">private static string[] photoCollections =
    {
        "popular",
        "upcoming",
        "editors",
        "fresh_today"
    };

public List PhotoCollectionViewModels { get; set; }

public MainViewModel()
{
    PhotoCollectionViewModels = new List();
    foreach (var photoCollection in photoCollections)
    {
        this.PhotoCollectionViewModels.Add(new PhotoCollectionViewModel(photoCollection));
    }
}
</code></pre>

<p>In the PhotoCollectionViewModel, we create the url from which the data needs to be  fetched from the api, along with the api consumer key, which can be obtained by <a href="http://500px.com/settings/applications">registering an application here</a> and assign the url to a IncrementalLoader, that will take care of incrementally loading the data and returning it to the ViewModel. The url has a placeholder for the current page number(<strong><em>page={0}</em></strong>) that would be populated by the IncrementalLoader on each load.</p>

<p>The IncrementalLoader is a generic class that takes in url from which it has to load the data and returns the generic type that it is assigned to on each LoadNextPage request.</p>

<pre><code class="csharp ">public class IncrementalLoader&lt;T&gt; where T : class
{
    private string BaseUrl;

    private int CurrentPageNumber;

    private bool isCurrentlyLoading;

    private string CurrentUrl
    {
        get
        {
            return string.Format(this.BaseUrl, ++this.CurrentPageNumber);
        }
    }

    public IncrementalLoader(string baseUrl)
    {
        this.BaseUrl = baseUrl;
    }

    public async Task&lt;T&gt; LoadNextPage()
    {
        if (this.isCurrentlyLoading)
        {
            // call in progress
            return null;
        }

        this.isCurrentlyLoading = true;
        HttpClient client = new HttpClient();

        // Add Microsoft.Bcl.Async nuget for await to work on PCL.

        var response = await client.GetStringAsync(this.CurrentUrl);
        var serializer = new DataContractJsonSerializer(typeof(T));
        var returnObject = serializer.ReadObject(new MemoryStream(Encoding.Unicode.GetBytes(response))) as T;
        this.isCurrentlyLoading = false;

        return returnObject;
    }

}
</code></pre>

<p>In the Main page, the view Model is bound to a Pivot control, which has the templates specified for displaying the list of PhotoCollectionViewModels.</p>

<pre><code class="xml">
&lt;Grid x:Name="ContentPanel" Grid.Row="1" &gt;
 &lt;phone:Pivot Name="photoCollection" ItemsSource="{Binding PhotoCollectionViewModels}"&gt;
 &lt;phone:Pivot.ItemTemplate&gt;
 &lt;DataTemplate&gt;
 &lt;phone:LongListSelector ItemRealized="Photo_Loaded" ItemsSource="{Binding Photos}" IsGroupingEnabled="False"&gt;
 &lt;phone:LongListSelector.ItemTemplate&gt;
 &lt;DataTemplate&gt;
 &lt;Image Source="{Binding image_url}" Margin="10" Width="500" /&gt;
 &lt;/DataTemplate&gt;
 &lt;/phone:LongListSelector.ItemTemplate&gt;
 &lt;/phone:LongListSelector&gt;
 &lt;/DataTemplate&gt;
 &lt;/phone:Pivot.ItemTemplate&gt;
 &lt;phone:Pivot.HeaderTemplate&gt;
 &lt;DataTemplate&gt;
 &lt;TextBlock Text="{Binding Title}" /&gt;
 &lt;/DataTemplate&gt;
 &lt;/phone:Pivot.HeaderTemplate&gt;
 &lt;/phone:Pivot&gt;
&lt;/Grid&gt;
</code></pre>

<p>In the ItemRealized method of the LongListSelector, we decide on whether to load the next page of data or not, based on the current item that gets realized. We load the data if the item realized is third from the last in the current list of photos.We connect the ItemRealized method to the ViewModel code in the code behind.</p>

<pre><code class="csharp">    private void Photo_Loaded(object sender, ItemRealizationEventArgs e)
    {
        LongListSelector longList = sender as LongListSelector;
        PhotoCollectionViewModel vm = longList.DataContext as PhotoCollectionViewModel;

        vm.LoadMorePhotos(e.Container.Content as Photo);
    }

    public async Task LoadMorePhotos(Photo currentPhoto)
    {
        if (currentPhoto != null)
        {
            var index = this.Photos.IndexOf(currentPhoto);
            if (this.Photos.Count - 3 &gt; index)
            {
                return ;
            }
        }
        this.currentCollection = await this.incrementalLoader.LoadNextPage();

        foreach (var photo in this.currentCollection.photos)
        {
            this.Photos.Add(photo);
        }
    }
</code></pre>

<p>Whenver a user scrolls on a pivot the corresponding, ItemRealized methods gets called from which we call on to the load the data for that PhotoCollectionViewModel. This way each of the pivots are incrementally loaded as required.</p>

<p>The code for this is available <a href="https://github.com/rahulpnath/Blog/tree/master/IncrementalLoading">here</a>. Make sure you register for an application in the 500px api portal to get a consumer key that needs be updated in the solution for it to run.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows Phone Series – Incremental Loading]]></title>
    <link href="http://rahulpnath.com/blog/windows-phone-series-incremental-loading/"/>
    <updated>2013-03-03T08:53:45+00:00</updated>
    <id>http://rahulpnath.com/blog/windows-phone-series-incremental-loading</id>
    <content type="html"><![CDATA[<p>Some time back we had a look on doing <a href="http://rahulpnath.wordpress.com/2012/10/28/windows-8-series-incremental-loading/">Incremental Loading with a Windows 8 store app</a>. This same scenario is something that one would come across quite frequently while developing a Windows Phone application too. We have a couple of options in dealing with this while on a Windows phone application. In an ideal case while binding to a large data on a windows phone application, we might be using a <a href="http://msdn.microsoft.com/en-US/library/windowsphone/develop/microsoft.phone.controls.longlistselector(v=vs.105">LongListSelector</a>.aspx) or a Listbox control.</p>

<p>While using a LongListSelector, we can use the Link event(if you are using <a href="http://phone.codeplex.com/">Windows Phone 7.1 toolkit</a>) Or the <a href="http://msdn.microsoft.com/en-US/library/windowsphone/develop/microsoft.phone.controls.longlistselector.itemrealized(v=vs.105">ItemRealized</a>.aspx) event(if you are on Windows phone 8.0). Basically we would be doing the same thing in either of these cases, checking the current item that is getting realized and see what is the index of the item in the whole list of data that you have currently and check if its time for you to fetch the next set of data from your data source(possibly a web service). As usual for the sample we will be using the <a href="http://500px.com/popular">500px</a> api.</p>

<p>Below is the piece of code that will fetch us the photo from the <a href="http://developers.500px.com/">500px api</a> to populate the listbox data.</p>

<pre><code class="csharp">private static int requestPerPage = 20;
private int currentPage = 1;
private bool isCurrentlyLoading = false;

private ObservableCollection&lt;Photo&gt; Photos = new ObservableCollection&lt;Photo&gt;();

private string datasourceUrl="https://api.500px.com/v1/photos?feature=popular&amp;consumer_key=" 
          + consumerKey + "&amp;rpp=" + requestPerPage.ToString() + "&amp;page={0}";

private void LoadDataFromSource()
{
    isCurrentlyLoading = true;
    var query = string.Format(datasourceUrl, currentPage);
    WebClient client = new WebClient();
    client.DownloadStringCompleted += client_DownloadStringCompleted;
    client.DownloadStringAsync(new Uri(query));

}

void client_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)
{
    using (var reader = new MemoryStream(Encoding.Unicode.GetBytes(e.Result)))
    {
        var ser = new DataContractJsonSerializer(typeof(RootObject));
        RootObject obj = (RootObject)ser.ReadObject(reader);
        currentPage = obj.current_page + 1;
        if (obj != null)
        {
            this.Dispatcher.BeginInvoke(() =&gt;
                {
                    foreach (var photo in obj.photos)
                    {
                        Photos.Add(photo);
                    }
                    isCurrentlyLoading = false;
                });
        }
    }
}
</code></pre>

<p>In the ItemRealized/Link event based on whether you are developing for Windows Phone 7 or 8, below would be the code that goes into that. We need to check the current item that is realized i.e rendered on the UI and see if it is</p>

<pre><code class="csharp">private void photosList_ItemRealized_1(object sender, ItemRealizationEventArgs e)
{
    Photo photo = e.Container.Content as Photo;
    if (photo != null)
    {
        int offset = 2;
        // Only if there is no data that is currently getting loaded
        // would be initiate the loading again
        if (!isCurrentlyLoading &amp;&amp; Photos.Count - Photos.IndexOf(photo) &lt;= offset)
        {
            LoadDataFromSource();
        }
    }
}
</code></pre>

<p>In case you want to use a normal listbox, you can do that also. We would need to hook up with VisualStateGroups. This <a href="http://blogs.msdn.com/b/slmperf/archive/2011/06/30/windows-phone-mango-change-listbox-how-to-detect-compression-end-of-scroll-states.aspx">link</a> explains this in details, and I have just reused parts of it as is. We need to override the scrollviewer style to hook into this new StateGroups. We need to look for CompressionBottom state, for the currentstatechanged event of the scrollviewer.</p>

<pre><code class="csharp">private void myScrollViewer_Loaded_1(object sender, RoutedEventArgs e)
{
    SetScrollViewer();
}

private void SetScrollViewer()
{
    // Visual States are always on the first child of the control template 
    FrameworkElement element = VisualTreeHelper.GetChild(myScrollViewer, 0) 
                            as FrameworkElement;
    if (element != null)
    {
        VisualStateGroup vgroup = FindVisualState(element, "VerticalCompression");

        if (vgroup != null)
        {
            vgroup.CurrentStateChanging += 
                 new EventHandler&lt;VisualStateChangedEventArgs&gt;(vgroup_CurrentStateChanging);
        }
    }
}

private void vgroup_CurrentStateChanging(object sender, VisualStateChangedEventArgs e)
{
    if (e.NewState.Name == "CompressionTop")
    {

    }

    if (e.NewState.Name == "CompressionBottom")
    {
        if (!isCurrentlyLoading )
        {
            LoadDataFromSource();
        }
    }
    if (e.NewState.Name == "NoVerticalCompression")
    {

    }
}
</code></pre>

<p>You can use either of these two ways to incrementally load data on a windows phone app. The entire code that is used in this blog is avaialble <a href="https://github.com/rahulpnath/IncrementalLoadingPhone">here</a>. The sample app shows both these methods. The pivot header specifies the method that is used, LongListSelector and Scrollstates</p>

<p><img src="/wp_incremental_loading_longlistselector.jpg" alt="windows phone incremental loading using longlistselector" /><img src="/wp_incremental_loading_scrollstates.jpg" alt="windows phone incremental loading using scrollstates" /></p>

<p>Hope this helps you to incrementally load data on your windows phone application</p>

<p><a href="https://github.com/rahulpnath/IncrementalLoadingPhone">Download Code</a></p>
]]></content>
  </entry>
  
</feed>
