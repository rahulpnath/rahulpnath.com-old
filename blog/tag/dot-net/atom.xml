<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: .net | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/tag/dot-net/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2017-02-27T00:03:43+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Configuring Unity Container: Comparing Code and Xml Configuration Side by Side]]></title>
    <link href="http://rahulpnath.com/blog/configuring-unity-container-comparing-code-and-xml-configuration-side-by-side/"/>
    <updated>2014-10-19T11:42:54+00:00</updated>
    <id>http://rahulpnath.com/blog/configuring-unity-container-comparing-code-and-xml-configuration-side-by-side</id>
    <content type="html"><![CDATA[<p>Setting up dependency containers from code is very easy, but not at all the same when done using a configuration file. The project that I am currently working on uses xml configuration for <a href="https://unity.codeplex.com/">Unity container</a> and I did struggle mapping certain dependencies, so thought of putting this up.</p>

<p>To start with I have created a console application and added the Unity <a href="https://www.nuget.org/packages/Unity/">nuget package</a>. You could directly add the configurations in the app.config file, but I prefer to keep the configurations separately in a different file, <em>unity.config</em>, and have it referred in the app.config(or web.config). Also make sure that the unity.config file gets copied to the build directory(setting build properties as content and copy always should help) so that it is available to the application.</p>

<pre><code class="xml app.config">&lt;configSections&gt;
  &lt;section name="unity" type="Microsoft.Practices.Unity.Configuration.UnityConfigurationSection, Microsoft.Practices.Unity.Configuration"/&gt;
&lt;/configSections&gt;
&lt;unity configSource="unity.config" /&gt;
</code></pre>

<p>In the unity.config we need to specify the assemblies and namespaces that we will be injecting the dependencies from. Inside the container is where we register the dependencies.</p>

<p>&#8220;` xml unity.config
<unity xmlns="http://schemas.microsoft.com/practices/2010/unity"></p>

<!-- Define Assemblies-->


<p><assembly name="ConfiguringUnity" /></p>

<!-- End Assemblies-->


<!-- Define Namespaces-->


<p><namespace name="ConfiguringUnity" /></p>

<!-- End Namespaces-->


<p><container></p>

<p></container>
</unity>
&#8220;`</p>

<p>Now that we have the basic infrastructure set up to start using the container, lets take a look at some common dependency injection scenarios that we come across. The <a href="http://msdn.microsoft.com/en-us/library/ff660914(v=pandp.20).aspx">Unity Configuration Schema</a> is worth  taking a look, to understand about the configuration elements and their attributes.</p>

<p><strong>Simple Class and Interface</strong><br/>
<code>csharp C#
this.unityContainer.RegisterType&lt;NormalClass&gt;();
this.unityContainer.RegisterType&lt;INormalInterface, NormalInterfaceImplementation&gt;();
</code>
<code>xml unity.config
&lt;register type="NormalClass" /&gt;
&lt;register type="INormalInterface" mapTo="NormalInterfaceImplementation" /&gt;
</code>
Since we have only given the interface name while registering the type, specifying the assembly and namespace names of the type is important.Unity will look through these elements to find the type specified, whenever the specified type is not a full type name. This mechanism is also referred to as <a href="http://msdn.microsoft.com/en-us/library/ff660933(v=pandp.20).aspx#_Automatic_Type_Lookup">Automatic Type Lookup</a></p>

<p><strong>Generic Interface</strong>
<code>csharp C#
this.unityContainer.RegisterType(typeof(IGenericInterface&lt;&gt;), typeof(GenericInterfaceImplementation&lt;&gt;));
this.unityContainer.RegisterType(typeof(IGenericInterfaceWithTwoParameter&lt;,&gt;), typeof(GenericInterfaceWithTwoParametersImplementation&lt;,&gt;));
</code>
<code>xml unity.config
&lt;register type="IGenericInterface`1" mapTo="GenericInterfaceImplementation`1" /&gt;
&lt;register type="IGenericInterfaceWithTwoParameter`2" mapTo="GenericInterfaceWithTwoParametersImplementation`2" /&gt;
// or
&lt;register type="IGenericInterface[]" mapTo="GenericInterfaceImplementation[]" /&gt;
&lt;register type="IGenericInterfaceWithTwoParameter[,]" mapTo="GenericInterfaceWithTwoParametersImplementation[,]" /&gt;
</code>
As shown above registering <a href="http://msdn.microsoft.com/en-us/library/ff660933(v=pandp.20).aspx#_Generic_Types">generic types</a> in config can either use the CLR notation of <code>N, where N is the number of generic parameters or use square brackets with commas to indicate the number of parameters. Examples using one and two parameters are shown above.   
For a generic interface, the parameters can have typed parameter associated with it, something like *IComplexGenericInterface&lt;ComplexGenericClass&lt;GenericClass&gt;&gt;*. In these cases we cannot directly register this using either of the notation above, as the configuration does not allow recursive formats of those notation. We can use [Aliases](http://msdn.microsoft.com/en-us/library/ff660933(v=pandp.20\).aspx#_Type_Aliases) for specifying the parameter type names and then refer the alias for registering the interface.
<figure class='code'><figcaption><span>C#</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">this</span><span class="p">.</span><span class="n">unityContainer</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">IComplexGenericInterface</span><span class="p">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">ComplexGenericClass</span><span class="p">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">GenericClass</span><span class="p">&amp;</span><span class="n">gt</span><span class="p">;&amp;</span><span class="n">gt</span><span class="p">;,</span> <span class="n">ComplexGenericInterfaceImplementation</span><span class="p">&amp;</span><span class="n">gt</span><span class="p">;();</span>
</span></code></pre></td></tr></table></div></figure>
&#8220;`xml unity.config
 &lt;alias alias=&#8221;ComplexGenericInterfaceType&#8221;
         type=&#8221;ConfiguringUnity.ComplexGenericClass</code>1[[ConfiguringUnity.GenericClass, ConfiguringUnity, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], ConfiguringUnity, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&#8221; />
<container>
  <register type="IComplexGenericInterface[ComplexGenericInterfaceType]" mapTo="ComplexGenericInterfaceImplementation" />
</container>
&#8220;`
As shown above alias is nothing but a shorthand name that will be replaced with the full type name when the configuration is loaded. This is only available at configuration time and not at runtime.</p>

<p><strong>Conflicting Interfaces</strong> <br/>
When you have conflicting interface names , probably from two different assemblies then you can create aliases or use full names to register the types. For the example I have created a class library project, ExternalLibrary and added it as a reference to the Console Application.
<code>csharp C#
this.unityContainer.RegisterType&lt;IConflictingInterface, ConflictingInterfaceImplementation&gt;();
            this.unityContainer.RegisterType&lt;ExternalLibrary.IConflictingInterface, ExternalLibrary.ConflictingInterfaceImplementation&gt;();
</code>
<code>xml unity.config
&lt;register type="IConflictingInterface" mapTo="ConflictingInterfaceImplementation" /&gt;
&lt;register type="ExternalLibrary.IConflictingInterface, ExternalLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" mapTo="ExternalLibrary.ConflictingInterfaceImplementation, ExternalLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" /&gt;
</code></p>

<h4><strong><em>Code and Config</em></strong> instead of <strong><em>Code Vs Config</em></strong></h4>

<p>Now that we have seen some of the common usage scenarios in registering types with containers, one main thought would be &lsquo;<a href="http://stackoverflow.com/questions/5418392/should-unity-be-configured-in-code-or-configuration-file">Should Unity be configured in code or configuration file?</a>&rsquo;. Xml configurations are anytime a pain for the developer as it more prone to errors and configuration complexities. But then there are scenarios where dependencies would have to be plugged in at runtime, for which xml configuration is really helpful. Unity does allow to specify both together, making the best use of both worlds. You can choose to have only your dependencies that are Late Bound in the config and have all others in the code. You could also override an already registered dependency.
<code>csharp C#
this.unityContainer.RegisterType&lt;IOverridableDependency, OverridableCodeImplementation&gt;();
</code>
<code>xml unity.config
&lt;register type="IOverridableDependency" mapTo="OverridableConfigImplementation" /&gt;
</code>
As shown above we have a different mapping in code and config for the same interface and I am loading the configuration into the container after all the  code registrations are done. In this case the dependency that is registered last will take precedence. So you could use this feature to override any dependencies specified in the code.</p>

<p>There surely are a lot more cases that you would have come across while registering dependencies, do drop in a comment on the missing ones. The sample for this can be found <a href="https://github.com/rahulpnath/Blog/tree/master/ConfiguringUnity">here</a>
<a href="http://www.codeproject.com" style="display:none" rel="tag">CodeProject</a></p>
]]></content>
  </entry>
  
</feed>
