<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: IoC | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/tag/ioc/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2017-03-01T04:58:14+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[IsRegistered on Unity Container for Generic Type]]></title>
    <link href="http://rahulpnath.com/blog/isregistered-on-unity-container-for-generic-type/"/>
    <updated>2015-01-14T22:31:51+00:00</updated>
    <id>http://rahulpnath.com/blog/isregistered-on-unity-container-for-generic-type</id>
    <content type="html"><![CDATA[<p><em>This post just describes a bug that is there in the Unity (3.5.1404) IoC container, when using the IsRegistered extension method, to check for generic types and a possible fix for it.</em></p>

<p><a href="http://msdn.microsoft.com/en-us/library/ff647202.aspx">Unity</a> IoC container provides <a href="http://msdn.microsoft.com/en-us/library/microsoft.practices.unity.unitycontainerextensions.isregistered(v=pandp.51).aspx">IsRegistered</a> extension method, that can be used to check whether a registration exists for a given type and name (can be null too) combination. When a generic type is registered in the container and trying to check IsRegistered using a concrete typed version of the generic interface it returns false.</p>

<p>As shown in the below code snippet, calling IsRegistered on a non-generic interface(<em>IFooBar</em>) returns true, indicating that a registration exists. But for the generic interface(<em>IFooGeneric&lt;></em>), trying to check if a registration exists for a concrete type (<em>IFooGeneric<string></em> - as only concrete types can be resolved from the container and an open generic type cannot be resolved) it returns false.</p>

<pre><code class="csharp">IUnityContainer unityContainer = new UnityContainer();
unityContainer.RegisterType(typeof(IFooBar), typeof(FooBarImplementation));
unityContainer.RegisterType(typeof(IFooGeneric&lt;&gt;), typeof(FooGenericImplementation&lt;&gt;));

var hasFooBarRegistration = unityContainer.IsRegistered&lt;IFooBar&gt;(); // Returns true

var hasFooGenericStringRegistration = unityContainer.IsRegistered&lt;IFooGeneric&lt;string&gt;&gt;(); // Returns False
var fooGenericString = unityContainer.Resolve&lt;IFooGeneric&lt;string&gt;&gt;(); // Resolution Succeeds
</code></pre>

<p>The <a href="https://unity.codeplex.com/SourceControl/latest#source/Unity/Src/UnityContainerExtensions.cs">IsRegistered method </a> as shown below, loops through the list of available registrations looking for a match on the registered type and name. The &lsquo;<em>typeToCheck</em>&rsquo; is the type of the object that we are trying to resolve in IsRegistered - <em>typeof(IFooGeneric<string>)</em>, but the registered type is <em>typeof(IFooGeneric&lt;>)</em>. Because of this the comparison fails and the registration does not pass the where clause of the query, causing the function to return <em>false</em>.</p>

<pre><code class="csharp">var registration = from r in container.Registrations
                   where r.RegisteredType == typeToCheck &amp;&amp; r.Name == nameToCheck
                   select r;
return registration.FirstOrDefault() != null;
</code></pre>

<p>To fix this, we would need to modify the where condition so that in cases where the RegisteredType is a generic type definition, it would compare with the generic type definition of &lsquo;<em>typeToCheck</em>&rsquo;, as shown below.</p>

<pre><code class="csharp">var genericTypeToCheck = typeToCheck.GetTypeInfo().IsGenericType
                         ? typeToCheck.GetGenericTypeDefinition()
                         : null;

var registration = from r in container.Registrations
                   where (r.RegisteredType.GetTypeInfo().IsGenericTypeDefinition
                   ? r.RegisteredType == genericTypeToCheck
                   : r.RegisteredType == typeToCheck)
                   &amp;&amp; r.Name == nameToCheck
                   select r;
return registration.FirstOrDefault() != null;
</code></pre>

<p>A similar <a href="https://unity.codeplex.com/discussions/568979">issue</a> was already raised in the unity discussions, which I feel was closed inappropriately.</p>

<blockquote><p>If a container can Resolve a particular type then it should also be able to return that it IsRegistered.</p></blockquote>

<p>Please do be aware that using IsRegistered extensively has a <a href="http://unity.codeplex.com/discussions/268223">negative impact on performance</a> as looping through the Registration looking for the name and type has <a href="http://en.wikipedia.org/wiki/Big_O_notation">O(n) complexity</a>. But that still does not justify the bug!.</p>

<p><em>I have submitted a <a href="https://unity.codeplex.com/SourceControl/network/forks/rahulpnath/isRegisteredForGenericTypes/contribution/7903">pull request</a> for the fix and it would be worth checking the latest comments on that to see if there are any better approaches or problems that I might have missed out with my fix!</em>
<a href="http://www.codeproject.com" style="display:none" rel="tag">CodeProject</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IoC Registration by Convention]]></title>
    <link href="http://rahulpnath.com/blog/ioc-registration-by-convention/"/>
    <updated>2015-01-03T18:03:17+00:00</updated>
    <id>http://rahulpnath.com/blog/ioc-registration-by-convention</id>
    <content type="html"><![CDATA[<p>Sometime back we had seen, how to <a href="http://www.rahulpnath.com/blog/configuring-unity-container-comparing-code-and-xml-configuration-side-by-side/">configure the unity container using code/config file</a> and I was using a mix of this in one of my projects. This approach soon became an overhead, as the manual wiring up of registrations is really cumbersome and also error prone. Mostly there were missing registrations only to be found out, when doing test runs or deployments. We soon were forced to move out of the manual registration and find a new way to register dependencies.</p>

<p>The below image by <a href="https://twitter.com/ploeh">Mark Seemann</a> sums it all up on when and how to use a Dependency Injection(DI) container and we were right at the bottom, where the whole purpose of a DI becomes pointless.</p>

<p><a href="http://bit.ly/1zLiq6p" class="center" title="Image By Mark Seemann, from http://bit.ly/1zLiq6p"><img src="http://rahulpnath.com/images/ioc_usefulness.png" class="center" alt="Image By Mark Seemann, from http://bit.ly/1zLiq6p"></a></p>

<h4>Convention Over Configuration</h4>

<p><a href="http://en.wikipedia.org/wiki/Convention_over_configuration">Convention over configuration</a>, is very popular today and there are already many frameworks that have adopted it e.g. MVC, Web Api. Following the same approach would make life much simpler and registration less painful as dependencies would get auto registered, if the convention is followed. Conventions could vary across projects/teams, so it is up to the team to decide on the conventions that are to be followed and have all the developers follow them religiously.</p>

<p>Currently our registration process picks up all the assemblies from the base path and iterates through all the classes that are under the project/application namespace and gets the interfaces out of them and registers them. For interfaces that have multiple definitions we perform named registration based on the class name or name from an attribute on the class or both.</p>

<p>We are using Unity as the IoC container and it does support <a href="http://msdn.microsoft.com/en-us/library/dn507479(v=pandp.30).aspx">convention based registrations</a> out of the box. You can either use the RegisterTypes method or the RegistrationConvention class to specify the conventions. The parameters in both of these approaches enable you to specify the types to register, the mappings to create, the name to use and lifetime. Since in our registration we wanted to use the named convention only in cases where there where multiple registrations for the same interface and the other interfaces were to be registered without any name this default convention had to be modified. Also we did not want to get tightly bound to the IoC container (just in case we want to swap out the container provider) and hence thought of having the convention logics in a separate class and have them registered to the container of choice.</p>

<p>The <em>GetClassesFromAssemblies</em> function iterates over the assemblies from the base application path(bin folder) to get all the dll&rsquo;s used and gets the classes that belong to the namespaces that we want to register. Alternatively you could also pass a list of assemblies if required to be used for the convention. If you want other namespaces too you can filter those in here.</p>

<pre><code class="csharp">private static IEnumerable&lt;Type&gt; GetClassesFromAssemblies(IEnumerable&lt;Assembly&gt; assemblies = null)
{
    var allClasses = assemblies != null ? AllClasses.FromAssemblies(assemblies) : AllClasses.FromAssembliesInBasePath();
    return
        allClasses.Where(
            n =&gt;
                n.Namespace != null
                &amp;&amp; n.Namespace.StartsWith(ApplicationNamespace, StringComparison.InvariantCultureIgnoreCase));
}                                                                                                        
</code></pre>

<p>For each of the type that is returned from the above method we get the list of interfaces that are defined on the type and needs to be registered against the type. In the sample code, I have added a couple of variations of registrations.</p>

<ul>
<li><em>IFooBar</em>        : Has only one implementation</li>
<li><em>IFoo</em>           : Has multiple implementations and should be resolved using <em>IFooFactory</em></li>
<li><em>IFooCustom</em>     : Has multiple implementations and needs to have a custom name (maybe for some reason you do not want the context information to be part of the class name). This is to be resolved using IFooCustomFactory.</li>
<li><em>IFooGeneric<T></em> : This is a generic implementation and the type can be decided at runtime.</li>
</ul>


<p>The <em>GetInterfacesToBeRegistered</em> function gets the interfaces that are to be registered for a given type. For this convention I want to <a href="http://stackoverflow.com/questions/5318685/get-only-direct-interface-instead-of-all">get only the direct interfaces</a> that are on the given type and not all the interfaces. The check below for <em>isGenericType</em> on an interface is for <em>IFooGeneric</em> as for generic interfaces the <a href="http://stackoverflow.com/questions/3117090/getinterfaces-returns-generic-interface-type-with-fullname-null">GetInterfaces does not return the full information required</a> and we need to use the <em>GetGenericTypeDefinition</em> method instead.</p>

<pre><code class="csharp">private static IEnumerable&lt;Type&gt; GetInterfacesToBeRegistered(Type type)
{
    var allInterfacesOnType = type.GetInterfaces()
        .Select(i =&gt; i.IsGenericType ? i.GetGenericTypeDefinition() : i).ToList();

    return allInterfacesOnType.Except(allInterfacesOnType.SelectMany(i =&gt; i.GetInterfaces())).ToList();
}
</code></pre>

<p>Once we have the interfaces for the type, we add them to an internal mapping list to register it all into the unity container. The internal mapping is against the interface type definition and has the list of classes that implements the interface.Now that we have all the types and interfaces to be registered, we need to register them into the container. For any interface that has only one type implementing it, we register it with default name else we get the name from the class name or the attribute that decorates the class if any.</p>

<pre><code class="csharp">private static void RegisterConventions(IUnityContainer container)
{
    foreach (var typeMapping in internalTypeMapping)
    {
        if (typeMapping.Value.Count == 1)
        {
            var type = typeMapping.Value.First();
            container.RegisterType(typeMapping.Key, type);
        }
        else
        {
            foreach (var type in typeMapping.Value)
            {
                container.RegisterType(typeMapping.Key, type, GetNameForRegsitration(type));
            }
        }
    }
}
</code></pre>

<p>The dependency with UnityContainer with the IoCConveniton class, can be easily removed by having an adapter interface into any container. To keep things simple I am having the direct dependency on the container in the sample. From the console application we can create a new container and use the convention class to register the dependencies. The factory implementations have the expected class conventions inside them that would be used to resolve the dependencies. Since the factory is part of the composition root I am using a <a href="http://blog.ploeh.dk/2012/03/15/ImplementinganAbstractFactory/">container based factory</a>, to resolve the dependencies.</p>

<pre><code class="csharp">IUnityContainer unityContainer = new UnityContainer();
IoCConvention.RegisterByConvention(unityContainer);
</code></pre>

<p>This has really taken off a lot of work for all the developers in the team and registrations of dependencies works seamlessly. You can find the sample convention implementation <a href="https://github.com/rahulpnath/Blog/tree/master/IocConventionRegistration">here</a>. Are you using convention registrations in your applications? If not you should start using them.
<a href="http://www.codeproject.com" style="display:none" rel="tag">CodeProject</a></p>
]]></content>
  </entry>
  
</feed>
