<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 500px | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/tag/500px/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2016-04-05T13:48:55+10:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Windows Phone Series – Incremental Loading]]></title>
    <link href="http://rahulpnath.com/blog/windows-phone-series-incremental-loading/"/>
    <updated>2013-03-03T19:53:45+11:00</updated>
    <id>http://rahulpnath.com/blog/windows-phone-series-incremental-loading</id>
    <content type="html"><![CDATA[<p>Some time back we had a look on doing <a href="http://rahulpnath.wordpress.com/2012/10/28/windows-8-series-incremental-loading/">Incremental Loading with a Windows 8 store app</a>. This same scenario is something that one would come across quite frequently while developing a Windows Phone application too. We have a couple of options in dealing with this while on a Windows phone application. In an ideal case while binding to a large data on a windows phone application, we might be using a <a href="http://msdn.microsoft.com/en-US/library/windowsphone/develop/microsoft.phone.controls.longlistselector(v=vs.105">LongListSelector</a>.aspx) or a Listbox control.</p>

<p>While using a LongListSelector, we can use the Link event(if you are using <a href="http://phone.codeplex.com/">Windows Phone 7.1 toolkit</a>) Or the <a href="http://msdn.microsoft.com/en-US/library/windowsphone/develop/microsoft.phone.controls.longlistselector.itemrealized(v=vs.105">ItemRealized</a>.aspx) event(if you are on Windows phone 8.0). Basically we would be doing the same thing in either of these cases, checking the current item that is getting realized and see what is the index of the item in the whole list of data that you have currently and check if its time for you to fetch the next set of data from your data source(possibly a web service). As usual for the sample we will be using the <a href="http://500px.com/popular">500px</a> api.</p>

<p>Below is the piece of code that will fetch us the photo from the <a href="http://developers.500px.com/">500px api</a> to populate the listbox data.</p>

<pre><code class="csharp">private static int requestPerPage = 20;
private int currentPage = 1;
private bool isCurrentlyLoading = false;

private ObservableCollection&lt;Photo&gt; Photos = new ObservableCollection&lt;Photo&gt;();

private string datasourceUrl="https://api.500px.com/v1/photos?feature=popular&amp;consumer_key=" 
          + consumerKey + "&amp;rpp=" + requestPerPage.ToString() + "&amp;page={0}";

private void LoadDataFromSource()
{
    isCurrentlyLoading = true;
    var query = string.Format(datasourceUrl, currentPage);
    WebClient client = new WebClient();
    client.DownloadStringCompleted += client_DownloadStringCompleted;
    client.DownloadStringAsync(new Uri(query));

}

void client_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)
{
    using (var reader = new MemoryStream(Encoding.Unicode.GetBytes(e.Result)))
    {
        var ser = new DataContractJsonSerializer(typeof(RootObject));
        RootObject obj = (RootObject)ser.ReadObject(reader);
        currentPage = obj.current_page + 1;
        if (obj != null)
        {
            this.Dispatcher.BeginInvoke(() =&gt;
                {
                    foreach (var photo in obj.photos)
                    {
                        Photos.Add(photo);
                    }
                    isCurrentlyLoading = false;
                });
        }
    }
}
</code></pre>

<p>In the ItemRealized/Link event based on whether you are developing for Windows Phone 7 or 8, below would be the code that goes into that. We need to check the current item that is realized i.e rendered on the UI and see if it is</p>

<pre><code class="csharp">private void photosList_ItemRealized_1(object sender, ItemRealizationEventArgs e)
{
    Photo photo = e.Container.Content as Photo;
    if (photo != null)
    {
        int offset = 2;
        // Only if there is no data that is currently getting loaded
        // would be initiate the loading again
        if (!isCurrentlyLoading &amp;&amp; Photos.Count - Photos.IndexOf(photo) &lt;= offset)
        {
            LoadDataFromSource();
        }
    }
}
</code></pre>

<p>In case you want to use a normal listbox, you can do that also. We would need to hook up with VisualStateGroups. This <a href="http://blogs.msdn.com/b/slmperf/archive/2011/06/30/windows-phone-mango-change-listbox-how-to-detect-compression-end-of-scroll-states.aspx">link</a> explains this in details, and I have just reused parts of it as is. We need to override the scrollviewer style to hook into this new StateGroups. We need to look for CompressionBottom state, for the currentstatechanged event of the scrollviewer.</p>

<pre><code class="csharp">private void myScrollViewer_Loaded_1(object sender, RoutedEventArgs e)
{
    SetScrollViewer();
}

private void SetScrollViewer()
{
    // Visual States are always on the first child of the control template 
    FrameworkElement element = VisualTreeHelper.GetChild(myScrollViewer, 0) 
                            as FrameworkElement;
    if (element != null)
    {
        VisualStateGroup vgroup = FindVisualState(element, "VerticalCompression");

        if (vgroup != null)
        {
            vgroup.CurrentStateChanging += 
                 new EventHandler&lt;VisualStateChangedEventArgs&gt;(vgroup_CurrentStateChanging);
        }
    }
}

private void vgroup_CurrentStateChanging(object sender, VisualStateChangedEventArgs e)
{
    if (e.NewState.Name == "CompressionTop")
    {

    }

    if (e.NewState.Name == "CompressionBottom")
    {
        if (!isCurrentlyLoading )
        {
            LoadDataFromSource();
        }
    }
    if (e.NewState.Name == "NoVerticalCompression")
    {

    }
}
</code></pre>

<p>You can use either of these two ways to incrementally load data on a windows phone app. The entire code that is used in this blog is avaialble <a href="https://github.com/rahulpnath/IncrementalLoadingPhone">here</a>. The sample app shows both these methods. The pivot header specifies the method that is used, LongListSelector and Scrollstates</p>

<p><img src="/wp_incremental_loading_longlistselector.jpg" alt="windows phone incremental loading using longlistselector" /><img src="/wp_incremental_loading_scrollstates.jpg" alt="windows phone incremental loading using scrollstates" /></p>

<p>Hope this helps you to incrementally load data on your windows phone application</p>

<p><a href="https://github.com/rahulpnath/IncrementalLoadingPhone">Download Code</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows 8 Series - Incremental Loading]]></title>
    <link href="http://rahulpnath.com/blog/windows-8-series-incremental-loading/"/>
    <updated>2012-10-29T01:41:31+11:00</updated>
    <id>http://rahulpnath.com/blog/windows-8-series-incremental-loading</id>
    <content type="html"><![CDATA[<p>Fast and fluid experience is one of the most important characteristics of a Windows 8 application. As the data becomes larger , it might not be always possible to get the entire data loaded before hand.We might want to have a incremental or sequential data loading so that the user has a better experience.
While developing windows 8 this can be easily achieved by using <a href="http://msdn.microsoft.com/en-us/library/windows/apps/Hh701916">ISupportIncrementalLoading</a>
interface which would load the data incrementally.The class that implements this should also implement the <a href="http://msdn.microsoft.com/en-us/library/system.collections.ilist.aspx">IList</a> and <a href="http://msdn.microsoft.com/en-us/library/system.collections.specialized.inotifycollectionchanged.aspx">INotifyColectionChanged</a>. A sample on how to implement this interface can be seen <a href="http://msdn.microsoft.com/en-us/library/windows/apps/Hh701916">here</a>.
Implementing these over and over for different data sources that you would want to load incrementally might soon become tedious and repetitive.So why not make up some generic classes that you could abstract away the task of loading the data incrementally. That&rsquo;s exactly what we would be looking into here.</p>

<p>First lets get the class that implements <a href="http://msdn.microsoft.com/en-us/library/windows/apps/Hh701916">ISupportIncrementalLoading</a>, IList and INotifyCollectionChanged. To keep things simple lets inherit from ObservableCollection,which in turn inherits the latter 2 interfaces</p>

<pre><code class="csharp">    public class IncrementalSource&lt;T, K&gt; : ObservableCollection&lt;K&gt;, ISupportIncrementalLoading
        where T: class
    {
        private string Query { get; set; }
        private int VirtualCount { get; set; }
        private int CurrentPage { get; set; }
        private IPagedSource&lt;T,K&gt; Source { get; set; }
        private int rpp { get; set; }

        public IncrementalSource(string query, Func&lt;T, IPagedResponse&lt;K&gt;&gt; GetPagedResponse)
        {
            this.Source = new PagedSourceLoader&lt;T, K&gt;(GetPagedResponse);
            this.VirtualCount = int.MaxValue;
            this.CurrentPage = 0;
            this.Query = query;
        }

        #region ISupportIncrementalLoading

        public bool HasMoreItems
        {
            get { return this.VirtualCount &gt; this.CurrentPage * (rpp == 0 ? 10 :rpp); }
        }

        public IAsyncOperation&lt;LoadMoreItemsResult&gt; LoadMoreItemsAsync(uint count)
        {
            CoreDispatcher dispatcher = Window.Current != null ? Window.Current.Dispatcher : Windows.ApplicationModel.Core.CoreApplication.MainView.CoreWindow.Dispatcher;
            if (count &gt; 50 || count &lt;= 0)
            {
                // default load count to be set to 50
                count = 50;
            }

            return Task.Run&lt;LoadMoreItemsResult&gt;(
                async () =&gt;
                {

                    IPagedResponse&lt;K&gt; result = await this.Source.GetPage(string.Format(this.Query,count), ++this.CurrentPage, (int)count);

                    this.VirtualCount = result.VirtualCount;
                    if (rpp == 0)
                    {
                        rpp = result.rpp;
                    }

                    await dispatcher.RunAsync(
                        CoreDispatcherPriority.Normal,
                        () =&gt;
                        {
                            foreach (K item in result.Items)
                                this.Add(item);
                        });

                    return new LoadMoreItemsResult() { Count = (uint)result.Items.Count() };

                }).AsAsyncOperation&lt;LoadMoreItemsResult&gt;();
        }

        #endregion
    }
</code></pre>

<p>Before going into the details of the code, lets understand what this class is going to do for us. We need to load data in a paged fashion from a large datasource. So we would generally be dealing with two types of object – one the type of object(<strong><em>K</em></strong>) whose list we are trying to load incrementally. Another one the type of object(<strong><em>T</em></strong>) that represents each paged request result. This object would ideally contain a property to hold list of objects of type K, the total number of items that the datasource would give us,so that we know how many pages we need to request for and also a property indicating the current page. Each datasource might return us these required properties in different property names and types. So we have a class to hold these data together for us, PagedResponse which implements IPagedResponse</p>

<pre><code class="csharp">    public interface IPagedResponse&lt;T&gt;
    {
        IEnumerable&lt;T&gt; Items { get; }
        int VirtualCount { get; }
        int rpp { get; set; } // rpp - requests per page
    }




    public class PagedResponse&lt;K&gt; : IPagedResponse&lt;K&gt;
    {
        public PagedResponse(IEnumerable&lt;K&gt; items, int virtualCount,int itemsPerPage)
        {
            this.Items = items;
            this.VirtualCount = virtualCount;
            rpp = itemsPerPage;
        }

        public int VirtualCount { get; private set; }
        public int rpp { get;  set; }
        public IEnumerable&lt;K&gt; Items { get; private set; }
    }
</code></pre>

<p>That said lets see the  <em>IncremetnalSource</em> class. It takes in the object type <strong><em>T </em></strong>and <strong><em>K.</em></strong>The constructor takes in the url where the datasource can be found.The Func&lt;T, IPagedResponse<K>> parameter represents a function that takes in the return type of the call to the url as a parameter and returns the PagedResponse type. In other words that function converts the paged request call type to the type that we use to represent it, IPagedResponse.See a sample below.</p>

<pre><code class="csharp">private PagedResponse&lt;Photo&gt; RootObjectResponse(RootObject rootObject)
{
    return new PagedResponse&lt;Photo&gt;(rootObject.photos, rootObject.total_items, rootObject.photos != null ? rootObject.photos.Count : 0);
}
</code></pre>

<p>Now we need to make the call to the datasource url. This might return us data in different formats, most popularly json or xml. So we would always want to abstract away the loading of data to another class so that we don’t get tied up with the data formats in <em>IncrementalSource.</em></p>

<p>IPagedSource&lt;T,K> will do this for us. A sample implementation of this is <em>PagedSourceLoader </em>that handles for json return type is below</p>

<pre><code class="csharp">    public interface IPagedSource&lt;R,K&gt;
    {
        Task&lt;IPagedResponse&lt;K&gt;&gt; GetPage(string query, int pageIndex, int pageSize);
    }




    public class PagedSourceLoader&lt;T,K&gt; : IPagedSource&lt;T,K&gt;
        where T:class 
    {
        private Func&lt;T, IPagedResponse&lt;K&gt;&gt; getPagedResponse;
        public PagedSourceLoader(Func&lt;T, IPagedResponse&lt;K&gt;&gt; GetPagedResponse)
        {
            getPagedResponse = GetPagedResponse;
        }

        #region IPagedSource

        public async Task&lt;IPagedResponse&lt;K&gt;&gt; GetPage(string query, int pageIndex, int pageSize)
        {
            query += "&amp;page="+pageIndex;
            HttpClient client = new HttpClient();
            HttpResponseMessage response = await client.GetAsync(query);
            var data = await response.Content.ReadAsStreamAsync();
            DataContractJsonSerializer json = new DataContractJsonSerializer(typeof(T));
            T dat = json.ReadObject(data) as T;
            return getPagedResponse(dat);
        }

        #endregion
    }
</code></pre>

<p>As you see above the <em>PagedSourceLoader</em> gets the json from the datasource url and converts to the type that we are interested in . You could always replace this class to use any other data format as you would want. Mostly you would just want one implementation for <em>IPagedSource&lt;T,K>, </em>as your data source would always return you the same data format. In case not you could inject that too into the <em>IncrementalSource</em> class.</p>

<p>I have a sample <a href="http://sdrv.ms/RdPtdL">here</a> that incrementally loads the photos from a photo site <a href="http://500px.com/flow">500px</a>. You would need to register for an to get the consumer key,which should hardly take some time <a href="http://500px.com/settings/applications?from=developers">here</a>.</p>

<p><img src="/windows8_incremental_loading.png" alt="windows8 incremental loading" /></p>

<p><a href="https://github.com/rahulpnath/Blog/tree/master/Windows8%20-%20IncrementalLoading">Download the sample source code</a></p>

<p>Keep a sample of the source code for yourself in case you wanted this specific version. I might refine this to a more usable library with couple of default <em>PagedSourceLoader.</em></p>

<p><strong>References:
</strong><a href="http://www.silverlightplayground.org/post/2012/06/10/Metro-Incrementally-load-GridView-and-ListView-with-ISupportIncrementalLoading.aspx">Metro: Incrementally load GridView and ListView with ISupportIncrementalLoading</a></p>

<p>Feel free to reuse it if you find it useful and drop a comment to refine it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows 8 Series - Exploring OAuth: c# and 500px]]></title>
    <link href="http://rahulpnath.com/blog/exploring-oauth-c-and-500px/"/>
    <updated>2012-10-05T22:00:27+10:00</updated>
    <id>http://rahulpnath.com/blog/exploring-oauth-c-and-500px</id>
    <content type="html"><![CDATA[<p>The days when we ourselves developed sites and application for our own services are long gone. Now it’s about building api’s, sharing data and going social that&rsquo;s the buzz. No more is it a feasible solution to build applications for the numerous devices, that varies in size,shape and by the software that runs in them. The best thing then would be to expose API’s so that anybody interested can build applications for you. In any case the last thing that you would want to share is your users credentials. This is where OAuth comes into picture. Put it simply OAuth is an open protocol that allows secure access to the data that you want to expose, usually the API.</p>

<p>Most of us would have seen OAuth in action. Whenever you logon to a site using any of the social network sites identity,be it Facebook or Twitter it’s OAuth that is behind the scenes that helps the site to get the required information from the social entity and you don’t have to disclose your social credentials to the site that you actually intended to visit. If you have never seen this now is a good time to. Try it <a href="http://500px.com/">here</a></p>

<p>Now that you have seen how it works lets dig deeper to see how to get this feature into the apps that you are building. There are a lot of c# libraries,so are for other languages, that will handle the OAuth part for you like some listed <a href="http://nuget.org/packages?q=oauth&amp;prerelease=&amp;sortOrder=package-download-count">here</a>, keeping the mystery unsolved.</p>

<p>I chose the web-api provided by <a href="http://developers.500px.com/">500px</a>, which does secure its data using OAuth. You can see the complete documentation of the api <a href="https://github.com/500px/api-documentation">here</a>. It is the Authentication part in that, that we would be concentrating here on, using OAuth 1.0</p>

<p><img src="/oauth_500px_authentication.png" alt="oauth_500px_authentication" /></p>

<p>On a high level as seen above,OAuth has 3 steps.    <br/>
1. Getting a request token     <br/>
2. Authorizing the user     <br/>
3. Getting the access token.</p>

<p>The access token is then used to access any protected resource.</p>

<p>The following definitions, as from the <a href="http://oauth.net/core/1.0/">OAuth specification</a> is worth knowing before we delve in</p>

<p><em>Service Provider:</em> A web application that allows access via OAuth.     <br/>
<em>User:</em> An individual who has an account with the Service Provider.     <br/>
<em>Consumer:</em> A website or application that uses OAuth to access the Service Provider on behalf of the User.     <br/>
<em>Protected Resource(s):</em> Data controlled by the Service Provider, which the Consumer can access through authentication.     <br/>
<em>Consumer Developer:</em> An individual or organization that implements a Consumer.     <br/>
<em>Consumer Key:</em> A value used by the Consumer to identify itself to the Service Provider.     <br/>
<em>Consumer Secret:</em> A secret used by the Consumer to establish ownership of the Consumer Key.     <br/>
<em>Request Token:</em> A value used by the Consumer to obtain authorization from the User, and exchanged for an Access Token.     <br/>
<em>Access Token:</em> A value used by the Consumer to gain access to the Protected Resources on behalf of the User, instead of using the User’s Service Provider credentials.     <br/>
<em>Token Secret:</em> A secret used by the Consumer to establish ownership of a given Token.     <br/>
<em>OAuth Protocol Parameters:</em> Parameters with names beginning with oauth_.</p>

<p>Before getting on to the steps we would need to register the application that is going to consume the web api, to get the Consumer Key and Consumer Secret required in OAuth.You can do that here for <a href="http://500px.com/settings/applications">500px</a>. All web-api’s supporting OAuth would have such a page, as registering provides us with the keys. If the application does not have a callback url, like in case you are developing for a phone or desktop application you can specify any url you want.</p>

<p><img src="/oauth_500px_application_details.png" alt="oauth_500px_application_details" /></p>

<p>The base URL for 500px web-api is ‘<a href="https://api.500px.com/v1/">https://api.500px.com/v1/</a>’. All further references to url’s would be relative to this</p>

<p><strong>Getting the Request Token</strong></p>

<p>To get the request token we need to make a POST request to <a href="https://github.com/500px/api-documentation/blob/master/authentication/POST_oauth_requesttoken.md"><em>oauth/request_token</em></a>, which expects the parameters <em>CallbackUrl,ConsumerKey,Nonce,SignatureMethod,Timestamp and OAuthVersion. </em>All these should be in the same order,i.e alphabetical. All these parameters needs to be signed using the consumer secret and the signature too needs to be attached in the request data. This data goes as part of the ‘<em>Authorization’</em> header of the request.</p>

<pre><code class="csharp">    public async Task&lt;OauthToken&gt; RequestToken() 
           { 
               AuthorizationParameters = new Dictionary&lt;string, string&gt;(){                                
                                 {OauthParameter.OauthCallback, OAuthCallbackUrl}, 
                                 {OauthParameter.OauthConsumerKey, consumerKey}, 
                                 {OauthParameter.OauthNonce, Nonce()}, 
                                 {OauthParameter.OauthSignatureMethod,OAuthSignatureMethod}, 
                                 {OauthParameter.OauthTimestamp, TimeStamp()}, 
                                 {OauthParameter.OauthVersion, OAuthVersion} 
                                   }; 
               string response = await this.MakeRequest(RequestType.POST) 
                   .Sign(OAuthRequestUrl, String.Empty) 
                   .ExecuteRequest(OAuthRequestUrl); 

    ……… 
</code></pre>

<p>The above function handles adding the parameters required and executing the request.</p>

<p>The <em>MakeRequest</em> call specifies the kind of HTTP call that you want to make, here it being a POST. The call to the function <em>Sign, </em>signs the parameters and adds the signature details to the parameter list. It uses the same signature method as specified in the parameter list, <em>HMAC-SHA1</em></p>

<pre><code class="csharp    ">    private Oauth500px Sign(string Url, string tokenSecret) 
           { 
               String SigBaseStringParams = String.Join("&amp;", AuthorizationParameters.Select(key =&gt; key.Key + "=" + Uri.EscapeDataString(key.Value))); 
               String SigBaseString = requestType.ToString() + "&amp;"; 
               SigBaseString += Uri.EscapeDataString(Url) + "&amp;" + Uri.EscapeDataString(SigBaseStringParams);

               IBuffer KeyMaterial = CryptographicBuffer.ConvertStringToBinary(consumerSecret + "&amp;" + tokenSecret, BinaryStringEncoding.Utf8); 
               MacAlgorithmProvider HmacSha1Provider = MacAlgorithmProvider.OpenAlgorithm(OAuthSignatureMethodName); 
               CryptographicKey MacKey = HmacSha1Provider.CreateKey(KeyMaterial); 
               IBuffer DataToBeSigned = CryptographicBuffer.ConvertStringToBinary(SigBaseString, BinaryStringEncoding.Utf8); 
               IBuffer SignatureBuffer = CryptographicEngine.Sign(MacKey, DataToBeSigned); 
               String Signature = CryptographicBuffer.EncodeToBase64String(SignatureBuffer); 
               AuthorizationParameters.Add(OauthParameter.OauthSignature, Signature); 
               return this; 
           } 
</code></pre>

<p>The <em>ExecueRequest</em> handles adding the details to the authorization header and making the request and returning the response.</p>

<p>A successful call to request token will return <em>Request Token</em> and a <em>token secret </em>which is to be used in the subsequent call to Authorize</p>

<p><strong>Authorize</strong></p>

<p>The call to authorize brings up the login page of the Service Provider(500px),if the user is not already logged in and is used to authorize the request token that has been just obtained. The request to authorize is to be made at <a href="https://github.com/500px/api-documentation/blob/master/authentication/POST_oauth_authorize.md">oauth/authorize</a>, with the request token received in the previous call.</p>

<pre><code class="csharp    ">    public async Task&lt;OauthToken&gt; AuthorizeToken() 
           { 
               var tempAuthorizeUrl = OAuthAuthorizeUrl + "?oauth_token=" + Token.Token;
               System.Uri StartUri = new Uri(tempAuthorizeUrl); 
               System.Uri EndUri = new Uri(OAuthCallbackUrl);
               var auth = 
                   await 
                   WebAuthenticationBroker.AuthenticateAsync(WebAuthenticationOptions.None, StartUri, EndUri);
               var responseData = auth.ResponseData;
</code></pre>

<p>Since this is for Windows8 I use the WebAuthenticationBroker to issue the request to authorize the user, which will open up a nice UI asking the user credentials. On entering the login details and getting successfully authorized, we would get the <em>request token</em> and the <em>oauth_verifier</em> code.</p>

<p><strong>Access Token</strong></p>

<p>This final step gives you the access token, that is used for any request to a protected resource. A POST request it to made to the url <a href="https://github.com/500px/api-documentation/blob/master/authentication/POST_oauth_accesstoken.md">oauth/access_token</a>, with the parameters <em>ConsumerKey, Nonce, SignatureMethod, Timestamp, RequestToken, VerifierCode and OAuthVersion, </em>again all alphabetical sorted and signed using the consumer key and token secret that we got in the call to request token.</p>

<pre><code class="csharp    ">    public async Task&lt;OauthToken&gt; AccessToken() 
           { 
               AuthorizationParameters = new Dictionary&lt;string, string&gt;() 
                       { 
                           {OauthParameter.OauthConsumerKey, consumerKey}, 
                           {OauthParameter.OauthNonce, Nonce()}, 
                           {OauthParameter.OauthSignatureMethod,OAuthSignatureMethod}, 
                           {OauthParameter.OauthTimestamp, TimeStamp()}, 
                           {OauthParameter.OauthToken,Token.Token}, 
                           {OauthParameter.OauthVerifier,Token.Verifier}, 
                           {OauthParameter.OauthVersion, OAuthVersion} 
                       }; 
               var response = await this.MakeRequest(RequestType.POST) 
                   .Sign(OAuthAccessUrl, Token.SecretCode) 
                   .ExecuteRequest(OAuthAccessUrl);

    ……. 
</code></pre>

<p>The SecretCode, that was obtained from the call to Requesttoken is also passed to the function <em>Sign</em>.</p>

<p>A successful call would return you the AccessToken and the Access token’s secret code for that. All subsequent request to any protected resource needs the AccessToken and should be signed using ConsumerKey and the access token’s secret code.</p>

<p>From now on any request to a protected resource should be made with the following parameters: <em>ConsumerKey,Nonce,SignatureMethod,Timestamp,OAuthToken and OAuthVersion</em> along with any additional parameters<em>. </em>This should be signed using the consumer secret and the access token secret code.</p>

<p>The ExecuteRequest handles for this and is a genenric function that would allow you to specify the return type that you are expecting and the Url of the protected resource</p>

<pre><code class="csharp ">
    public async Task&lt;T&gt; ExecuteRequest&lt;T&gt;(string Url, Dictionary&lt;string, string&gt; Parameters) where T : class 
         { 
             AuthorizationParameters = new Dictionary&lt;string, string&gt;() 
                                           { 
                                               {OauthParameter.OauthConsumerKey, consumerKey}, 
                                               {OauthParameter.OauthNonce, Nonce()}, 
                                               {OauthParameter.OauthSignatureMethod, OAuthSignatureMethod}, 
                                               {OauthParameter.OauthTimestamp, TimeStamp()}, 
                                               {OauthParameter.OauthToken, Token.Token}, 
                                               {OauthParameter.OauthVersion, OAuthVersion} 
                                           };

             string RequestUrl; 
             if (Parameters != null &amp;&amp; Parameters.Count &gt; 0) 
             { 
                 RequestUrl = Url + "?" + 
                              String.Join("&amp;", 
                              Parameters.Select(a =&gt; a.Key + (string.IsNullOrEmpty(a.Value) ? string.Empty : "=" + Uri.EscapeDataString(a.Value))).ToArray()); 
                 foreach (var parameter in Parameters) 
                 { 
                     AuthorizationParameters.Add(parameter.Key, parameter.Value); 
                 } 
             } 
             else 
                 RequestUrl = Url; 
             var response = await this.MakeRequest(requestType).Sign(Url, Token.SecretCode).ExecuteRequest(RequestUrl); 
             if (string.IsNullOrEmpty(response)) 
                 return null; 
             DataContractJsonSerializer json = new DataContractJsonSerializer(typeof(T)); 
             T dat = json.ReadObject(new MemoryStream(Encoding.UTF8.GetBytes(response))) as T; 
             return dat; 
         }
</code></pre>

<p>A sample way to use this would be as below</p>

<pre><code class="csharp ">Oauth500Px.MakeRequest(Oauth500px.RequestType.GET).ExecuteRequest&amp;lt;PhotoDetails&amp;gt;( 
                    photoDetails, null);
</code></pre>

<p>The code for the OAuth wrapper for 500px specific toWindows8 is available <a href="https://github.com/rahulpnath/Blog/blob/master/Oauth500px.cs">here</a> for download. Feel free to modify it and use it. I will be refactoring the code out a bit more and also add a few functionalities. So in case you wanted this specific version do keep a copy for yourself.</p>

<p>PS: Incorporating an offline comment that I had got, on putting a space after each full stop and hope I have not missed any.</p>
]]></content>
  </entry>
  
</feed>
