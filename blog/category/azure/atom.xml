<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: azure | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/azure/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2017-01-22T00:05:39+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Could Not Load Assembly msshrtmi.dll?]]></title>
    <link href="http://rahulpnath.com/blog/could-not-load-assembly-msshrtmi-dll/"/>
    <updated>2016-06-19T17:38:37+00:00</updated>
    <id>http://rahulpnath.com/blog/could-not-load-assembly-msshrtmi-dll</id>
    <content type="html"><![CDATA[<p>While migrating a few Azure Cloud Services to Web Jobs, we started facing the error, <span style='color: red;'><em>Could not load assembly &hellip; /msshrtmi.dll</em></span>,for just one of the projects. The error provides the exact path from where it is trying to load the DLL and is the same path from which the process is running. But the location does have the <em>msshrtmi.dll</em>, which for some reason the process is not able to load.</p>

<p><img class="center" src="/images/msshrtmi_load_error.png" alt="msshrtmi dll load error" /></p>

<div class="alert alert-info" role="alert">
<strong>TL;DR</strong> This error occurred due to an attribute - <i>&lt;Prefer32Bit&gt;false&lt;/Prefer32Bit&gt;</i> - in the csproj file, while the referred msshrtmi dll was 32-bit version. This might not be applicable to you, but since it has happened once it&#8217;s very likely to happen again.
</div>


<p>To our surprise, this was happening only with a specific worker, while all others (around 8) were working fine. All of the workers are generated by the same build process on a server. For some reason (I am still investigating into this) the msshrtmi.dll is added as an external reference in the project and referred from there in all the project files. This was done mainly because we had a few external dependencies that were dependent on specific Azure SDK version (2.2). But this explicit reference should not have caused any issues as all, as the other processes were working fine and only a specific one was failing.</p>

<p>One useful tool to help diagnose why the .NET framework cannot locate assemblies is <a href="https://msdn.microsoft.com/en-us/library/e74a18c4(v=vs.110).aspx">Assembly Binding Log Viewer(Fuslogvw.exe)</a>. The viewer displays an entry for each failed assembly bind. For each failure, the viewer describes the application that initiated the bind; the assembly the bind is for, including name, version, culture and public key; and the date and time of the failure.</p>

<blockquote><p><em>Fuslogvw.exe is automatically installed with Visual Studio. To run the tool, use the Developer Command Prompt with administrator credentials.</em></p></blockquote>

<p>Running <em>fuslogvw</em> with the application shows the assembly binding error, double clicking which gives a details error information, as shown below. This error message gives more details and tells us that the assembly platform or ContentType is invalid.</p>

<p><img class="center" src="/images/msshrtmi_fuslogvw.png" alt="LOG: Assembly Name is: msshrtmi, Version=2.2.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
ERR: Invalid assembly platform or ContentType in file (hr = 0x8007000b).
ERR: Run-from-source setup phase failed with hr = 0x8007000b.
ERR: Failed to complete setup of assembly (hr = 0x8007000b). Probing terminated." /></p>

<p>In the Task Manager, the worker with the assembly loading error (last <em>worker</em> in the image below) shows as a 64-bit process, while the others as 32-bit. Since the referred msshrtmi DLL is 32-bit, it explains why it was unable to find the correct platform matching msshrtmi assembly.</p>

<p><img class="center" src="/images/msshrtmi_task_manager.png" alt="msshrtmi task manager" /></p>

<p><a href="https://msdn.microsoft.com/en-us/library/ms164699(v=vs.110).aspx">CorFlags.exe</a> is used to determine whether an .exe file or .dll file is meant to run only on a specific platform or under WOW64. Running the <em>corflags</em> on all the workers produces the below two results:</p>

<p><mark>corflags Problematic_Worker.exe</mark> <br/>
Version   : v4.0.30319 <br/>
CLR Header: 2.5 <br/>
PE        : PE32 <br/>
CorFlags  : 0x1  <br/>
ILONLY    : 1 <br/>
32BITREQ  : 0 <br/>
<mark>32BITPREF : 0</mark><br/>
Signed    : 0</p>

<p><mark>corflags Worker.exe</mark>    <br/>
Version   : v4.0.30319 <br/>
CLR Header: 2.5 <br/>
PE        : PE32 <br/>
CorFlags  : 0x20003 <br/>
ILONLY    : 1 <br/>
32BITREQ  : 0 <br/>
<mark> 32BITPREF : 1</mark>  <br/>
Signed    : 0</p>

<p>The <em>32BITPREF</em> flag is &lsquo;0&rsquo; for the worker that shows the error, whereas for the rest shows 1. The <a href="https://msdn.microsoft.com/en-us/library/ms164699(v=vs.110).aspx"><em>32BITPREF</em></a> flag indicates that the application runs as a 32 bit process even on 64-bit platforms. This explains why the problematic worker was running as 64-bit process since the flag is turned off.</p>

<blockquote><p><em><a href="http://blogs.microsoft.co.il/sasha/2012/04/04/what-anycpu-really-means-as-of-net-45-and-visual-studio-11/">From .NET 4.5 and Visual Studio 11</a>, the default for most .NET projects is again AnyCPU, but there is more than one meaning to AnyCPU now. There is an additional sub-type of AnyCPU, “Any CPU 32-bit preferred”, which is the new default (overall, there are now five options for the /platform C# compiler switch: x86, Itanium, x64, anycpu, and anycpu32bitpreferred). When using that flavor of AnyCPU, the semantics are the following:</em></p>

<ul>
<li><em>If the process runs on a 32-bit Windows system, it runs as a 32-bit process. IL is compiled to x86 machine code.</em></li>
<li><em>If the process runs on a 64-bit Windows system, it runs as a 32-bit process. IL is compiled to x86 machine code.</em></li>
<li><em>If the process runs on an ARM Windows system, it runs as a 32-bit process. IL is compiled to ARM machine code.</em></li>
</ul>
</blockquote>

<p>All the projects are getting built using the same build scripts, and we are not explicitly turning off/on this compiler option. So the next possible place where any setting for this flag is specified is the <em>csproj</em> file. On the properties of the worker project file (the one that shows error), I see that &lsquo;<em>Prefer 32-bit</em>&rsquo; option is not checked and the csproj file has it explicitly set to false (as shown below). For other projects, this option is checked in Visual Studio and has no entry in the csproj file, which means the flag defaults to true.</p>

<p><img class="center" src="/images/msshrtmi_prefer32bit.png" alt="msshrtmi prefer 32bit csproj" /></p>

<p><strong><em>Deleting the Prefer32Bit attribute from the csproj and building fixed the assembly loading issue of msshrtmi!</em></strong></p>

<p>Though this ended up being a minor fix (in terms of code change), I learned a lot of different tools that can be used to debug assembly loading issues. It was using these right tools that helped me identify this extra attribute on the csproj file and help solve the issue. So the next time you see such an error , either with mssrhtmi or another DLL, hope this helps to find your way through!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Managing Azure AD Application for Key Vault]]></title>
    <link href="http://rahulpnath.com/blog/managing-azure-ad-application-for-key-vault/"/>
    <updated>2015-06-27T19:13:48+00:00</updated>
    <id>http://rahulpnath.com/blog/managing-azure-ad-application-for-key-vault</id>
    <content type="html"><![CDATA[<blockquote><p>Please check <a href="http://www.rahulpnath.com/blog/how-the-deprecation-of-switch-azuremode-affects-azure-key-vault/">here</a> for scripts using the latest PowerShell cmdlets.</p></blockquote>

<p>Access to the Key Vault is secured using AD application token, as we had seen in the &lsquo;<a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">Authenticating a Client Application with Azure Key Vault</a>&rsquo;. Quite often administrators require to manage the AD application created, performing activities like creating new AD applications, changing the certificate used to authenticate with the AD application, remove a certificate or even delete an application. All of these are possible using PowerShell scripts and administrators can even run this as part of their automation scripts. With the latest Azure PowerShell version(0.9.2 or higher), the Key Vault cmdlet&rsquo;s are included automatically and does not require any additional installations. For managing the Azure AD application we need to <a href="https://msdn.microsoft.com/en-us/library/azure/jj151815.aspx#bkmk_installmodule">install the Azure AD module for PowerShell</a> and import them into the PowerShell command prompt.</p>

<h4><strong>Creating AD application</strong></h4>

<p>The <em><a href="https://msdn.microsoft.com/en-us/library/dn986794.aspx">New-AzureADApplication</a></em> cmdlet is used to create a new Azure AD application. It also provides an option to specify the certificate details used to authenticate with the AD application at the time of creation itself. This can be done as a separate step if required, which is shown later in the post.</p>

<p>First we need a certificate that is to be used for authenticating against the AD application, for which I use the below commands to generate a test certificate</p>

<pre><code class="text">makecert -sv mykey.pvk -n "cn=AD Test Vault Application" ADTestVaultApplication.cer -b 03/03/2014 -e 06/05/2017 -r -len 2048
pvk2pfx -pvk mykey.pvk -spc ADTestVaultApplication.cer -pfx ADTestVaultApplication.pfx -po test
</code></pre>

<p>This certificate is then used to create the AD application using the below script.</p>

<pre><code class="powershell">$certificateFilePath = "C:\certificates\ADTestVaultApplication.cer"
$certificate = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
$certificate.Import($certificateFilePath)
$rawCertificateData = $certificate.GetRawCertData()
$credential = [System.Convert]::ToBase64String($rawCertificateData)
$startDate= [System.DateTime]::Now
$endDate = $startDate.AddYears(1)
$adApplication = New-AzureADApplication -DisplayName "KeyVaultADApplication" 
  -HomePage  "http://www.rahulpnath.com" -IdentifierUris "http://www.rahulpnath.com"  
  -KeyValue  $credential -KeyType "AsymmetricX509Cert" -KeyUsage "Verify" 
  -StartDate $startDate -EndDate $endDate 
</code></pre>

<p>To associate the application created with the Key Vault, we need to create a service principal using <a href="https://msdn.microsoft.com/en-us/library/dn986799.aspx">New-AzureADServicePrincipal</a> and then associate that with the Vault using the <a href="https://msdn.microsoft.com/en-us/library/azure/dn903607.aspx">Set-AzureKeyVaultAccessPolicy</a></p>

<pre><code class="powershell">$servicePrincipal = New-AzureADServicePrincipal -ApplicationId $adApplication.ApplicationId
Set-AzureKeyVaultAccessPolicy -VaultName 'KeyVaultRahul' -ObjectId  $servicePrincipal.Id -PermissionsToKeys all -PermissionsToSecrets all
$ServicePrincipal.ApplicationId #Outputs the ServicePrincipalName/AppPrincipalId
</code></pre>

<h4><strong>Adding a Certificate</strong></h4>

<p>The <em><a href="https://msdn.microsoft.com/en-us/library/azure/dn194106.aspx">New-MsolServicePrincipalCredential</a></em> cmdlet is used to add a new credential to a service principal or to an application. The service principal is identified by supplying one of the following: object ID, appPrincipalID, service principal name (SPN).</p>

<pre><code class="powershell">$msolCredentials = get-credential
connect-msolservice -credential $msolCredentials
$certificateFilePath = "C:\certificates\ADTestVaultApplicationNew.cer"
$x509Certificate2 = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
$x509Certificate2.Import($certificateFilePath)
$rawCertData = $x509Certificate2.GetRawCertData()
$credentialValue = [System.Convert]::ToBase64String($rawCertData)
$startDate= [System.DateTime]::Now
$endDate = $startDate.AddYears(1)
New-MsolServicePrincipalCredential -ServicePrincipalName $ServicePrincipal.ApplicationId -Type Asymmetric -Value $credentialValue -StartDate $startDate -EndDate   $endDate 
</code></pre>

<h4><strong>Removing a Certificate</strong></h4>

<p>Whenever a credential gets compromised or as part of regular credential refresh, administrators would want to remove an old certificate and replace with a new one. The <a href="https://msdn.microsoft.com/en-us/library/azure/dn194125.aspx">Remove-MsolServicePrincipalCredential</a> cmdlet is used to remove a credential key from a service principal by specifying the key ID for the credential and the objectID/applicationID/ServicePrincipalName to identify the service principal. To get the key ID of an existing credential, <a href="https://msdn.microsoft.com/en-us/library/azure/dn194091.aspx">Get-MsolServicePrincipalCredential</a> cmdlet can be used, which returns the list of credentials associated with a service principal. The below script just removes the first credential, you could loop through and remove all.</p>

<pre><code class="powershell">$servicePrincipalCredential = Get-MsolServicePrincipalCredential -ServicePrincipalName $ServicePrincipal.ApplicationId -ReturnKeyValues 0
Remove-MsolServicePrincipalCredential -ServicePrincipalName $ServicePrincipal.ApplicationId -KeyIds $servicePrincipalCredential[0].KeyId
</code></pre>

<h4><strong>Delete an application</strong></h4>

<p>The <a href="https://msdn.microsoft.com/en-us/library/azure/dn194113.aspx">Remove-MsolServicePrincipal</a> cmdlet removes a service principal from Microsoft Azure Active Directory, by specifying objectID/applicationID/ServicePrincipalName to identify the service principal.</p>

<pre><code class="powershell">Remove-MsolServicePrincipal -ObjectId &lt;Guid&gt;
Or
Remove-MsolServicePrincipal -AppPrincipalId &lt;Guid&gt;
Or
Remove-MsolServicePrincipal -ServicePrincipalName &lt;string&gt;
</code></pre>

<p>Managing the AD application is a very important and necessary process in the life cycle of a Key Vault, as the access to the Vault is controlled using that. Certificates securing the AD applciation should be rolled/updated frequently and application permissions should be reviewed often to make sure that all applications have only the required permissions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Azure Key Vault in a Real World Application]]></title>
    <link href="http://rahulpnath.com/blog/azure-key-vault-in-a-real-world-application/"/>
    <updated>2015-04-25T11:46:09+00:00</updated>
    <id>http://rahulpnath.com/blog/azure-key-vault-in-a-real-world-application</id>
    <content type="html"><![CDATA[<blockquote><p>Please check <a href="http://www.rahulpnath.com/blog/how-the-deprecation-of-switch-azuremode-affects-azure-key-vault/">here</a> for scripts using the latest PowerShell cmdlets.</p></blockquote>

<p>Over the last couple of posts we have seen how to <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">Get Started with Azure Key Vault</a>, <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">Authenticate a Client Application with the Vault</a> and also on how the vault can be used as an <a href="http://www.rahulpnath.com/blog/moving-sensitive-information-from-configuration-file-to-azure-key-vault/">alternate to the configuration file to keep sensitive information secure</a>. In this post we will explore into how a key vault can be fit into the life-cycle of an application, configuring application to use the keyvault for different deployments and also on how to manage the keys/secrets for these different deployments. Any application that uses the Key Vault to manage keys and other sensitive information, should be able to switch easily to use the vault configured for it.</p>

<h3>Configuring Client-Applications to use the Key vault</h3>

<p>Objects are uniquely identified within Azure Key Vault using a URL such that no two objects in the system, regardless of geo-location, have the same URL. The complete URL to an object is called the Object Identifier and consists of a prefix portion that identifies the Key Vault, the object type, a user provided Object Name, and an Object Version. The <em>object-name</em> is case-insensitive and immutable. When an object is first created it is given a unique version identifier and is marked as the current version of the object. Creation of a new instance with the same object name gives the new object a unique version identifier and causes it to become the current version. When querying for an object <em>object-version</em> is optional and if not provided will point to the current version of the given object-name.</p>

<blockquote>https://{keyvault-name}.vault.azure.net/{object-type}/{object-name}/{object-version}</blockquote>


<p>From a client application all we need to have is to the configuration for the key vault url, and configurations to identify key/secret name which can include the version if required. This could be saved in the application&rsquo;s configuration file as shown below.
<code>xml
&lt;appSettings&gt;
  &lt;add key="KeyVaultUrl" value="https://testvaultrahul.vault.azure.net"/&gt;
  &lt;add key="SqlConnectionString" value="SqlConnectionString"/&gt;
  &lt;add key ="SecretWithVersion" value="SecretWithVersion/cfedea84815e4ca8bc19cf8eb943ee13"/&gt;
  &lt;add key="CryptoKey" value="CryptoKey"/&gt;
&lt;/appSettings&gt;
</code></p>

<p>In the above configuration I assume that when these configurations are used from the code, we know that if a value is a key or secret. We could have an extended configuration or string prefix&rsquo;s (key<em> or secret</em>) to indicate this and then have the code automatically detect it too if required to decouple that, but I don&rsquo;t see it really necessary. So the application at any time would only depend on these configured values, and we can easily switch it use any vault configured with the required key/secret values.</p>

<pre><code class="csharp">var keyVaultIdentifierHelper = new KeyVaultIdentifierHelper(ConfigurationManager.AppSettings["KeyVaultUrl"]);
var connectionStringIdentifier =
    keyVaultIdentifierHelper.GetSecretIdentifier(ConfigurationManager.AppSettings["SqlConnectionString"]);
var connectionStringSecret = await keyClient.GetSecretAsync(connectionStringIdentifier);
</code></pre>

<pre><code class="csharp KeyVaultIdentifierHelper">public class KeyVaultIdentifierHelper
{
    private const string KeyFormat = "{0}/keys/{1}";
    private const string SecretFormat = "{0}/secrets/{1}";
    private readonly string keyVaultUrl;

    public KeyVaultIdentifierHelper(string keyVaultUrl)
    {
        this.keyVaultUrl = keyVaultUrl;
    }

    public string GetKeyIdentifier(string keyName)
    {
        return string.Format(KeyFormat, this.keyVaultUrl, keyName);
    }

    public string GetSecretIdentifier(string secretName)
    {
        return string.Format(SecretFormat, this.keyVaultUrl, secretName);
    }
}
</code></pre>

<h3>Managing the Key Vault for Multiple Deployments</h3>

<p>Now that we have decoupled the application from the Key Vault, we need to see how to configure key vaults to cater for multiple deployments. In any application development life-cycle, there would be multiple deployments at a given time for the application to cater for different roles - developers, testers and maybe a production one too. It is very likely that the connection strings and other sensitive information would be deployment specific and we would want to keep them separate. Best way to achieve this would be to create Key vault per deployment so that this separation is clearly maintained. You could check on the <a href="http://azure.microsoft.com/en-in/pricing/details/key-vault/">Key Vault Pricing</a> on how this would affect your overall cost. For each of these deployments you would need to make sure that all the required keys/secrets are added with valid values. Since this can soon end up as a repeated activity, it is best to automate this (using powershell scripts or your own application)</p>

<h3>Restricting Permissions to Key Vault</h3>

<p>We had seen how to <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">authenticate a client application with a Key Vault</a> using an Active Directory (AD) application, and how to set various access policies for these application&rsquo;s. Applications should be given only the minimum set of permissions that it requires to operate on, most probably this would be only the read permissions. For <a href="https://github.com/rahulpnath/AzureKeyVaultExplorer">administrative application&rsquo;s</a> we would want to give all permissions so that it can modify the vault keys/secrets as required. For such a scenario it is best to have, two (or more) separate AD application&rsquo;s created and have separate permissions provided.</p>

<p><img class="center" alt="Multiple AD applications to access key vault with different permissions" src="/images/multiple_ad_application.PNG" /></p>

<h3>What all should be there in my configuration file?</h3>

<p>All your <a href="http://www.rahulpnath.com/blog/moving-sensitive-information-from-configuration-file-to-azure-key-vault/">sensitive information should be moved out of your application configuration file</a>, and Key Vault is the one place to have them all. The application&rsquo;s configuration file should only have the azure key vault url and the AD application id and certificate identifier (thumb print) that can be used to authenticate with the AD. Yes it is advisable to use the <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">certificate authentication mechanism</a> as opposed to the secret mechanism, if not you would have to put the secret in your configuration file, which would be like &lsquo;giving a thief the key to your safe&rsquo;.Additionally you could also have the key identifier mappings in the configuration file that the application can use to map to key/secret in the vault as we had seen above.</p>

<p>By doing this we have fully decoupled the application and its dependency with the vault store and have also protected all our sensitive information. This also helps in having the application to be tested with configurations appropriate to the type of deployment. Hope this helps you in developing your application against the key vault.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Moving Sensitive Information from Configuration File to Azure Key Vault]]></title>
    <link href="http://rahulpnath.com/blog/moving-sensitive-information-from-configuration-file-to-azure-key-vault/"/>
    <updated>2015-03-14T17:34:23+00:00</updated>
    <id>http://rahulpnath.com/blog/moving-sensitive-information-from-configuration-file-to-azure-key-vault</id>
    <content type="html"><![CDATA[<blockquote><p>Please check <a href="http://www.rahulpnath.com/blog/how-the-deprecation-of-switch-azuremode-affects-azure-key-vault/">here</a> for scripts using the latest PowerShell cmdlets.</p></blockquote>

<p>Most of the applications today needs to use some kind of sensitive information like a database connection-string, api secret or passwords for it to connect to external service providers. Today we see that all these information are stored in the application&rsquo;s configuration file, which poses a huge security risk. Anyone having access to this configuration file could use this information to access sensitive data posing a security risk. Having understood this risk, we would not want to keep these secrets anymore in the application but move it to a safer and secure place. With <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">Azure Key Vault</a>, we can have this information encrypted and saved safely out of the application and use as required from the application.Azure Key Vault provides a feature of saving such small data, <strong>Secrets</strong>, into the vault and access them over a secure endpoint.</p>

<blockquote><p>Secrets in Azure Key Vault are octet sequences with a maximum size of 10k bytes each and can have any data stored.</p></blockquote>

<p>If you are new to Azure Key Vault and yet to setup a vault, you could refer to <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">Getting Started with Azure Key Vault</a>, to setup the vault and the Active Directory(AD) application that is used to authenticate our application to access the keyvault. Since in this case we are going to use Secrets from the key vault, while setting the key vault access policy for the the AD application, we need to explicitly set access for the application to use the secrets. Access Policy to secrets and keys are distinct and can be set accordingly and you can choose to have different application&rsquo;s to access keys and secrets separately. In the below script I have set the same application to have access to keys and secrets, by setting  <em>PermissionsToKeys</em> and <em>PermissionsToSecrets</em></p>

<pre><code class="powershell">Set-AzureKeyVaultAccessPolicy -VaultName 'TestVaultRahul' -ServicePrincipalName 'd4f09821-ab30-44f3-8d57-69925489b932' -PermissionsToKeys all -PermissionsToSecrets all
</code></pre>

<p>To create a secret in the Vault, you can use the powershell script command as shown below. On successful creation of the secret the identifier to the secret is returned, which can be used by the application to obtain the Secret value.Since we have given the AD application &lsquo;<em>all</em>&rsquo; access, we could also create the secret using the api client.</p>

<pre><code class="powershell">PS C:\&gt; $apiKey = ConvertTo-SecureString -String "ApiKey" -AsPlainText -Force
Set-AzureKeyVaultSecret -VaultName TestVaultRahul -Name "ApiKey" -SecretValue $apiKey

SecretValue     : System.Security.SecureString
SecretValueText : ApiKey
VaultName       : testvaultrahul
Name            : ApiKey
Version         : cfedea84815e4ca8bc19cf8eb943ee13
Id              : https://testvaultrahul.vault.azure.net/secrets/ApiKey/cfedea84815e4ca8bc19cf8eb943ee13
</code></pre>

<p>For the application to access this secret all it needs is the SecretIdentifier and the AD credentials to authenticate with the key vault. You would want to use <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">certificate based authentication</a> to authenticate against the AD application so that only the thumbprint information needs to be there in the application&rsquo;s configuration and not the secret itself as that is again a sensitive information.
&#8220;` csharp
var keyClient = new KeyVaultClient((authority, resource, scope) =>
{
    var authenticationContext = new AuthenticationContext(authority, null);
    var clientAssertionCertificate = new ClientAssertionCertificate(applicationId, certificate);
    var result = authenticationContext.AcquireToken(resource, clientAssertionCertificate);
});</p>

<p>var secret =
    await keyClient.GetSecretAsync(&ldquo;<a href="https://testvaultrahul.vault.azure.net/secrets/ApiKey/cfedea84815e4ca8bc19cf8eb943ee13">https://testvaultrahul.vault.azure.net/secrets/ApiKey/cfedea84815e4ca8bc19cf8eb943ee13</a>&rdquo;);
&#8220;`</p>

<p>No longer do we need to keep these sensitive information in the applications configuration file, we can just have the Secret Identifiers configured in the application and have the application fetch is as required from the vault. By doing this we have kept the sensitive information out of reach from the application and also from the people who have access to a production environment.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Authenticating a Client Application with Azure Key Vault]]></title>
    <link href="http://rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/"/>
    <updated>2015-03-06T11:40:25+00:00</updated>
    <id>http://rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault</id>
    <content type="html"><![CDATA[<blockquote><p>Please check <a href="http://www.rahulpnath.com/blog/how-the-deprecation-of-switch-azuremode-affects-azure-key-vault/">here</a> for scripts using the latest PowerShell cmdlets.</p></blockquote>

<p>Azure Key Vault provides an easy way for managing cryptographic keys and secrets (like connection strings or passwords) in a secure and distributed manner as opposed to having them in the configuration file or a database. If you are new to Azure Key Vault check out the <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">Getting Started with Azure Key Vault</a> on how to setup the vault and add keys and use that from a console application.</p>

<p>In this post we will explore into the ways of authenticating a client application with a key vault. For an application to use the key vault it must authenticate using a token from the Azure Active Directory (AD). For this an application needs to be registered in the Azure AD and this application needs to be authorized to access key or secret in the vault using the <a href="https://msdn.microsoft.com/en-us/library/azure/dn903607.aspx">Set-AzureKeyVaultAccessPolicy</a> that comes as part of the <a href="https://gallery.technet.microsoft.com/scriptcenter/Azure-Key-Vault-Powershell-1349b091">key vault powershell scripts</a>.</p>

<blockquote><p>As of today, the keyvault will be created in the Default AD associated to the azure subscription and there is no way that it can be created in a different directory. But maybe this will be <a href="https://social.msdn.microsoft.com/Forums/azure/en-US/21d0dcaa-791c-4f96-8f9d-738b6b0076b2/create-a-new-key-vault-in-a-different-directory?forum=AzureKeyVault">supported in future</a>.</p></blockquote>

<p>So for a client to access the key vault, it needs to obtain the token from the Azure AD application, which can be done using 2 ways:</p>

<ul>
<li>Using ClientId and secret</li>
<li>Using ClientId and certificate</li>
</ul>


<h4><strong>Using ClientId and Secret</strong></h4>

<p>Creating an application that can be authenticated using clientid and secret can be done using the management portal. In the azure management portal, we need to create to the application under the default AD. To find the default AD you can check under the settings in the portal</p>

<p><img class="center" alt="Default Active Directory under Settings" src="/images/default_ad_settings.PNG" /></p>

<p>To add an application in the default, under Active Directory select the default AD and the applications tab and select &lsquo;<em>Add an application</em>&rsquo;.</p>

<p><img class="center" alt="Create an Application under default" src="/images/default_ad.PNG" /></p>

<p>From the pop-up select &lsquo;<em>Add an application my organization is developing</em>&rsquo; and give a name of your choice and of type &lsquo;<em>Web Application AND/OR WEB API</em>&rsquo;. In the App properties window it asks for the &lsquo;<em>Sign-On Url</em>&rsquo; and &lsquo;<em>App ID Uri</em>&rsquo;, for which you can give two unique values and is not mandatory that it should exists. On confirming these values the AD application would be created and you would be presented with the application properties. Under the &lsquo;<em>Configure</em>&rsquo; tab, you can see the Client ID and below that there is an option to create the &lsquo;<em>keys</em>&rsquo; which will be the secret.</p>

<p><img class="center" alt="AD Application Configure" src="/images/ad_application_configure.PNG" /></p>

<p>In the drop-down under the keys select the duration and choose a duration of your choice and save. On saving the secret will be generated. Copy this secret and keep for reference to use in the client application.</p>

<p><img class="center" alt="AD Application Secret Generation" src="/images/ad_application_keys.PNG" /></p>

<p>Now that we have created the application and have the clientid and the secret we need to authorize the application to access the key vault. For this we use the <em>Set-AzureKeyVaultAccessPolicy</em> from the powershell and provide the client id of the application that we have just created. The <em>PermissionToKeys</em> parameter determines the permission that the application would have on the keys in the vault which can take multiple comma separated values (all, backup, create, decrypt, delete, encrypt, import, get, list, restore, sign, wrapkey, unwrapkey, update and verify). Similarly for access to secrets in the keyvault you need to set <em>PermissionToSecrets</em> which can all take multiple values (all, delete, get, list and set).</p>

<pre><code class="powershell">PS C:\&gt; Set-AzureKeyVaultAccessPolicy -VaultName 'TestVaultRahul' -ServicePrincipalName '01c74fc1-4fb3-455e-8612-d5ad05a7fe2a' -PermissionsToKeys all
</code></pre>

<p>Now using the clientid and the secret we can authenticate from the client application using it as below
<code>csharp
var keyClient = new KeyVaultClient((authority, resource, scope) =&gt;
{
    var adCredential = new ClientCredential(clientid, applicationSecret);
    var authenticationContext = new AuthenticationContext(authority, null);
    return authenticationContext.AcquireToken(resource, adCredential).AccessToken;
});
</code></p>

<iframe class="center" width="560" height="315" src="https://www.youtube.com/embed/51Qmk3TQJ44" frameborder="0" allowfullscreen></iframe>


<h4><strong>Using ClientId and Certificate</strong></h4>

<p>Creating an application that can be authenticated using the clientid and the certificate is only possible using powershell scripts, and these are again available with the key vault powershell scripts. For this we first need to create a certificate or if your organization already has provided one use that. Since this is for demo I would be creating a test certificate as <a href="https://msdn.microsoft.com/en-in/library/ff699202.aspx">explained here</a>.
<code>
makecert -sv mykey.pvk -n "cn=AD Test Vault Application" ADTestVaultApplication.cer -b 03/03/2014 -e 06/05/2016 -r
pvk2pfx -pvk mykey.pvk -spc ADTestVaultApplication.cer -pfx ADTestVaultApplication.pfx -po test
</code></p>

<p>Once we have the certificate, we can create a new AD application and specify certificate authentication for the application as shown below. Make sure that you give the full path to the certificate as below (mine was located under C:\cert)</p>

<pre><code class="powershell">Connect-AzureAD -DomainName '&lt;domainname&gt;'
$newADApplication = New-AzureADApplication -DisplayName 'TestVaultApplication'
Add-AzureADApplicationCredential -ObjectId $newADApplication.objectId -FilePath C:\cert\ADTestVaultApplication.cer
$newADApplication.appId
</code></pre>

<p>Once the application is created, we need to perform the same authorization steps as above to give the application access to the key vault, after which we can use the clientid (that would be output to the powershell console) and the certificate to authenticate the application. Make sure that the certificate is installed into the store so that it can be used by the application.</p>

<pre><code class="csharp">var keyClient = new KeyVaultClient((authority, resource, scope) =&gt;
{
    var authenticationContext = new AuthenticationContext(authority, null);
    X509Certificate2 certificate;
    X509Store store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
    try
    {
        store.Open(OpenFlags.ReadOnly);
        X509Certificate2Collection certificateCollection = store.Certificates.Find(X509FindType.FindByThumbprint, "E2F3EAE0A131EE0CF1FF1995A6ABA9F9462A0C03", false);
        if (certificateCollection == null || certificateCollection.Count == 0)
        {
            throw new Exception("Certificate not installed in the store");
        }

        certificate = certificateCollection[0];
    }
    finally
    {
        store.Close();
    }

    var clientAssertionCertificate = new ClientAssertionCertificate(applicationId, certificate);
    var result = authenticationContext.AcquireToken(resource, clientAssertionCertificate);
    return result.AccessToken;
});
</code></pre>

<iframe class="center" width="560" height="315" src="https://www.youtube.com/embed/JbshGF4ZwGE" frameborder="0" allowfullscreen></iframe>


<p>You could use either ways to authenticate an application to Azure Key Vault. Using the certificate way would be more secure as you can also password protect your certificate so that it cannot be installed without having that. If using the client secret anybody having access to the configuration would be able to access the vault. Also make sure that you give the application&rsquo;s only necessary permissions for accessing keys and secrets while registering the application. You could use the sample used in the <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">Getting Started with Azure Key Vault</a> <a href="https://github.com/rahulpnath/Blog/tree/master/AzureKeyVault">sample</a>. The code in there uses clientId and secret, you could change it with the above code to use certificate authentication.</p>
]]></content>
  </entry>
  
</feed>
