<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: azure | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/azure/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2018-12-14T00:02:59+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[.Net Core Web App and Azure AD Groups Role based access]]></title>
    <link href="http://rahulpnath.com/blog/dot-net-core-api-and-azure-ad-groups-based-access/"/>
    <updated>2018-12-11T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/dot-net-core-api-and-azure-ad-groups-based-access</id>
    <content type="html"><![CDATA[<p>Getting your application to provide capabilities based on the role of the User using the system is a common thing. When using Azure Active Directory (AD), the Groups feature allows organizing users of your system into different roles. In the applications that we build, the group information can be used to enable/disable functionality. For, e.g., if your application has the functionality to add new users you might want to restrict this to only users belonging to the administrator role.</p>

<p><a href="https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-groups-create-azure-portal">Adding new groups</a> can be done using the Azure portal. Select Group Type, <em>Security</em> as it is intended to provide permissions based on roles.</p>

<p><img src="/images/azure_ad_Groups.png" alt="Azure AD Add Group" class="center" /></p>

<p>For the Groups to be returned as part of the claims, the <em>groupMembershipClaims</em> property in application manifest needs to be updated. Setting it to <em>SecurityGroup</em> will return all SecurityGroups of the user.</p>

<pre><code class="json Azure AD Manifest - Group Membership Claims">{
    "groupMembershipClaims": "SecurityGroup"
}
</code></pre>

<p>For each group created an <em>ObjectId</em> is assigned to it which is what gets returned as part of the claims. You can either add it as part of your applications config file or use Microsoft Graph API to query the list of groups at runtime. Here I have chosen to keep it as part of the config file.</p>

<pre><code class="json appsettings.json">"AdGroups": [
  {
    "GroupName": "Admin",
    "GroupId": "119f6fb5-a325-47f9-9889-ae6979e9e120"
  },
  {
    "GroupName": "Employee",
    "GroupId": "02618532-b2c0-4e58-a32e-e715ddf07f63"
  }
]
</code></pre>

<p>Now that we have all the groups and associated configuration setup, we can wire up the .Net Core web application to start using the groups from the claims to enable/disable features. Using the <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-2.2">Policy-based authorization</a> capabilities of .Net core application we can wire up policies for all the groups we have.</p>

<blockquote><p><em><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-2.2">Role-based authorization and claims-based authorization</a> use a requirement, a requirement handler, and a pre-configured policy. These building blocks support the expression of authorization evaluations in code. The result is a richer, reusable, testable authorization structure.</em></p></blockquote>

<p>We have an <em>IsMemberOfGroupRequirement</em> class to represent the requirement for all the groups, the <em>IsMemberOfGroupHandler</em> that implements how to validate a group requirement. The Handler reads the current user&rsquo;s claims and checks it contains the objectId associated with the Group as a claim. If a match is found the requirement check is marked as a success. Since we want the request to continue to match for any other group requirements the requirement is not failed explicitly.</p>

<pre><code class="csharp IsMemberOfGroup Requirement">public class IsMemberOfGroupRequirement : IAuthorizationRequirement
{
    public readonly string GroupId ;
    public readonly string GroupName ;

    public IsMemberOfGroupRequirement(string groupName, string groupId)
    {
        GroupName = groupName;
        GroupId = groupId;
    }
}

public class IsMemberOfGroupHandler : AuthorizationHandler&lt;IsMemberOfGroupRequirement&gt;
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context, IsMemberOfGroupRequirement requirement)
    {
        var groupClaim = context.User.Claims
             .FirstOrDefault(claim =&gt; claim.Type == "groups" &amp;&amp;
                 claim.Value.Equals(requirement.GroupId, StringComparison.InvariantCultureIgnoreCase));

        if (groupClaim != null)
            context.Succeed(requirement);

        return Task.CompletedTask;
    }
}
</code></pre>

<p>Registering the policies for all the groups in the application&rsquo;s configuration file and the handler can be done as below. Looping through all the groups in the config we create a policy for each with the associated GroupName. It allows us to use the GroupName as the policy name at places where we want to restrict features for users belonging to that group.</p>

<pre><code class="csharp Registering Policy and Handler">services.AddAuthorization(options =&gt;
{
    var adGroupConfig = new List&lt;AdGroupConfig&gt;();
    _configuration.Bind("AdGroups", adGroupConfig);

    foreach (var adGroup in adGroupConfig)
        options.AddPolicy(
            adGroup.GroupName, 
            policy =&gt;
                policy.AddRequirements(new IsMemberOfGroupRequirement(adGroup.GroupName, adGroup.GroupId)));
});

services.AddSingleton&lt;IAuthorizationHandler, IsMemberOfGroupHandler&gt;();
</code></pre>

<p>Using the policy is now as simple as decorating your controllers with the Authorize attribute and providing the required Policy names on it as shown below.
<code>csharp
[Authorize(Policy = "Admin")]
[ApiController]
public partial class AddUsersController : ControllerBase
{
    ....
}
</code></p>

<p>Hope this helps you to setup Role-based functionality for your ASP.Net Core applications using Azure AD as authentication/authorization provider.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Azure AD Custom Attributes and Optional Claims from an ASP.Net Application]]></title>
    <link href="http://rahulpnath.com/blog/azure-ad-custom-attributes-and-optional-claims-from-an-asp-dot-net-application/"/>
    <updated>2018-12-10T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/azure-ad-custom-attributes-and-optional-claims-from-an-asp-dot-net-application</id>
    <content type="html"><![CDATA[<p>When using Azure Active Directory for managing your users, it is a common requirement to add additional attributes to your Users like SkypeId, employee code, EmployeeId and similar. Even though this happens to be a common need, getting this done is not that straightforward. This post describes how you can get additional properties on User objects in Azure AD.</p>

<p>Recently when I had to do this at a client, we had users in Azure AD, the additional property, employeeCode for the user was available in an internal application which had the users Azure email-address mapped to it. We needed these to be synced across to the user Azure AD and make it available as part of claims for a Web site that uses <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/authentication-scenarios">Azure AD authentication</a></p>

<h3>Adding Custom Attribute using Directory Schema Extensions</h3>

<p>Azure AD user has a set of <a href="https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-users-profile-azure-portal">default properties</a>, manageable through the Azure Portal. Any additional property to User gets added as an extension to the current user Schema. To add a new property we first need to <a href="https://msdn.microsoft.com/library/azure/ad/graph/howto/azure-ad-graph-api-directory-schema-extensions#RegisterAnExtension">register an extension</a>. Adding a new extension can be done using the <a href="https://graphexplorer.azurewebsites.net/">GraphExplorer website</a>. You need to specify the appropriate directory name (e.g., <em>contoso.onmicrosoft.com</em>) and the applicationObjectId. The application object id is the Object Id of the AD application that the Web Application uses to authenticate with Azure AD.</p>

<blockquote><p><em><a href="https://docs.microsoft.com/en-us/graph/extensibility-overview#azure-ad-directory-schema-extensions">Azure AD supports</a> a similar type of extension, known as directory schema extensions, on a few directory object resources. Although you have to use the Azure AD Graph API to create and manage the definitions of directory schema extensions, you can use the Microsoft Graph API to add, get, update and delete data in the properties of these extensions.</em></p></blockquote>

<pre><code class="json">POST https://graph.windows.net/contoso.onmicrosoft.com/applications/
    &lt;applicationObjectId&gt;/extensionProperties?api-version=1.5 HTTP/1.1
{
    "name": "employeeCode&lt;optionalEnvironmentName&gt;",
    "dataType": "String",
    "targetObjects": [
        "User"
    ]
}
</code></pre>

<p>The response gives back the fully-qualified extension property name, which is used to write values to the property. Usually the name is of the format <em>extension_&lt;adApplicationIdWithoutDashes>_extensionPropertyName</em></p>

<p>If you have multiple environments (like Dev, Test, UAT, Prod) all pointing to the same Active Directory, it is a good idea to append the environment name to the extension property. It avoids any bad data issues between environments as all these properties get written to the same User object. You can automate the above step using any scripting language of your choice if required.</p>

<h3>Setting Values for Custom Attributes</h3>

<p>Now that we have the extension property created on the AD application, we can set the property on the User object. If you want to set this manually, you can use the <a href="https://graphexplorer.azurewebsites.net/">GraphExplorer website</a> again to do this.</p>

<pre><code class="json">PATCH https://graph.windows.net/contoso.onmicrosoft.com/users
        /jim@contoso.onmicrosoft.com?api-version=1.5
{
    "extension_ab603c56068041afb2f6832e2a17e237_employeeCode&lt;optionalEnvironmentName&gt;": "EMP124"
}
</code></pre>

<p>In our case it was not a one-off case of updating the User object, so better wanted this to be automated. Employee codes were available from a database with the associated Azure AD email address. So we created a windows service job that would sync these codes to Azure AD. You can write to Azure AD schema extension properties using <a href="https://developer.microsoft.com/en-us/graph">Microsoft Graph API</a>. Add a reference to the <a href="https://www.nuget.org/packages/Microsoft.Graph">Microsoft Graph NuGet package</a>, and you are all set to go. For the Graph API to authenticate, use a different Azure AD app (separate to the one that you registered the extension property on, which the web app uses to authenticate), just because it needs additional permissions as well and it is a good idea to isolate that. Under Settings -> Required Permissions, Add Microsoft Graph and provide the relevant permissions for it to write the user&rsquo;s profile/directory data.</p>

<p><img
    src="/images/azureAd_GraphApi_Permissions.png"
    class="center"
    alt="Azure AD Graph API Permissions" /></p>

<pre><code class="csharp Get Graph Api Client">private static async Task&lt;GraphServiceClient&gt; GetGraphApiClient()
{
    var clientId = ConfigurationManager.AppSettings["AppId"];
    var secret = ConfigurationManager.AppSettings["Secret"];
    var domain = ConfigurationManager.AppSettings["Domain"];

    var credentials = new ClientCredential(clientId, secret);
    var authContext =
        new AuthenticationContext($"https://login.microsoftonline.com/{domain}/");
    var token = await authContext
        .AcquireTokenAsync("https://graph.microsoft.com/", credentials);

    var graphServiceClient = new GraphServiceClient(new DelegateAuthenticationProvider((requestMessage) =&gt;
    {
        requestMessage
            .Headers
            .Authorization = new AuthenticationHeaderValue("bearer", token.AccessToken);

        return Task.CompletedTask;
    }));

    return graphServiceClient;
}
</code></pre>

<pre><code class="csharp Update Extension Value">private async Task UpdateEmployeeCode(
    string employeeCodePropertyName, GraphServiceClient graphApiClient, Employee employee)
{
    var dictionary = new Dictionary&lt;string, object&gt;();
    dictionary.Add(employeeCodePropertyName, employee.Code);

    await graphApiClient.Users[employee.EmailAddress]
        .Request()
        .UpdateAsync(new User()
        {
            AdditionalData = dictionary
        });
}
</code></pre>

<p>Looping through all the employee codes, you can update all of them into Azure AD at regular intervals. To verify that the attributes are updated correctly, you can either use the Graph API client to read the extension property or use the Graph Explorer Website.</p>

<h3>Accessing Custom Attributes through Claims</h3>

<p>With the Azure AD updated with the employee code for each user, we can now set up the AD application to return the additional property as part of the claims, when the web application authenticates with it. The application manifest of the Azure AD application needs to be modified to return the extension property as part of the claims. By default <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-optional-claims#configuring-optional-claims">optionalClaims property</a> is set to null and you can update it with the below values.</p>

<p><img
    src="/images/AzureAd_schema_extension_optionalClaims.png"
    class="center" alt="Azure AD Application Manifest - Optional Claims" /></p>

<pre><code class="json Optional Claims in Azure AD Application Manifest">"optionalClaims": {
    "idToken": [
      {
        "name": "extension_&lt;id&gt;_employeeCodeLocal",
        "source": "user",
        "essential": true,
        "additionalProperties": []
      }
    ],
    "accessToken": [],
    "saml2Token": []
  },
</code></pre>

<p>I updated the idToken property as the .Net Core Web Application was using JWT ID token. If you are unsure of what token you can use <a href="https://rahulpnath.com/blog/fiddler-free-web-debugging-proxy/">Fiddler</a> to find what kind of token is used (as shown below).</p>

<p><img src="/images/AzureAd_idToken.png" class="center" alt="Id token returned" /></p>

<p>With the optonalClaims set, the web application is all set to go. For an authenticated user (with the extension property set), the extension property is available as part of claims. The claim type will be &lsquo;<em>extn.employeeCode<optionalEnvironmentNam></em>&rsquo;. The below code can be used to extract the employee code from the claim.</p>

<pre><code class="csharp Get Employee Code From Claim">public static string GetEmployeeCode(this ClaimsPrincipal claimsPrincipal)
{
    if (claimsPrincipal == null || claimsPrincipal.Claims == null)
        return null;

    var empCodeClaim = claimsPrincipal.Claims
        .FirstOrDefault(claim =&gt; claim.Type.StartsWith("extn.employeeCode"));

    return empCodeClaim?.Value;
}
</code></pre>

<div class="alert alert-warning">
Usually, the claims start flowing through immediately. However, once it did happen to me that the claims did not come for over a long period. Not sure what I did wrong, but once I deleted and recreated the AD application, it started working fine.
</div>


<p>Although setting additional properties on Azure AD Users is a common requirement, setting it up is not that straight-forward. Hope the portal improves someday, and it would be as easy as setting a list of key-value properties as extension properties, and it would all seamlessly flow through as part of the claims. However, till that day, hope this helps you to set up extra information on your Azure AD users.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Azure Web App Restarting Automatically Due to Overwhelming Change Notification]]></title>
    <link href="http://rahulpnath.com/blog/azure-web-restarting-automatically-due-to-overwhelming-change-notification/"/>
    <updated>2017-07-24T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/azure-web-restarting-automatically-due-to-overwhelming-change-notification</id>
    <content type="html"><![CDATA[<p>At one of my clients, we faced a strange issue recently. The Azure Web application restarted automatically very often. The event log in the <a href="https://github.com/projectkudu/kudu/wiki/Kudu-console">Kudu console</a> showed the below error message.</p>

<blockquote><p><em>2017-07-13 00:09:50,333 [P45516/D4/T171] INFO  Umbraco.Core.UmbracoApplicationBase - Application shutdown. Details: HostingEnvironment</em></p>

<p><em>_shutDownMessage=Directory rename change notification for &rsquo;D:\home\site\wwwroot&#8217;.</em>  <br/>
<em>Overwhelming Change Notification in wwwroot</em>   <br/>
<em>HostingEnvironment initiated shutdown</em>  <br/>
<em>Directory rename change notification for &rsquo;D:\home\site\wwwroot&#8217;.</em>   <br/>
<em>Overwhelming Change Notification in wwwroot</em>   <br/>
<em>Initialization Error</em>   <br/>
<em>HostingEnvironment caused shutdown</em></p></blockquote>

<p>As you can tell from the logs, the website is an <a href="https://umbraco.com/">Umbraco</a> CMS hosted as an Azure Web application. We noticed that the restarts were happening more when the content was getting updated through <a href="https://our.umbraco.org/documentation/getting-started/backoffice/">backoffice</a>. The error also states that the restart was caused due to <em>Overwhelming Change Notification in wwwroot</em>. This hints that there are changes that are happening under the wwwroot folder, where the site is hosted.</p>

<div class="alert alert-info">
Even though this post details on why the specific site on Umbraco was restarting, most of the contents are still applicable for any other ASP.NET MVC application.
</div>


<h3>fcnMode Configuration</h3>

<p>A quick search got me to the <a href="https://msdn.microsoft.com/en-us/library/system.web.configuration.httpruntimesection.fcnmode(v=vs.110">fcnMode</a>.aspx)setting under <a href="https://msdn.microsoft.com/en-us/library/system.web.configuration.httpruntimesection(v=vs.110">httpRuntime</a>.aspx) section. An ASP.net application monitors certain files and folders under the wwwroot folder and will restart the application domain whenever it detects changes. This likely look looks the reason why the web site is restarting.</p>

<p>The <a href="https://msdn.microsoft.com/en-us/library/system.web.configuration.fcnmode(v=vs.110">fcnMode enumeration</a>.aspx) can take one of the four values below. For an Umbraco application this is by <a href="http://issues.umbraco.org/issue/U4-7712">default set to <em>Single</em></a>.</p>

<ul>
<li><strong>Default</strong>: For each subdirectory, the application creates an object that monitors the subdirectory. This is the default behavior.</li>
<li><strong>Disabled</strong>: File change notification is disabled.</li>
<li><strong>NotSet</strong>: File change notification is not set, so the application creates an object that monitors each subdirectory. This is the default behavior.</li>
<li><strong>Single</strong>: The application creates one object to monitor the main directory and uses this object to monitor each subdirectory.</li>
</ul>


<pre><code class="xml fcnMode set to Single for Umbraco application">&lt;system.web&gt;
    ...
    &lt;httpRuntime 
        requestValidationMode="2.0" 
        enableVersionHeader="false"
        targetFramework="4.5"
        maxRequestLength="51200" 
        fcnMode="Single" /&gt;
    ...
&lt;system.web&gt;
</code></pre>

<blockquote><p><em>FCNMode creates a monitor object with a buffer size of 4KB for each folder. When FCNMode is set to Single, a single monitor object is created with a buffer size of 64KB. When there are file changes, the buffer is filled with file change information. If the buffer gets overwhelmed with too many file change notifications an “Overwhelming File Change Notifications” error will occur and the app domain will recycle. The likelihood of the buffer getting overwhelmed is higher in an environment where you are using separate file server because the folder paths are much larger.</em></p>

<p>-<a href="http://www.dnnsoftware.com/community-blog/cid/154980/aspnet-file-change-notifications-and-dnn"> ASP.NET File Change Notifications and DNN</a></p></blockquote>

<p>You can read more about fcnMode setting and how it affects ASP.Net applications <a href="https://shazwazza.com/post/all-about-aspnet-file-change-notification-fcn/">here</a>.</p>

<h3>What&rsquo;s causing file changes?</h3>

<p>Default reaction when you come across such a setting or configuration value might be to turn that off and fcnMode does allow that as well - <em>Disabled</em>. But first, it is better that we understand what is causing file changes under the wwwroot folder and see if we can address that. The <a href="https://shazwazza.com/post/fcn-file-change-notification-viewer-for-aspnet/">FCN Viewer</a> helps visualize how many files and folders are being watched in as ASP.Net application.</p>

<p>In the Umbraco website, we are using a third party library <a href="http://imageprocessor.org/">ImageProcessor</a> that helps to process images dynamically. The ImageProcessor caches images and the <a href="http://imageprocessor.org/imageprocessor-web/configuration/#cacheconfig">cache location is configurable</a>. By default, it caches files under the App_Data/cache folder, which also happens to be one of the folders that the ASP.Net application monitors for changes. So anytime there are lots of files changing in the cache folder it causes the single monitor object monitoring the folders. This causes a buffer overflow and triggers an application restart due to <em>Overwhelming file change notifications</em>. However, ImageProcessor does allow moving the <a href="https://github.com/JimBobSquarePants/ImageProcessor/issues/518">cache folder outside of the wwwroot folder</a>. This causes the file not to be monitored and still work fine with the application. Since the <a href="https://twitter.com/Shazwazza/status/885770960321773568">library does not create the cache folder automatically</a>, we need to make sure that the folder specified in the config file exists.</p>

<p>Having moved the cache folder outside of the wwwroot, I no longer need to update the fcnMode setting and can leave it as intended. If you are facing application restarts as well due to overwhelming change notification in wwwroot see what is likely causing the file changes and then try and fix that instead of just setting the fcnMode to disabled.</p>

<p>Hope that helps fix your application restarting problem!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Azure Key Vault From Azure Functions - Certificate Based Authentication]]></title>
    <link href="http://rahulpnath.com/blog/azure-key-vault-from-azure-functions-certificate-based-authentication/"/>
    <updated>2017-05-25T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/azure-key-vault-from-azure-functions-certificate-based-authentication</id>
    <content type="html"><![CDATA[<p>In the previous post we saw how to connect to <a href="/blog/azure-key-vault-from-azure-functions/">Azure Key Vault from Azure Functions</a>. We used the <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">Application Id and Secret to authenticate with the Azure AD Application</a>. Since the general recommendation is to use certificate-based authentication, in this post, we will see how we can use certificates to authenticate from within an Azure Function.</p>

<p>First, we need to create an Azure AD application and set it up to use certificate-based authentication. Create a new service principal for the AD application and associate that with the Azure Key Vault. Authorize the AD application with the permissions required. In this case, I am providing all access to keys and secrets.</p>

<pre><code class="powershell">$certificateFilePath = "C:\certificates\ADTestVaultApplication.cer"
$certificate = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
$certificate.Import($certificateFilePath)
$rawCertificateData = $certificate.GetRawCertData()
$credential = [System.Convert]::ToBase64String($rawCertificateData)
$startDate= [System.DateTime]::Now
$endDate = $startDate.AddYears(1)
$adApplication = New-AzureRmADApplication -DisplayName "CertAdApplication" -HomePage  "http://www.test.com" -IdentifierUris "http://www.test.com" -CertValue $credential  -StartDate $startDate -EndDate $endDate

$servicePrincipal = New-AzureRmADServicePrincipal -ApplicationId $adApplication.ApplicationId

Set-AzureRmKeyVaultAccessPolicy -VaultName 'RahulKeyVault' -ServicePrincipalName $servicePrincipal.ServicePrincipalNames[0] -PermissionsToSecrets all -PermissionToKeys all 
</code></pre>

<p>Create an Azure Function App under your subscription as shown below. You can also use the same application created in the previous post (if you did create one).</p>

<p><img src="/images/azureFunction_newFunctionApp.png" alt="Azure Function New App" class="center" /></p>

<p>In the Function Apps page, select the app just created. Add a new function like in the last post. Selecting the Function App shows the available set of actions. Under the <em>Platform Features</em> tab we can upload the SSL certificates first and then update the Application Certificates to make the certificate available for the function.</p>

<p><img src="/images/azureFunction_PlatformFeatures.png" alt="Azure Function Platform Features" class="center" /></p>

<p>Upload the certificate by selecting it from your folder system.</p>

<p><img src="/images/azureFunction_addCertificate.png" alt="Azure Function Upload Certificate" class="center" /></p>

<p>For the certificate to be available for use in the Azure Functions an entry should be present in Application Settings. Under <em>Application Settings</em> in the <em>Platform Features</em> tab add App settings key and value - <em>WEBSITE_LOAD_CERTIFICATES</em> and the certificate thumbprint This makes the certificate available for consumption within the function. Multiple thumbprints can be specified comma separated if required.</p>

<p><img src="/images/azureFunction_AppSetting.png" alt="Azure Function Certificates App Settings" class="center" /></p>

<p>Using a certificate to authenticate with the Key Vault is the same as we have <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">seen before</a>.</p>

<pre><code class="csharp">using System;
using Microsoft.Azure.KeyVault;
using Microsoft.IdentityModel.Clients.ActiveDirectory;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;

private const string applicationId = "AD Application ID";
private const string certificateThumbprint = "Certificate Thumbprint";

public async static Task Run(TimerInfo myTimer, TraceWriter log)
{
    var keyClient = new KeyVaultClient(async (authority, resource, scope) =&gt;
{
    var authenticationContext = new AuthenticationContext(authority, null);
    X509Certificate2 certificate;
    X509Store store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
    try
    {
        store.Open(OpenFlags.ReadOnly);
        X509Certificate2Collection certificateCollection = store.Certificates.Find(X509FindType.FindByThumbprint, certificateThumbprint, false);
        if (certificateCollection == null || certificateCollection.Count == 0)
        {
            throw new Exception("Certificate not installed in the store");
        }

        certificate = certificateCollection[0];
    }
    finally
    {
        store.Close();
    }

    var clientAssertionCertificate = new ClientAssertionCertificate(applicationId, certificate);
    var result = await authenticationContext.AcquireTokenAsync(resource, clientAssertionCertificate);
    return result.AccessToken;
});

    var secretIdentifier = "https://rahulkeyvault.vault.azure.net/secrets/mySecretName";
    var secret = await keyClient.GetSecretAsync(secretIdentifier);

    log.Info($"Secret Value: {secret}"); 
}
</code></pre>

<p>Make sure you add in the <em>project.json</em> as seen in the <a href="/blog/azure-key-vault-from-azure-functions/">previous post</a> to enable the required NuGet packages. The Azure function now uses the certificate to authenticate with Key Vault and retrieve the secret.</p>

<p>Hope this helps!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Azure Key Vault From Azure Functions]]></title>
    <link href="http://rahulpnath.com/blog/azure-key-vault-from-azure-functions/"/>
    <updated>2017-05-01T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/azure-key-vault-from-azure-functions</id>
    <content type="html"><![CDATA[<p><em><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview">Azure Functions</a> is a solution for easily running small pieces of code, or &ldquo;functions,&rdquo; in the cloud. You can write just the code you need for the problem at hand, without worrying about a whole application or the infrastructure to run it. Functions can make development even more productive, and you can use your development language of choice, such as C#, F#, Node.js, Python or PHP. Pay only for the time your code runs and trust Azure to scale as needed. Azure Functions lets you develop serverless applications on Microsoft Azure.</em></p>

<p>Even when developing with Azure Functions you want to keep your sensitive data protected. Like for example if the function needs to connect to a database you might want to get the connection string from <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">Azure Key Vault</a>. If you are new to Azure Key Vault check out <a href="http://www.rahulpnath.com/blog/category/azure-key-vault/">these posts to get started</a>. In this post, we will explore how we can consume objects in Azure Key Vault from an Azure Function.</p>

<p><strong>Create Azure Function App</strong>: Let&rsquo;s first create an Azure Function App from the Azure portal. Under <em>New - Compute - Function App</em> you can create a new Azure Function.</p>

<p><img src="/images/azureFunction_new.png" alt="" class="center" /></p>

<p>Enter the details of the new function app and press Create. Each function app has an associated storage account. You can choose an existing one or create a new one.</p>

<p><img src="/images/azureFunction_create.png" alt="" class="center" /></p>

<p>You can view all Azure Functions Apps in the subscription under <em>More services - Function Apps</em></p>

<p><img src="/images/azureFunction_all.png" alt="" class="center" /></p>

<p><strong>Create Function</strong>: To create a function you can create from an existing template or create a custom function. In this example, I will use a timer based function in C#.</p>

<p><img src="/images/azureFunction_createFunction.png" alt="" class="center" /></p>

<p>In the <em>run.csx</em> file add in the code for the function. The below code fetches the secret value from the Key Vault and logs it. You need to provide the <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">Azure AD Application Id and secret</a> to authenticate with it. Alternatively you can also use <a href="http://www.rahulpnath.com/blog/azure-key-vault-from-azure-functions-certificate-based-authentication/">certificate based authentication to authenticate with the Key Vault</a>. Make sure you add in the relevant <em>using</em> statements for the KeyVault client Azure Active Directory Authentication libraries (ADAL).</p>

<pre><code class="csharp">using System;
using Microsoft.Azure.KeyVault;
using Microsoft.IdentityModel.Clients.ActiveDirectory;

private const string applicationId = "AD Application Id";
private const string applicationSecret = "AD Application Secret";

public async static Task Run(TimerInfo myTimer, TraceWriter log)
{
    var keyClient = new KeyVaultClient(async (authority, resource, scope) =&gt;
    {
        var adCredential = new ClientCredential(applicationId, applicationSecret);
        var authenticationContext = new AuthenticationContext(authority, null);
        return (await authenticationContext.AcquireTokenAsync(resource, adCredential)).AccessToken;
    });

    var secretIdentifier = "https://rahulkeyvault.vault.azure.net/secrets/mySecretName";
    var secret = await keyClient.GetSecretAsync(secretIdentifier);

    log.Info($"C# Timer trigger function executed at: {secret}"); 
}
</code></pre>

<p><img src="/images/azureFunction_code.png" alt="" class="center" /></p>

<p>Since the KeyVaultClient and the ADAL libraries are NuGet packages, we need to specify these as dependencies for the Azure Function. To use NuGet packages, create a <em>project.json</em> file in the functions folder. Add in both the NuGet packages name and required version.</p>

<pre><code class="json">{
  "frameworks": {
    "net46":{
      "dependencies": {
        "Microsoft.Azure.KeyVault": "1.0.0",
        "Microsoft.IdentityModel.Clients.ActiveDirectory": "2.14.201151115"
      }
    }
   }
}
</code></pre>

<p><img src="/images/azureFunction_nuget.png" alt="" class="center" /></p>

<p>Executing the function, retrieves the secret details from the Key Vault and logs it as shown below.</p>

<p><img src="/images/azureFunction_run.png" alt="" class="center" /></p>

<p>Hope this helps you to get started with Key Vault in Azure Functions and keep your sensitive data secure.</p>
]]></content>
  </entry>
  
</feed>
