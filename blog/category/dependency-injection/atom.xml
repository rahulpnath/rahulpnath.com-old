<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dependency injection | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/dependency-injection/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2018-03-24T00:01:56+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[IsRegistered on Unity Container for Generic Type]]></title>
    <link href="http://rahulpnath.com/blog/isregistered-on-unity-container-for-generic-type/"/>
    <updated>2015-01-14T22:31:51+00:00</updated>
    <id>http://rahulpnath.com/blog/isregistered-on-unity-container-for-generic-type</id>
    <content type="html"><![CDATA[<p><em>This post just describes a bug that is there in the Unity (3.5.1404) IoC container, when using the IsRegistered extension method, to check for generic types and a possible fix for it.</em></p>

<p><a href="http://msdn.microsoft.com/en-us/library/ff647202.aspx">Unity</a> IoC container provides <a href="http://msdn.microsoft.com/en-us/library/microsoft.practices.unity.unitycontainerextensions.isregistered(v=pandp.51).aspx">IsRegistered</a> extension method, that can be used to check whether a registration exists for a given type and name (can be null too) combination. When a generic type is registered in the container and trying to check IsRegistered using a concrete typed version of the generic interface it returns false.</p>

<p>As shown in the below code snippet, calling IsRegistered on a non-generic interface(<em>IFooBar</em>) returns true, indicating that a registration exists. But for the generic interface(<em>IFooGeneric&lt;></em>), trying to check if a registration exists for a concrete type (<em>IFooGeneric<string></em> - as only concrete types can be resolved from the container and an open generic type cannot be resolved) it returns false.</p>

<pre><code class="csharp">IUnityContainer unityContainer = new UnityContainer();
unityContainer.RegisterType(typeof(IFooBar), typeof(FooBarImplementation));
unityContainer.RegisterType(typeof(IFooGeneric&lt;&gt;), typeof(FooGenericImplementation&lt;&gt;));

var hasFooBarRegistration = unityContainer.IsRegistered&lt;IFooBar&gt;(); // Returns true

var hasFooGenericStringRegistration = unityContainer.IsRegistered&lt;IFooGeneric&lt;string&gt;&gt;(); // Returns False
var fooGenericString = unityContainer.Resolve&lt;IFooGeneric&lt;string&gt;&gt;(); // Resolution Succeeds
</code></pre>

<p>The <a href="https://unity.codeplex.com/SourceControl/latest#source/Unity/Src/UnityContainerExtensions.cs">IsRegistered method </a> as shown below, loops through the list of available registrations looking for a match on the registered type and name. The &lsquo;<em>typeToCheck</em>&rsquo; is the type of the object that we are trying to resolve in IsRegistered - <em>typeof(IFooGeneric<string>)</em>, but the registered type is <em>typeof(IFooGeneric&lt;>)</em>. Because of this the comparison fails and the registration does not pass the where clause of the query, causing the function to return <em>false</em>.</p>

<pre><code class="csharp">var registration = from r in container.Registrations
                   where r.RegisteredType == typeToCheck &amp;&amp; r.Name == nameToCheck
                   select r;
return registration.FirstOrDefault() != null;
</code></pre>

<p>To fix this, we would need to modify the where condition so that in cases where the RegisteredType is a generic type definition, it would compare with the generic type definition of &lsquo;<em>typeToCheck</em>&rsquo;, as shown below.</p>

<pre><code class="csharp">var genericTypeToCheck = typeToCheck.GetTypeInfo().IsGenericType
                         ? typeToCheck.GetGenericTypeDefinition()
                         : null;

var registration = from r in container.Registrations
                   where (r.RegisteredType.GetTypeInfo().IsGenericTypeDefinition
                   ? r.RegisteredType == genericTypeToCheck
                   : r.RegisteredType == typeToCheck)
                   &amp;&amp; r.Name == nameToCheck
                   select r;
return registration.FirstOrDefault() != null;
</code></pre>

<p>A similar <a href="https://unity.codeplex.com/discussions/568979">issue</a> was already raised in the unity discussions, which I feel was closed inappropriately.</p>

<blockquote><p>If a container can Resolve a particular type then it should also be able to return that it IsRegistered.</p></blockquote>

<p>Please do be aware that using IsRegistered extensively has a <a href="http://unity.codeplex.com/discussions/268223">negative impact on performance</a> as looping through the Registration looking for the name and type has <a href="http://en.wikipedia.org/wiki/Big_O_notation">O(n) complexity</a>. But that still does not justify the bug!.</p>

<p><em>I have submitted a <a href="https://unity.codeplex.com/SourceControl/network/forks/rahulpnath/isRegisteredForGenericTypes/contribution/7903">pull request</a> for the fix and it would be worth checking the latest comments on that to see if there are any better approaches or problems that I might have missed out with my fix!</em>
<a href="http://www.codeproject.com" style="display:none" rel="tag">CodeProject</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IoC Registration by Convention]]></title>
    <link href="http://rahulpnath.com/blog/ioc-registration-by-convention/"/>
    <updated>2015-01-03T18:03:17+00:00</updated>
    <id>http://rahulpnath.com/blog/ioc-registration-by-convention</id>
    <content type="html"><![CDATA[<p>Sometime back we had seen, how to <a href="http://www.rahulpnath.com/blog/configuring-unity-container-comparing-code-and-xml-configuration-side-by-side/">configure the unity container using code/config file</a> and I was using a mix of this in one of my projects. This approach soon became an overhead, as the manual wiring up of registrations is really cumbersome and also error prone. Mostly there were missing registrations only to be found out, when doing test runs or deployments. We soon were forced to move out of the manual registration and find a new way to register dependencies.</p>

<p>The below image by <a href="https://twitter.com/ploeh">Mark Seemann</a> sums it all up on when and how to use a Dependency Injection(DI) container and we were right at the bottom, where the whole purpose of a DI becomes pointless.</p>

<p><a href="http://bit.ly/1zLiq6p" class="center" title="Image By Mark Seemann, from http://bit.ly/1zLiq6p"><img src="http://rahulpnath.com/images/ioc_usefulness.png" class="center" alt="Image By Mark Seemann, from http://bit.ly/1zLiq6p"></a></p>

<h4>Convention Over Configuration</h4>

<p><a href="http://en.wikipedia.org/wiki/Convention_over_configuration">Convention over configuration</a>, is very popular today and there are already many frameworks that have adopted it e.g. MVC, Web Api. Following the same approach would make life much simpler and registration less painful as dependencies would get auto registered, if the convention is followed. Conventions could vary across projects/teams, so it is up to the team to decide on the conventions that are to be followed and have all the developers follow them religiously.</p>

<p>Currently our registration process picks up all the assemblies from the base path and iterates through all the classes that are under the project/application namespace and gets the interfaces out of them and registers them. For interfaces that have multiple definitions we perform named registration based on the class name or name from an attribute on the class or both.</p>

<p>We are using Unity as the IoC container and it does support <a href="http://msdn.microsoft.com/en-us/library/dn507479(v=pandp.30).aspx">convention based registrations</a> out of the box. You can either use the RegisterTypes method or the RegistrationConvention class to specify the conventions. The parameters in both of these approaches enable you to specify the types to register, the mappings to create, the name to use and lifetime. Since in our registration we wanted to use the named convention only in cases where there where multiple registrations for the same interface and the other interfaces were to be registered without any name this default convention had to be modified. Also we did not want to get tightly bound to the IoC container (just in case we want to swap out the container provider) and hence thought of having the convention logics in a separate class and have them registered to the container of choice.</p>

<p>The <em>GetClassesFromAssemblies</em> function iterates over the assemblies from the base application path(bin folder) to get all the dll&rsquo;s used and gets the classes that belong to the namespaces that we want to register. Alternatively you could also pass a list of assemblies if required to be used for the convention. If you want other namespaces too you can filter those in here.</p>

<pre><code class="csharp">private static IEnumerable&lt;Type&gt; GetClassesFromAssemblies(IEnumerable&lt;Assembly&gt; assemblies = null)
{
    var allClasses = assemblies != null ? AllClasses.FromAssemblies(assemblies) : AllClasses.FromAssembliesInBasePath();
    return
        allClasses.Where(
            n =&gt;
                n.Namespace != null
                &amp;&amp; n.Namespace.StartsWith(ApplicationNamespace, StringComparison.InvariantCultureIgnoreCase));
}                                                                                                        
</code></pre>

<p>For each of the type that is returned from the above method we get the list of interfaces that are defined on the type and needs to be registered against the type. In the sample code, I have added a couple of variations of registrations.</p>

<ul>
<li><em>IFooBar</em>        : Has only one implementation</li>
<li><em>IFoo</em>           : Has multiple implementations and should be resolved using <em>IFooFactory</em></li>
<li><em>IFooCustom</em>     : Has multiple implementations and needs to have a custom name (maybe for some reason you do not want the context information to be part of the class name). This is to be resolved using IFooCustomFactory.</li>
<li><em>IFooGeneric<T></em> : This is a generic implementation and the type can be decided at runtime.</li>
</ul>


<p>The <em>GetInterfacesToBeRegistered</em> function gets the interfaces that are to be registered for a given type. For this convention I want to <a href="http://stackoverflow.com/questions/5318685/get-only-direct-interface-instead-of-all">get only the direct interfaces</a> that are on the given type and not all the interfaces. The check below for <em>isGenericType</em> on an interface is for <em>IFooGeneric</em> as for generic interfaces the <a href="http://stackoverflow.com/questions/3117090/getinterfaces-returns-generic-interface-type-with-fullname-null">GetInterfaces does not return the full information required</a> and we need to use the <em>GetGenericTypeDefinition</em> method instead.</p>

<pre><code class="csharp">private static IEnumerable&lt;Type&gt; GetInterfacesToBeRegistered(Type type)
{
    var allInterfacesOnType = type.GetInterfaces()
        .Select(i =&gt; i.IsGenericType ? i.GetGenericTypeDefinition() : i).ToList();

    return allInterfacesOnType.Except(allInterfacesOnType.SelectMany(i =&gt; i.GetInterfaces())).ToList();
}
</code></pre>

<p>Once we have the interfaces for the type, we add them to an internal mapping list to register it all into the unity container. The internal mapping is against the interface type definition and has the list of classes that implements the interface.Now that we have all the types and interfaces to be registered, we need to register them into the container. For any interface that has only one type implementing it, we register it with default name else we get the name from the class name or the attribute that decorates the class if any.</p>

<pre><code class="csharp">private static void RegisterConventions(IUnityContainer container)
{
    foreach (var typeMapping in internalTypeMapping)
    {
        if (typeMapping.Value.Count == 1)
        {
            var type = typeMapping.Value.First();
            container.RegisterType(typeMapping.Key, type);
        }
        else
        {
            foreach (var type in typeMapping.Value)
            {
                container.RegisterType(typeMapping.Key, type, GetNameForRegsitration(type));
            }
        }
    }
}
</code></pre>

<p>The dependency with UnityContainer with the IoCConveniton class, can be easily removed by having an adapter interface into any container. To keep things simple I am having the direct dependency on the container in the sample. From the console application we can create a new container and use the convention class to register the dependencies. The factory implementations have the expected class conventions inside them that would be used to resolve the dependencies. Since the factory is part of the composition root I am using a <a href="http://blog.ploeh.dk/2012/03/15/ImplementinganAbstractFactory/">container based factory</a>, to resolve the dependencies.</p>

<pre><code class="csharp">IUnityContainer unityContainer = new UnityContainer();
IoCConvention.RegisterByConvention(unityContainer);
</code></pre>

<p>This has really taken off a lot of work for all the developers in the team and registrations of dependencies works seamlessly. You can find the sample convention implementation <a href="https://github.com/rahulpnath/Blog/tree/master/IocConventionRegistration">here</a>. Are you using convention registrations in your applications? If not you should start using them.
<a href="http://www.codeproject.com" style="display:none" rel="tag">CodeProject</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Configuring Unity Container: Comparing Code and Xml Configuration Side by Side]]></title>
    <link href="http://rahulpnath.com/blog/configuring-unity-container-comparing-code-and-xml-configuration-side-by-side/"/>
    <updated>2014-10-19T11:42:54+00:00</updated>
    <id>http://rahulpnath.com/blog/configuring-unity-container-comparing-code-and-xml-configuration-side-by-side</id>
    <content type="html"><![CDATA[<p>Setting up dependency containers from code is very easy, but not at all the same when done using a configuration file. The project that I am currently working on uses xml configuration for <a href="https://unity.codeplex.com/">Unity container</a> and I did struggle mapping certain dependencies, so thought of putting this up.</p>

<p>To start with I have created a console application and added the Unity <a href="https://www.nuget.org/packages/Unity/">nuget package</a>. You could directly add the configurations in the app.config file, but I prefer to keep the configurations separately in a different file, <em>unity.config</em>, and have it referred in the app.config(or web.config). Also make sure that the unity.config file gets copied to the build directory(setting build properties as content and copy always should help) so that it is available to the application.</p>

<pre><code class="xml app.config">&lt;configSections&gt;
  &lt;section name="unity" type="Microsoft.Practices.Unity.Configuration.UnityConfigurationSection, Microsoft.Practices.Unity.Configuration"/&gt;
&lt;/configSections&gt;
&lt;unity configSource="unity.config" /&gt;
</code></pre>

<p>In the unity.config we need to specify the assemblies and namespaces that we will be injecting the dependencies from. Inside the container is where we register the dependencies.</p>

<p>&#8220;` xml unity.config
<unity xmlns="http://schemas.microsoft.com/practices/2010/unity"></p>

<!-- Define Assemblies-->


<p><assembly name="ConfiguringUnity" /></p>

<!-- End Assemblies-->


<!-- Define Namespaces-->


<p><namespace name="ConfiguringUnity" /></p>

<!-- End Namespaces-->


<p><container></p>

<p></container>
</unity>
&#8220;`</p>

<p>Now that we have the basic infrastructure set up to start using the container, lets take a look at some common dependency injection scenarios that we come across. The <a href="http://msdn.microsoft.com/en-us/library/ff660914(v=pandp.20).aspx">Unity Configuration Schema</a> is worth  taking a look, to understand about the configuration elements and their attributes.</p>

<p><strong>Simple Class and Interface</strong><br/>
<code>csharp C#
this.unityContainer.RegisterType&lt;NormalClass&gt;();
this.unityContainer.RegisterType&lt;INormalInterface, NormalInterfaceImplementation&gt;();
</code>
<code>xml unity.config
&lt;register type="NormalClass" /&gt;
&lt;register type="INormalInterface" mapTo="NormalInterfaceImplementation" /&gt;
</code>
Since we have only given the interface name while registering the type, specifying the assembly and namespace names of the type is important.Unity will look through these elements to find the type specified, whenever the specified type is not a full type name. This mechanism is also referred to as <a href="http://msdn.microsoft.com/en-us/library/ff660933(v=pandp.20).aspx#_Automatic_Type_Lookup">Automatic Type Lookup</a></p>

<p><strong>Generic Interface</strong>
<code>csharp C#
this.unityContainer.RegisterType(typeof(IGenericInterface&lt;&gt;), typeof(GenericInterfaceImplementation&lt;&gt;));
this.unityContainer.RegisterType(typeof(IGenericInterfaceWithTwoParameter&lt;,&gt;), typeof(GenericInterfaceWithTwoParametersImplementation&lt;,&gt;));
</code>
<code>xml unity.config
&lt;register type="IGenericInterface`1" mapTo="GenericInterfaceImplementation`1" /&gt;
&lt;register type="IGenericInterfaceWithTwoParameter`2" mapTo="GenericInterfaceWithTwoParametersImplementation`2" /&gt;
// or
&lt;register type="IGenericInterface[]" mapTo="GenericInterfaceImplementation[]" /&gt;
&lt;register type="IGenericInterfaceWithTwoParameter[,]" mapTo="GenericInterfaceWithTwoParametersImplementation[,]" /&gt;
</code>
As shown above registering <a href="http://msdn.microsoft.com/en-us/library/ff660933(v=pandp.20).aspx#_Generic_Types">generic types</a> in config can either use the CLR notation of <code>N, where N is the number of generic parameters or use square brackets with commas to indicate the number of parameters. Examples using one and two parameters are shown above.   
For a generic interface, the parameters can have typed parameter associated with it, something like *IComplexGenericInterface&lt;ComplexGenericClass&lt;GenericClass&gt;&gt;*. In these cases we cannot directly register this using either of the notation above, as the configuration does not allow recursive formats of those notation. We can use [Aliases](http://msdn.microsoft.com/en-us/library/ff660933(v=pandp.20\).aspx#_Type_Aliases) for specifying the parameter type names and then refer the alias for registering the interface.
<figure class='code'><figcaption><span>C#</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">this</span><span class="p">.</span><span class="n">unityContainer</span><span class="p">.</span><span class="n">RegisterType</span><span class="p">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">IComplexGenericInterface</span><span class="p">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">ComplexGenericClass</span><span class="p">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">GenericClass</span><span class="p">&amp;</span><span class="n">gt</span><span class="p">;&amp;</span><span class="n">gt</span><span class="p">;,</span> <span class="n">ComplexGenericInterfaceImplementation</span><span class="p">&amp;</span><span class="n">gt</span><span class="p">;();</span>
</span></code></pre></td></tr></table></div></figure>
&#8220;`xml unity.config
 &lt;alias alias=&#8221;ComplexGenericInterfaceType&#8221;
         type=&#8221;ConfiguringUnity.ComplexGenericClass</code>1[[ConfiguringUnity.GenericClass, ConfiguringUnity, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], ConfiguringUnity, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&#8221; />
<container>
  <register type="IComplexGenericInterface[ComplexGenericInterfaceType]" mapTo="ComplexGenericInterfaceImplementation" />
</container>
&#8220;`
As shown above alias is nothing but a shorthand name that will be replaced with the full type name when the configuration is loaded. This is only available at configuration time and not at runtime.</p>

<p><strong>Conflicting Interfaces</strong> <br/>
When you have conflicting interface names , probably from two different assemblies then you can create aliases or use full names to register the types. For the example I have created a class library project, ExternalLibrary and added it as a reference to the Console Application.
<code>csharp C#
this.unityContainer.RegisterType&lt;IConflictingInterface, ConflictingInterfaceImplementation&gt;();
            this.unityContainer.RegisterType&lt;ExternalLibrary.IConflictingInterface, ExternalLibrary.ConflictingInterfaceImplementation&gt;();
</code>
<code>xml unity.config
&lt;register type="IConflictingInterface" mapTo="ConflictingInterfaceImplementation" /&gt;
&lt;register type="ExternalLibrary.IConflictingInterface, ExternalLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" mapTo="ExternalLibrary.ConflictingInterfaceImplementation, ExternalLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" /&gt;
</code></p>

<h4><strong><em>Code and Config</em></strong> instead of <strong><em>Code Vs Config</em></strong></h4>

<p>Now that we have seen some of the common usage scenarios in registering types with containers, one main thought would be &lsquo;<a href="http://stackoverflow.com/questions/5418392/should-unity-be-configured-in-code-or-configuration-file">Should Unity be configured in code or configuration file?</a>&rsquo;. Xml configurations are anytime a pain for the developer as it more prone to errors and configuration complexities. But then there are scenarios where dependencies would have to be plugged in at runtime, for which xml configuration is really helpful. Unity does allow to specify both together, making the best use of both worlds. You can choose to have only your dependencies that are Late Bound in the config and have all others in the code. You could also override an already registered dependency.
<code>csharp C#
this.unityContainer.RegisterType&lt;IOverridableDependency, OverridableCodeImplementation&gt;();
</code>
<code>xml unity.config
&lt;register type="IOverridableDependency" mapTo="OverridableConfigImplementation" /&gt;
</code>
As shown above we have a different mapping in code and config for the same interface and I am loading the configuration into the container after all the  code registrations are done. In this case the dependency that is registered last will take precedence. So you could use this feature to override any dependencies specified in the code.</p>

<p>There surely are a lot more cases that you would have come across while registering dependencies, do drop in a comment on the missing ones. The sample for this can be found <a href="https://github.com/rahulpnath/Blog/tree/master/ConfiguringUnity">here</a>
<a href="http://www.codeproject.com" style="display:none" rel="tag">CodeProject</a></p>
]]></content>
  </entry>
  
</feed>
