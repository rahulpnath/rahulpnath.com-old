<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: .net core | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/dot-net-core/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2019-01-05T00:02:34+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[.Net Core Web App and Azure AD Groups Role based access]]></title>
    <link href="http://rahulpnath.com/blog/dot-net-core-api-and-azure-ad-groups-based-access/"/>
    <updated>2018-12-11T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/dot-net-core-api-and-azure-ad-groups-based-access</id>
    <content type="html"><![CDATA[<p>Getting your application to provide capabilities based on the role of the User using the system is a common thing. When using Azure Active Directory (AD), the Groups feature allows organizing users of your system into different roles. In the applications that we build, the group information can be used to enable/disable functionality. For, e.g., if your application has the functionality to add new users you might want to restrict this to only users belonging to the administrator role.</p>

<p><a href="https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-groups-create-azure-portal">Adding new groups</a> can be done using the Azure portal. Select Group Type, <em>Security</em> as it is intended to provide permissions based on roles.</p>

<p><img src="/images/azure_ad_Groups.png" alt="Azure AD Add Group" class="center" /></p>

<p>For the Groups to be returned as part of the claims, the <em>groupMembershipClaims</em> property in application manifest needs to be updated. Setting it to <em>SecurityGroup</em> will return all SecurityGroups of the user.</p>

<pre><code class="json Azure AD Manifest - Group Membership Claims">{
    "groupMembershipClaims": "SecurityGroup"
}
</code></pre>

<p>For each group created an <em>ObjectId</em> is assigned to it which is what gets returned as part of the claims. You can either add it as part of your applications config file or use Microsoft Graph API to query the list of groups at runtime. Here I have chosen to keep it as part of the config file.</p>

<pre><code class="json appsettings.json">"AdGroups": [
  {
    "GroupName": "Admin",
    "GroupId": "119f6fb5-a325-47f9-9889-ae6979e9e120"
  },
  {
    "GroupName": "Employee",
    "GroupId": "02618532-b2c0-4e58-a32e-e715ddf07f63"
  }
]
</code></pre>

<p>Now that we have all the groups and associated configuration setup, we can wire up the .Net Core web application to start using the groups from the claims to enable/disable features. Using the <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-2.2">Policy-based authorization</a> capabilities of .Net core application we can wire up policies for all the groups we have.</p>

<blockquote><p><em><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-2.2">Role-based authorization and claims-based authorization</a> use a requirement, a requirement handler, and a pre-configured policy. These building blocks support the expression of authorization evaluations in code. The result is a richer, reusable, testable authorization structure.</em></p></blockquote>

<p>We have an <em>IsMemberOfGroupRequirement</em> class to represent the requirement for all the groups, the <em>IsMemberOfGroupHandler</em> that implements how to validate a group requirement. The Handler reads the current user&rsquo;s claims and checks it contains the objectId associated with the Group as a claim. If a match is found the requirement check is marked as a success. Since we want the request to continue to match for any other group requirements the requirement is not failed explicitly.</p>

<pre><code class="csharp IsMemberOfGroup Requirement">public class IsMemberOfGroupRequirement : IAuthorizationRequirement
{
    public readonly string GroupId ;
    public readonly string GroupName ;

    public IsMemberOfGroupRequirement(string groupName, string groupId)
    {
        GroupName = groupName;
        GroupId = groupId;
    }
}

public class IsMemberOfGroupHandler : AuthorizationHandler&lt;IsMemberOfGroupRequirement&gt;
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context, IsMemberOfGroupRequirement requirement)
    {
        var groupClaim = context.User.Claims
             .FirstOrDefault(claim =&gt; claim.Type == "groups" &amp;&amp;
                 claim.Value.Equals(requirement.GroupId, StringComparison.InvariantCultureIgnoreCase));

        if (groupClaim != null)
            context.Succeed(requirement);

        return Task.CompletedTask;
    }
}
</code></pre>

<p>Registering the policies for all the groups in the application&rsquo;s configuration file and the handler can be done as below. Looping through all the groups in the config we create a policy for each with the associated GroupName. It allows us to use the GroupName as the policy name at places where we want to restrict features for users belonging to that group.</p>

<pre><code class="csharp Registering Policy and Handler">services.AddAuthorization(options =&gt;
{
    var adGroupConfig = new List&lt;AdGroupConfig&gt;();
    _configuration.Bind("AdGroups", adGroupConfig);

    foreach (var adGroup in adGroupConfig)
        options.AddPolicy(
            adGroup.GroupName, 
            policy =&gt;
                policy.AddRequirements(new IsMemberOfGroupRequirement(adGroup.GroupName, adGroup.GroupId)));
});

services.AddSingleton&lt;IAuthorizationHandler, IsMemberOfGroupHandler&gt;();
</code></pre>

<p>Using the policy is now as simple as decorating your controllers with the Authorize attribute and providing the required Policy names on it as shown below.
<code>csharp
[Authorize(Policy = "Admin")]
[ApiController]
public partial class AddUsersController : ControllerBase
{
    ....
}
</code></p>

<p>Hope this helps you to setup Role-based functionality for your ASP.Net Core applications using Azure AD as authentication/authorization provider.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Azure AD Custom Attributes and Optional Claims from an ASP.Net Application]]></title>
    <link href="http://rahulpnath.com/blog/azure-ad-custom-attributes-and-optional-claims-from-an-asp-dot-net-application/"/>
    <updated>2018-12-10T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/azure-ad-custom-attributes-and-optional-claims-from-an-asp-dot-net-application</id>
    <content type="html"><![CDATA[<p>When using Azure Active Directory for managing your users, it is a common requirement to add additional attributes to your Users like SkypeId, employee code, EmployeeId and similar. Even though this happens to be a common need, getting this done is not that straightforward. This post describes how you can get additional properties on User objects in Azure AD.</p>

<p>Recently when I had to do this at a client, we had users in Azure AD, the additional property, employeeCode for the user was available in an internal application which had the users Azure email-address mapped to it. We needed these to be synced across to the user Azure AD and make it available as part of claims for a Web site that uses <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/authentication-scenarios">Azure AD authentication</a></p>

<h3>Adding Custom Attribute using Directory Schema Extensions</h3>

<p>Azure AD user has a set of <a href="https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-users-profile-azure-portal">default properties</a>, manageable through the Azure Portal. Any additional property to User gets added as an extension to the current user Schema. To add a new property we first need to <a href="https://msdn.microsoft.com/library/azure/ad/graph/howto/azure-ad-graph-api-directory-schema-extensions#RegisterAnExtension">register an extension</a>. Adding a new extension can be done using the <a href="https://graphexplorer.azurewebsites.net/">GraphExplorer website</a>. You need to specify the appropriate directory name (e.g., <em>contoso.onmicrosoft.com</em>) and the applicationObjectId. The application object id is the Object Id of the AD application that the Web Application uses to authenticate with Azure AD.</p>

<blockquote><p><em><a href="https://docs.microsoft.com/en-us/graph/extensibility-overview#azure-ad-directory-schema-extensions">Azure AD supports</a> a similar type of extension, known as directory schema extensions, on a few directory object resources. Although you have to use the Azure AD Graph API to create and manage the definitions of directory schema extensions, you can use the Microsoft Graph API to add, get, update and delete data in the properties of these extensions.</em></p></blockquote>

<pre><code class="json">POST https://graph.windows.net/contoso.onmicrosoft.com/applications/
    &lt;applicationObjectId&gt;/extensionProperties?api-version=1.5 HTTP/1.1
{
    "name": "employeeCode&lt;optionalEnvironmentName&gt;",
    "dataType": "String",
    "targetObjects": [
        "User"
    ]
}
</code></pre>

<p>The response gives back the fully-qualified extension property name, which is used to write values to the property. Usually the name is of the format <em>extension_&lt;adApplicationIdWithoutDashes>_extensionPropertyName</em></p>

<p>If you have multiple environments (like Dev, Test, UAT, Prod) all pointing to the same Active Directory, it is a good idea to append the environment name to the extension property. It avoids any bad data issues between environments as all these properties get written to the same User object. You can automate the above step using any scripting language of your choice if required.</p>

<h3>Setting Values for Custom Attributes</h3>

<p>Now that we have the extension property created on the AD application, we can set the property on the User object. If you want to set this manually, you can use the <a href="https://graphexplorer.azurewebsites.net/">GraphExplorer website</a> again to do this.</p>

<pre><code class="json">PATCH https://graph.windows.net/contoso.onmicrosoft.com/users
        /jim@contoso.onmicrosoft.com?api-version=1.5
{
    "extension_ab603c56068041afb2f6832e2a17e237_employeeCode&lt;optionalEnvironmentName&gt;": "EMP124"
}
</code></pre>

<p>In our case it was not a one-off case of updating the User object, so better wanted this to be automated. Employee codes were available from a database with the associated Azure AD email address. So we created a windows service job that would sync these codes to Azure AD. You can write to Azure AD schema extension properties using <a href="https://developer.microsoft.com/en-us/graph">Microsoft Graph API</a>. Add a reference to the <a href="https://www.nuget.org/packages/Microsoft.Graph">Microsoft Graph NuGet package</a>, and you are all set to go. For the Graph API to authenticate, use a different Azure AD app (separate to the one that you registered the extension property on, which the web app uses to authenticate), just because it needs additional permissions as well and it is a good idea to isolate that. Under Settings -> Required Permissions, Add Microsoft Graph and provide the relevant permissions for it to write the user&rsquo;s profile/directory data.</p>

<p><img
    src="/images/azureAd_GraphApi_Permissions.png"
    class="center"
    alt="Azure AD Graph API Permissions" /></p>

<pre><code class="csharp Get Graph Api Client">private static async Task&lt;GraphServiceClient&gt; GetGraphApiClient()
{
    var clientId = ConfigurationManager.AppSettings["AppId"];
    var secret = ConfigurationManager.AppSettings["Secret"];
    var domain = ConfigurationManager.AppSettings["Domain"];

    var credentials = new ClientCredential(clientId, secret);
    var authContext =
        new AuthenticationContext($"https://login.microsoftonline.com/{domain}/");
    var token = await authContext
        .AcquireTokenAsync("https://graph.microsoft.com/", credentials);

    var graphServiceClient = new GraphServiceClient(new DelegateAuthenticationProvider((requestMessage) =&gt;
    {
        requestMessage
            .Headers
            .Authorization = new AuthenticationHeaderValue("bearer", token.AccessToken);

        return Task.CompletedTask;
    }));

    return graphServiceClient;
}
</code></pre>

<pre><code class="csharp Update Extension Value">private async Task UpdateEmployeeCode(
    string employeeCodePropertyName, GraphServiceClient graphApiClient, Employee employee)
{
    var dictionary = new Dictionary&lt;string, object&gt;();
    dictionary.Add(employeeCodePropertyName, employee.Code);

    await graphApiClient.Users[employee.EmailAddress]
        .Request()
        .UpdateAsync(new User()
        {
            AdditionalData = dictionary
        });
}
</code></pre>

<p>Looping through all the employee codes, you can update all of them into Azure AD at regular intervals. To verify that the attributes are updated correctly, you can either use the Graph API client to read the extension property or use the Graph Explorer Website.</p>

<h3>Accessing Custom Attributes through Claims</h3>

<p>With the Azure AD updated with the employee code for each user, we can now set up the AD application to return the additional property as part of the claims, when the web application authenticates with it. The application manifest of the Azure AD application needs to be modified to return the extension property as part of the claims. By default <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-optional-claims#configuring-optional-claims">optionalClaims property</a> is set to null and you can update it with the below values.</p>

<p><img
    src="/images/AzureAd_schema_extension_optionalClaims.png"
    class="center" alt="Azure AD Application Manifest - Optional Claims" /></p>

<pre><code class="json Optional Claims in Azure AD Application Manifest">"optionalClaims": {
    "idToken": [
      {
        "name": "extension_&lt;id&gt;_employeeCodeLocal",
        "source": "user",
        "essential": true,
        "additionalProperties": []
      }
    ],
    "accessToken": [],
    "saml2Token": []
  },
</code></pre>

<p>I updated the idToken property as the .Net Core Web Application was using JWT ID token. If you are unsure of what token you can use <a href="https://rahulpnath.com/blog/fiddler-free-web-debugging-proxy/">Fiddler</a> to find what kind of token is used (as shown below).</p>

<p><img src="/images/AzureAd_idToken.png" class="center" alt="Id token returned" /></p>

<p>With the optonalClaims set, the web application is all set to go. For an authenticated user (with the extension property set), the extension property is available as part of claims. The claim type will be &lsquo;<em>extn.employeeCode<optionalEnvironmentNam></em>&rsquo;. The below code can be used to extract the employee code from the claim.</p>

<pre><code class="csharp Get Employee Code From Claim">public static string GetEmployeeCode(this ClaimsPrincipal claimsPrincipal)
{
    if (claimsPrincipal == null || claimsPrincipal.Claims == null)
        return null;

    var empCodeClaim = claimsPrincipal.Claims
        .FirstOrDefault(claim =&gt; claim.Type.StartsWith("extn.employeeCode"));

    return empCodeClaim?.Value;
}
</code></pre>

<div class="alert alert-warning">
Usually, the claims start flowing through immediately. However, once it did happen to me that the claims did not come for over a long period. Not sure what I did wrong, but once I deleted and recreated the AD application, it started working fine.
</div>


<p>Although setting additional properties on Azure AD Users is a common requirement, setting it up is not that straight-forward. Hope the portal improves someday, and it would be as easy as setting a list of key-value properties as extension properties, and it would all seamlessly flow through as part of the claims. However, till that day, hope this helps you to set up extra information on your Azure AD users.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up Build and Deploy Pipeline for a .NET Core Console Application]]></title>
    <link href="http://rahulpnath.com/blog/build-and-deploy-a-net-core-console-application/"/>
    <updated>2018-01-03T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/build-and-deploy-a-net-core-console-application</id>
    <content type="html"><![CDATA[<p>I was given a console application written in .NET Core 2.0 and asked to set up a continuous deployment pipeline using <a href="https://www.jetbrains.com/teamcity/">TeamCity</a> and <a href="https://octopus.com/">Octopus Deploy</a>. I struggled a bit with some parts, so thought it&rsquo;s worth putting together a post on how I went about it. If you have a better or different way of doing things, please shout out in the comments below.</p>

<p>At the end of this post, we will have a console application that is automatically deployed to a server and running, anytime a change is pushed to the associated source control repository.</p>

<h3>Setting Up TeamCity</h3>

<p>Create a <a href="https://confluence.jetbrains.com/display/TCD10/Creating+and+Editing+Projects">New Project</a> and add a <a href="https://confluence.jetbrains.com/display/TCD10/Creating+and+Editing+Build+Configurations">new build configuration</a> just like you would for any other project. Since the application is in .NET Core, install the <a href="https://github.com/JetBrains/teamcity-dotnet-plugin">.NET CLI plugin</a> on the TeamCity server.</p>

<p><img src="/images/net_core_teamcity_build_steps.png" alt="Build Steps to build .Net Core"></p>

<p>The first three build steps use the .NET CLI to <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-restore?tabs=netcore2x">Restore</a>, <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-build?tabs=netcore2x">Build</a> and <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-publish?tabs=netcore2x">Publish</a> the application. Thee three steps restore the dependencies of the project, builds it and publishes all the relevant DLL&rsquo;s into the publish folder.</p>

<p>The published application now needs to be packaged for deployment. In my case, deployments are managed using Octopus Deploy. For .NET projects, the preferred way of packaging for Octopus is using <a href="https://octopus.com/docs/packaging-applications/creating-packages/nuget-packages/using-octopack">Octopack</a>. However, OctoPack does not support .NET Core projects. The recommendation is to either use <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-pack?tabs=netcore2x">dotnet pack</a> or <a href="https://octopus.com/docs/packaging-applications/creating-packages/nuget-packages/using-octo.exe">Octo.exe pack</a>. Using the latter I have set up a Command Line build step to pack the contents of the published folder into a zip (.nupkg) file.</p>

<pre><code class="bash">octo pack --id ApplicationName --version %build.number% --basePath published-app 
</code></pre>

<p>The NuGet package is published to the NuGet server used by Octopus. Using the <a href="https://octopus.com/docs/api-and-integration/teamcity">Octopus Deploy: Create Release</a> build step, a new release is triggered in Octopus Deploy.</p>

<h3>Setting Up Octopus Deploy</h3>

<p>Create a <a href="https://octopus.com/docs/deployment-process/projects">new project</a> in Octopus Deploy to manage deployments. Under the Process tab, I have two <a href="https://octopus.com/docs/deployment-process/steps">steps</a> - one to deploy the Package and another to start the application.</p>

<p><img src="/images/net_core_octopus_deploy_process.png" alt="Octopus Deploy Process Steps"></p>

<p>For the Deploy Package step I have enabled Custom Deployment Scripts and <a href="https://octopus.com/docs/deploying-applications/deploying-asp.net-core-web-applications/json-configuration-variables-feature">JSON Configuration variables</a>. Under the pre-deployment script, I stop any existing .NET applications. If multiple .NET applications are running on the box, select your application explicitly.</p>

<pre><code class="powershell Pre Deployment Script">Stop-Process -Name dotnet -Force -ErrorAction SilentlyContinue
</code></pre>

<p>Once the package is deployed, the custom script starts up the application.</p>

<pre><code class="powershell Run App">cd C:\DeploymentFolder
Start-Process dotnet .\ApplicationName.dll
</code></pre>

<p>With all that set, any time a change is pushed into the source control repository, TeamCity picks that up, build and triggers a deployment to the configured environments in Octopus Deploy. Hope this helps!</p>
]]></content>
  </entry>
  
</feed>
