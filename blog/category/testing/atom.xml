<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: testing | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/testing/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2018-07-23T00:02:53+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Managing Your Postman API Specs]]></title>
    <link href="http://rahulpnath.com/blog/manage-your-postman-api-specs/"/>
    <updated>2018-07-02T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/manage-your-postman-api-specs</id>
    <content type="html"><![CDATA[<p>In the previous post, we explored how to use <a href="Automated%20API%20Testing%20Using%20Postman%20Collection%20Runner">Postman for testing API endpoints</a>. Postman is an excellent tool to manage API specs as well, so that you can try API requests individually to see how things are working. It also acts as documentation for all your API endpoints and serves as a good starting point for someone new to the team. When it comes to managing the API specs for your application, there are a few options that we have and let&rsquo;s explore what they are.</p>

<h3>Organizing API Specs</h3>

<p>Postman supports the concept of <a href="https://www.getpostman.com/docs/v6/postman/collections/creating_collections">Collections</a>, which are nothing but a Folder to group of saved API requests/Specs. Collections support nesting which means you can add Folders within a collection to further group them. As you can see below the <em>MyApplication</em> and <em>Postman Echo</em> are collections, and there are subfolders inside them which in turn contains API requests. The multi-level hierarchy helps you to organize your requests the way you want to.</p>

<p><img src="/images/postman_collections.png" alt="Postman Collections" class ="center"></p>

<h3>Sharing API Specs</h3>

<p>Any Collection that you create in Postman is automatically synced to Postman Cloud if you are logged in with an account. It allows you to share collections through a link. With <a href="https://www.getpostman.com/pricing">paid version of Postman</a> you get to create <a href="https://www.getpostman.com/workspaces">team workspaces</a>, which means a team can collaborate on the shared versions. It allows easy sharing of specs across your team and manages them in a centralized place.</p>

<p>However, if you are not logged in or don&rsquo;t have a paid version of Postman, you can maintain the specs along with your Source Code. Postman allows you to <a href="https://www.getpostman.com/docs/v6/postman/collections/sharing_collections#sharing-as-a-file">export Collections and share specs as a JSON file</a>. You can then check this file into your source code repository. Other team members can Import the exported file to get the latest specs. The only disadvantage with this is that you need to make sure to export/import every time you/other team members make a change to the JSON file. However, I have seen this approach work well in teams and one way we made sure that the JSON file was up to date is to have to update the API spec as a Work Item and which required to be <a href="https://rahulpnath.com/blog/code-review/">peer reviewed</a>(through Pull Requests)</p>

<h3>Managing Environments</h3>

<p>Typically any application/API would be deployed to multiple environments (like localhost, Development, Testing, Production, etc.) and you would want to switch between these environments to test your API endpoints seamlessly. Postman makes this easy by using the <a href="https://www.getpostman.com/docs/v6/postman/environments_and_globals/manage_environments">Environment Feature</a>.</p>

<p><img src="/images/postman_environment.png" alt="Postman Environment" class="center" /></p>

<p>Again as with Collections, Environments are also synced to Postman Cloud when you are logged in. It makes all your environments available to all your team seamlessly. However, if you are not logged in you can again export the environments as a JSON file and then share that out of band (in a secure manner as this might have sensitive information like tokens, keys, etc.) with your team.</p>

<h3>Publishing API Specs</h3>

<p>Postman allows you to <a href="https://www.getpostman.com/docs/v6/postman/api_documentation/publishing_public_docs">publish API specs</a> (even to a custom URL), which can act like your API Documentation. You can publish it per environments and also easily execute them. Publishing is available only if you log in to an account as it requires the API Specs and environment details in the first place.</p>

<p><img src="/images/postman_published.png" alt="Postman Published" class="center" /></p>

<h3>Security Considerations</h3>

<p>When using the sync feature of Postman (logged in to the application with Postman account), it is <a href="https://www.getpostman.com/docs/v6/postman_for_publishers/run_button/security">recommended</a> that you do not have any sensitive information (like passwords/tokens) as part of the API request spec/Collection. These should be extracted out as Environment variables and stored as part of the appropriate environment.</p>

<p>If you are logged in, all the data that you add to it is automatically synced, which means it will be living in Postman&rsquo;s cloud server. This might not be a desirable option for every company but looks like there is no option to turn sync off at the Collection level. The only way to not sync collections is to not log into an account in Postman.</p>

<div class="alert alert-warning">
    <i>
    If you are logged into Postman then any collection that you create is automatically synced to Postman server. Only way to <a href="https://support.getpostman.com/hc/en-us/articles/203492852-How-do-I-disable-Sync-">prevent sync</a> is not to log in
    </i>
</div>


<p>We have seen the options by which you can share API collections and environments amongst your team even if you are logged in. However, one thing to be aware of is if any of your team members are logged into Postman and imports a collection shared via Repository/out of band methods, it will be synced to Postman server. So at the organization/team level, you would need ways to prevent this from happening if it is essential for you. Best is to have your API&rsquo;s designed in such a way that you do not have to expose such sensitive information, which anyways is a better practice.</p>

<p>Hope this allows to manage your API specs better!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automated API Testing Using Postman Collection Runner]]></title>
    <link href="http://rahulpnath.com/blog/automated-api-testing-using-postman-collection-runner/"/>
    <updated>2018-06-26T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/automated-api-testing-using-postman-collection-runner</id>
    <content type="html"><![CDATA[<p>A while back we looked at how we can use <a href="https://rahulpnath.com/blog/postman-chaining-requests-to-speed-up-manual-api-tests/">Postman to chain multiple requests to speed up out Manual API Testing</a>. For those who are not familiar with <a href="https://www.getpostman.com/">Postman</a>, it is an application that assists in API testing and development, which I see as sitting a level top of a tool like <a href="https://rahulpnath.com/blog/fiddler-free-web-debugging-proxy/">Fiddler</a>.</p>

<p>In this post, we will see how we can use Postman to test some basic CRUD operations over an API using a feature called <a href="http://blog.getpostman.com/2016/11/22/postmans-new-collection-runner/">Postman Runner</a>. Using this still involves some manual intervention. However, we can automate them using a combination of different tools.</p>

<h3>Setting Up the API</h3>

<p>To start with I create a simple API endpoint using the out of the box Web API project from Visual Studio 2017. It is a Values Controller which stores key-value pairs to which you can send GET, POST, DELETE requests. Below is the API implementation. It is a simple in-memory implementation and does not use any persistent store. However, the tests would not change much even if the store was to be persistent. The importance here is not in the implementation of the API, but how you can use Postman to add some quick tests.</p>

<pre><code class="csharp ValuesController">public class ValuesController : ApiController
{
    static Dictionary&lt;int, string&gt; values = new Dictionary&lt;int, string&gt;();

    public IEnumerable&lt;string&gt; Get()
    {
        return values.Values;
    }

    public IHttpActionResult Get(int id)
    {
        if (values.ContainsKey(id))
            return Ok(values[id]);

        return NotFound();
    }

    public IHttpActionResult Post(int id, [FromBody]string value)
    {
        values[id] = value;
        return Ok();
    }

    public IHttpActionResult Delete(int id)
    {
        if (!values.ContainsKey(id))
            return NotFound();

        values.Remove(id);
        return Ok();
    }
}
</code></pre>

<h3>Setting Up Postman</h3>

<p>To start with we will create a new Collection in Postman to hold our tests for the Values Controller - I have named it &lsquo;<em>Values CRUD - Test</em>&rsquo;. The collection is a container for all the API requests that we are going to write. First, we will add all the request definitions into postman which we can later reorder for the tests.</p>

<p><img src="/images/postman_request.png" alt="Postman Request" class="center" /></p>

<blockquote><p>The <em><strong>/</strong></em> in the URL are parameters defined as part of the selected Environment. Environments in Postman allow you to switch between different application environments like Development, Test, Production. You can configure different values for each environment and Postman will send the requests as per the configuration.</p></blockquote>

<p>Below are the environment variables for my local environment. You can define as many environments as you want and switch between them.</p>

<p><img src="/images/postman_environment.png" alt="Postman Environment" class="center" /></p>

<p>Now that I have all the request definitions for the API added let&rsquo;s add some tests to verify our API functionality.</p>

<h3>Writing The First Test</h3>

<p>Postman allows executing scripts before and after running API requests. We did see this in the <a href="https://rahulpnath.com/blog/postman-chaining-requests-to-speed-up-manual-api-tests/">API Chaining post</a> where we grabbed the <em>messageId</em> from the POST request and added it to the environment variable for use in the subsequent requests. Similarly, we can also add scripts to verify that the API request returns expected results, status code, etc.</p>

<p>Let&rsquo;s first write a simple test on our GET API request that it returns a 200 OK response when called. The below test uses the <a href="https://www.getpostman.com/docs/v6/postman/scripts/postman_sandbox_api_reference">Postmans PM API</a> to assert that status code of the response is 200. Check the <em><a href="https://www.getpostman.com/docs/v6/postman/scripts/postman_sandbox_api_reference#response-assertion-api-in-test-scripts">Response Assertion API in test scripts</a></em> to see the other assertion options available like <em>pm.response.to.have.status</em>. The tests are under the Tests section similar to where wrote the scripts to chain API requests. When executing the API request, the Tests tab shows the successful test run for the particular request.</p>

<pre><code class="javascript 200 Status Code">pm.test("Status code is 200", function() {
  pm.response.to.have.status(200);
});
</code></pre>

<p><img src="/images/postman_tests.png" alt="Postman Tests" class="center" /></p>

<p>Similarly, you can also write <em>Pre-request Script</em> to set variables or perform any other operation. Below I am setting the <em>Value</em> environment variable to &ldquo;Test&rdquo;. You could generate a random value here or set a random id, or set an identifier that does not already exists. It&rsquo;s test/application specific, so leave it you to decide what works best for you.</p>

<pre><code class="javascript Pre-request Script.">pm.environment.set("Value", "Test");
</code></pre>

<h3>Collection Runner</h3>

<p>The collection runner allows you to manage multiple API requests and run them as a set. Once completed it shows a summary of all the tests included within each request and details of tests that passed/failed in the run. You can target the Runner to run against your environment of choice.</p>

<p><img src="/images/postman_collection_runner.png" alt="Postman Collection Runner" class="center" /></p>

<p>Running these tests still involves some manual effort of selecting environments and running them. However using <a href="https://www.npmjs.com/package/newman">Newman</a>, you can run Postman Collections from the command line, which means even in your build pipeline.</p>

<p>Using Postman, we can quickly test our API&rsquo;s across multiple environments. The Collection Runner also shows an excellent visual summary of the tests and helps us in API development. However, I found these tests to violate the <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY principle</a>. You need to repeat the same API request structure if you have to use them in a different context. Like in the example above I had to create two <em>Get Value By Id</em> requests to test for the value existing and also for when it does not exists. You could use some conditional looping inside the scripts, but then that makes your tests complicated and gets into the loop of how to test your tests. Postman does allow you to export the API request to the language of your choice. So once you have the basic schema, you can export them and write tests that compose them. I find Postman tests and the Runner a quick way to start testing your API endpoints and then for more complicated cases use a stronger programming language. Having the tests in Postman also allows us to have an API spec in place and can be useful to play around with the API.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Semantic Comparison: Improve Test Assertions]]></title>
    <link href="http://rahulpnath.com/blog/semantic-comparison-improve-test-assertions/"/>
    <updated>2017-06-20T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/semantic-comparison-improve-test-assertions</id>
    <content type="html"><![CDATA[<p>One of the traits of a good unit test is to have just <a href="http://osherove.com/blog/2005/4/14/try-to-avoid-multiple-asserts-in-a-single-unit-test.html">one Assert statement.</a>.</p>

<blockquote><p><em>Consider Assert failures as symptoms of a disease and Asserts as indication points or blood checks for the body of the software. The more symptoms you can find, the easier the disease will be to figure out and remove. If you have multiple asserts in one test - only the first failing one reveals itself as failed and you lose sight of other possible symptoms.</em></p>

<p>-<a href="http://osherove.com/">Roy Osherove</a></p></blockquote>

<p>When a test with multiple asserts fails, it is hard to tell the exact reason of test failure. To get more details on the actual failure we either have to debug the tests or look into the stack trace.</p>

<h3>Tests With Multiple Assertions</h3>

<p>Many times we end up needing to assert on more than one properties or behavior. Let&rsquo;s look at a few such examples and see how we can refactor the tests. <em>I have excluded the actual code that is getting is tested here as it is easy to understand what that will look like from the tests. (Drop a comment otherwise)</em></p>

<p><strong>Example 1:</strong> In the below test we have a <em>Name</em> class that represents FirstName and LastName of a user. It exposes a <em>Parse</em> method to make it easy for us to create a Name object from a string. Below are some tests for the Parse method. The test has multiple assertions to confirm that the first and last name properties get set as expected.</p>

<pre><code class="csharp Name class">[Theory]
[InlineData("Rahul", "Rahul", "")]
[InlineData("Rahul Nath", "Rahul", "Nath")]
[InlineData("Rahul P Nath", "Rahul", "P Nath")]
public void FirstNameOnlyProvidedResultsInFirstNameSet(
   string name,
   string expFirstName,
   string expLastName)
{
    var actual = Name.Parse(name);

    Assert.Equal(expFirstName, actual.FirstName);
    Assert.Equal(expLastName, actual.LastName);
}
</code></pre>

<p><strong>Example 2:</strong> The below test is for the <em>Controller</em> class to confirm that the <em>CustomerViewModel</em> passed to the <em>Post</em> method on the controller saves the <em>Customer</em> to the repository. The assert statement includes multiple properties of the customer object, which is just a shorthand version of writing multiple such assert statements on each of those properties.</p>

<pre><code class="csharp Controller Unit Test">[Theory, AutoWebData]
public void PostSavesToRepository(
    CustomerViewModel model,
    [Frozen]Mock&lt;ICustomerRepository&gt; customerRepository,
    CustomerController sut)
{
  var expected = model.ToCustomer();

  sut.Post(model);

  customerRepository.Verify(a =&gt;
    a.Upsert(It.IsAny&lt;Customer&gt;(customer =&gt; 
        customer.Name == expected.Name &amp;&amp;
        customer.Age == expected.Age &amp;&amp;
        customer.Phone == customer.Phone))
}
</code></pre>

<p><strong>Example 3:</strong> The below test ensures that all properties are set when transforming from DTO to domain entity (or any such object transformations at system boundaries). The test asserts on every property of the class.</p>

<pre><code class="csharp Comparing different object types">[Theory]
[AutoMoqData]
public void AllowanceToDomainModelMapsAllProperties(
    Persistence.Allowance allowance, 
    int random)
{
    allowance.EndDate = allowance.StartDate.AddDays(random);

    var actual = allowance.ToDomainModel();

    Assert.Equal(allowance.ClientId, actual.ClientId);
    Assert.Equal(allowance.Credit, actual.Credit);
    Assert.Equal(allowance.Data, actual.Data);
    Assert.Equal(allowance.StartDate, actual.Period.StartDate);
    Assert.Equal(allowance.EndDate, actual.Period.EndDate);
}
</code></pre>

<h3>Semantic Comparison Library</h3>

<p><a href="https://www.nuget.org/packages/SemanticComparison/">Semantic Comparison</a> is a library that allows deep comparison of similar looking objects. Originally part of <a href="http://www.rahulpnath.com/blog/autofixture-make-your-unit-tests-robust/">AutoFixture</a> library, it is also available as a separate <a href="https://www.nuget.org/packages/SemanticComparison/">Nuget package</a>.</p>

<blockquote><p><em>SemanticComparison makes it easier to compare instances of various objects to each other. Instead of performing a normal equality comparison, SemanticComparison compares objects that look semantically similar - even if they are of different types</em></p></blockquote>

<p>Using SemanticComparison, we can compare two objects and compare their properties for equality. It allows including/excluding properties when comparing objects.</p>

<h3>Refactoring Tests</h3>

<p><strong>Example 1:</strong> The <em>Name</em> is a perfect case for being a <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Value Object</a>. In this case, the class will override Equals, and it will be easier for us to write the tests. Converting to a Value Object is one of the cases where we <a href="http://www.rahulpnath.com/blog/tests-as-a-feedback-tool/">use tests as a feedback to improve code</a>. But in cases where you do not have the control over the class or do not want to make it a value object, we can use SemanticComparison to help check for equality as shown below.</p>

<pre><code class="csharp Name Class">[Theory]
[InlineData("Rahul", "Rahul", "")]
[InlineData("Rahul Nath", "Rahul", "Nath")]
[InlineData("Rahul P Nath", "Rahul", "P Nath")]
public void FirstNameOnlyProvidedResultsInFirstNameSet(
   string name,
   string expFirstName,
   string expLastName)
{
    var expected = new Name(expFirstName, expLastName);

    var actual = Name.Parse(name);

    expected
        .AsSource()
        .OfLikeness&lt;Name&gt;()
        .ShouldEqual(actual);
}
</code></pre>

<p><strong>Example 2:</strong>  Using SemanticComparison we can remove the need of asserting on each of the properties. In the below case since the Customer Id is set to a new Guid in the ToCustomer method, I ignore the Id property from the comparison using <em>Without</em>. When the <em>expected</em> objects gets compared against the <em>actual</em> all properties except <em>Id</em> will be compared for equality. Any number of properties can be excluded by chaining multiple <em>Without</em> methods.</p>

<pre><code class="csharp Controller Unit Test">[Theory, AutoWebData]
public void PostSavesToRepository(
    CustomerViewModel model,
    [Frozen]Mock&lt;ICustomerRepository&gt; customerRepository,
    CustomerController sut)
{
  var customer = model.ToCustomer();
  var expected = customer
      .AsSource()
      .OfLikeness&lt;Customer&gt;()
      .Without(a =&gt; a.Id);

  sut.Post(model);

  customerRepository.Verify(a =&gt;
    a.Upsert(It.IsAny&lt;Customer&gt;(actual =&gt; 
        expected.ShoudEqual(actual)));
}
</code></pre>

<p><strong>Example 3:</strong>  Using SemanticComparison we can remove the asserts on every property and also set custom comparisons. The StartDate and EndDate on the persistence entity are converted into a DateRange object (Period). By using the <em>With</em> method in combination with the <em>EqualsWhen</em> method we can set custom comparison behavior that needs to be performed when comparing objects. The same test will hold true even if we add new properties and will force mapping to be updated if any of the property mappings is missed. Here we also see how SemanticComparison can compare two different types.</p>

<pre><code class="csharp Comparing different object types">[Theory]
[AutoMoqData]
public void AllowanceToDomainModelMapsAllProperties(
    Persistence.Allowance allowance, 
    int random)
{
    allowance.EndDate = allowance.StartDate.AddDays(random);

    var actual = allowance.ToDomainModel();

    allowance
        .AsSource()
        .OfLikeness&lt;Allowance&gt;()
        .With(a =&gt; a.Period)
        .EqualsWhen((p, m) =&gt; { return m.Period.StartDate == p.StartDate &amp;&amp; m.Period.EndDate == p.EndDate; })
        .ShouldEqual(actual);
}
</code></pre>

<p>Using SemanticComparison library, we reduce the dependencies on the actual implementation and extract that into a more generic representation. Fewer dependencies on the actual implementation code/properties make the tests more robust and adaptable to change. Hope this helps you get started with Semantic Comparison and improve on your test assertions.</p>

<p><strong>References:</strong></p>

<ul>
<li><a href="http://blog.ploeh.dk/2012/06/21/TheResemblanceidiom/">The Resemblance Idiom</a></li>
<li><a href="http://blog.ploeh.dk/2010/06/29/IntroducingAutoFixtureLikeness/">Introducing AutoFixture Likeness</a></li>
<li><a href="http://blog.ploeh.dk/2012/06/22/ResemblanceandLikeness/">Resemblance and Likeness</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use Tests As A Feedback Tool To Improve Code]]></title>
    <link href="http://rahulpnath.com/blog/tests-as-a-feedback-tool/"/>
    <updated>2017-06-01T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/tests-as-a-feedback-tool</id>
    <content type="html"><![CDATA[<p>A unit test suite provides immediate feedback when you make a change. A passing test suite gives the confidence on the changes made. It&rsquo;s the confidence that the team has on the tests suite that matters more than the <a href="http://www.rahulpnath.com/blog/is-code-coverage-a-lie/">code coverage number</a>. Tests also provide feedback about the code. It suggests how easy or difficult it is to use the code just written since tests are the first consumers of the code. Different kinds of <a href="http://xunitpatterns.com/Test%20Smells.html">Test Smells</a> indicates a problem with the code that is getting tested or the test code itself and provides feedback to improve it.</p>

<p><img alt = "Test Feedback" src="/images/test_feedback.png" class = "center" /></p>

<p>Let&rsquo;s take a look at a couple of Test Smells and see what changes can be made to improve the code.</p>

<h3>Multiple Asserts on Class Properties</h3>

<p>Tests should ideally follow the Single Responsibility Principle (SRP). It should test one thing and try to limit that to one <em>Assert</em> statement. Often I come across tests that assert multiple things. At times this could just be that we are testing all side-effects of the method that is getting tested. Such tests can be broken down into separate tests which test just one thing each. In certain other cases, the effects of the method that is getting tested itself are spread across multiple properties. Let&rsquo;s see a simple example of one such case. Below is a DateRange class which takes in a StartDate and EndDate and creates a DateRange class if the endDate is greater than startDate.</p>

<pre><code class="csharp">public class DateRange
{
    public readonly DateTime StartDate;

    public readonly DateTime EndDate;

    public DateRange(DateTime startDate, DateTime endDate)
    {
        if (endDate &lt; startDate)
            throw new ArgumentException("End date cannot be less than start Date");

        StartDate = startDate;
        EndDate = endDate;
    }

    public static DateRange MonthsFromDate(DateTime date, int numOfMonths)
    {
        return new DateRange(date   , DateTime.Today.AddMonths(numOfMonths));
    }

    public bool IsInRange(DateTime theDateTime)
    {
        return theDateTime &gt;= StartDate &amp;&amp; theDateTime &lt;= EndDate;
    }
}
</code></pre>

<p>Let&rsquo;s take a look at one of the tests that check for the successful creation of a DateRange object using the MonthsFromDate function. In the tests below you can see that there are two statements to assert that the DateRange object is created successfully. In this particular case, the assertions are limited to two, but could often be more than that.</p>

<pre><code class="csharp">[Theory]
[InlineData("01-Jan-2017", 2, "01-Mar-2017")]
[InlineData("01-Jan-2017", 0, "01-Jan-2017")]
[InlineData("01-Jan-2017", 27, "01-Apr-2019")]
public void MonthsFromDateReturnsExpected(
    string startDateString,
    int monthsFromNow,
    string endDateString)
{
    var startDate = DateTime.Parse(startDateString);
    var endDate = DateTime.Parse(endDateString);

    var actual = DateRange.MonthsFromDate(startDate, monthsFromNow);

    Assert.Equal(startDate, actual.StartDate);
    Assert.Equal(endDate, actual.EndDate);
}
</code></pre>

<p>I can think if two ways to solve the above problem. One is to refactor the test code and the other to refactor the DateRange class itself. Both methods involve creating the expected DateRange object upfront and then comparing against it for equality. The tests can be refactored using <a href="https://www.nuget.org/packages/SemanticComparison">SemanticComparison</a> library.</p>

<pre><code class="csharp Refactor Test using SemanticComparison">[Theory]
[InlineData("01-Jan-2017", 2, "01-Mar-2017")]
[InlineData("01-Jan-2017", 0, "01-Jan-2017")]
[InlineData("01-Jan-2017", 27, "01-Apr-2019")]
public void MonthsFromDateReturnsExpectedUsingSemanticComparison(
   string startDateString,
   int monthsFromNow,
   string endDateString)
{
    var startDate = DateTime.Parse(startDateString);
    var endDate = DateTime.Parse(endDateString);
    var expected = new DateRange(startDate, endDate);

    var actual = DateRange.MonthsFromDate(startDate, monthsFromNow);

    expected
        .AsSource()
        .OfLikeness&lt;DateRange&gt;()
        .ShouldEqual(actual);
}
</code></pre>

<p>In this particular case looking closely at the <a href="http://xunitpatterns.com/SUT.html">system under test (SUT)</a>, the DateRange class, we understand that it can be a <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Value Object</a>. Any two instances of DateRange with the same start and end date can be considered equal. Equality is based on the value contained and not on any other identity. Though in all cases that you observe this behavior it might not be possible for you to convert it into a value object. In those case use the approach mentioned below. But in cases where you have control over it, override <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Equals and GetHashCode</a> to implement value equality. The test is much simpler and had less code</p>

<pre><code class="csharp Refactor DateRange to ValueObject">[Theory]
[InlineData("01-Jan-2017", 2, "01-Mar-2017")]
[InlineData("01-Jan-2017", 0, "01-Jan-2017")]
[InlineData("01-Jan-2017", 27, "01-Apr-2019")]
public void MonthsFromDateReturnsExpectedUsingValueObject(
   string startDateString,
   int monthsFromNow,
   string endDateString)
{
    var startDate = DateTime.Parse(startDateString);
    var endDate = DateTime.Parse(endDateString);
    var expected = new DateRange(startDate, endDate);

    var actual = DateRange.MonthsFromDate(startDate, monthsFromNow);

    Assert.Equal(expected, actual);
}
</code></pre>

<h3>Complicated Test Setup and Test Code Duplication</h3>

<p>At times we run into cases where setting up the sut is complicated and is a lot of code. Complicated setup often leads to <a href="http://xunitpatterns.com/Test%20Code%20Duplication.html">Test code duplication</a>.</p>

<blockquote><p><em>A complicated test setup warrants &lsquo;</em>cut-copy-paste<em>&rsquo; to test different aspects of the sut.</em></p></blockquote>

<p>From my experience, I have seen this happen more for the test setup phase. The test setup phase is identical across a set of tests with only the assertions being different. Let us look into some common reasons why test setup can becoming complicated leading to test code duplication as well.</p>

<h4><strong>Violating Single Responsibility Principle (SRP)</strong></h4>

<p>The test setup can get complicated when the sut violates Single Responsibility Principle (SRP). When there are too many things that are getting affected by the sut, the setup and the verification phases become complex. In these cases extracting the responsibilities as injected dependencies help reduce complexity. The tests can then use mocks to test the sut in isolation. The post, <a href="http://www.rahulpnath.com/blog/refactoring-to-improve-testability-extracting-dependencies/">Refactoring to Improve Testability: Extracting Dependencies</a> looks into an end to end scenario of this case and how it can be improved.</p>

<p>Violating SRP also leads to test code duplication as multiple aspects need testing and the setup looks almost similar. Refactoring the sut and the test code are ways that test code can be made more robust in these cases.</p>

<h4><strong>SUT Constraints</strong></h4>

<p>Test Code Duplication can occur when there are constraints on a constructor, and the test needs to construct it. Let&rsquo;s take the example of DateRange class we saw above. The DateRange constructor takes in two dates, startDate and endDate. But the constructor has a rule enforced that endDate must be greater than startDate. In such cases, I often see tests that have DateRange as a property directly or indirectly (as properties on other objects) creating them explicitly.</p>

<pre><code class="csharp Explicitly create objects with Constraints">[Theory]
[InlineData("1 Jan 2016", "1 Mar 2016", "20 Feb 2016")]
[InlineData("11 Apr 2016", "30 Mar 2017", "26 Dec 2016")]
public void DateInBetweenStartAndEndDateIsInRangeManualSetup(
    string startDateString,
    string endDateString,
    string dateInBetween)
{
    var startDate = DateTime.Parse(startDateString);
    var endDate = DateTime.Parse(endDateString);
    var date = DateTime.Parse(dateInBetween);
    var sut = new DateRange(startDate, endDate);

    var actual = sut.IsInRange(date);

    Assert.True(actual);
}
</code></pre>

<p>We cannot depend on the default behavior of AutoFixture to generate a DateRange object for us, as it does not know about this constraint and will always pass two random dates to the constructor. The below test is not repeatable and can fail at times if AutoFixture sends the endDate less than the start date.</p>

<pre><code class="csharp Using AutoFixture on classes that have constraints can lead to tests that are not repeatable">[Theory]
[InlineAutoData]
public void DateInBetweenStartAndEndDateIsInRange(DateRange sut)
{
    var rand = new Random();
    var date = sut.StartDate.AddDays(rand.Next(0, (sut.EndDate - sut.StartDate).Days - 1));
    var actual = sut.IsInRange(date);

    Assert.True(actual);
}
</code></pre>

<p>To make the test repeatable, we must be able to generate a DateRange class successfully every time we ask AutoFixture for one. For this, we add a DateRange <a href="https://github.com/AutoFixture/AutoFixture/wiki/Internal-Architecture">customization and plug it into the Fixture creation pipeline</a>. The customization makes sure that the DateRange class constructor parameters match the constraints.</p>

<pre><code class="csharp DateRange AutoFixture Customization">public class InlineCustomizedAutoDataAttribute : AutoDataAttribute
{
    public InlineCustomizedAutoDataAttribute()
        : base(new Fixture().Customize(new DateRangeCustomization()))
    {
    }
}

public class DateRangeCustomization : ICustomization
{
    public void Customize(IFixture fixture)
    {
        fixture.Customizations.Add(new DateRangeSpecimenBuilder());
    }
}
public class DateRangeSpecimenBuilder : ISpecimenBuilder
{
    public object Create(object request, ISpecimenContext context)
    {
        var requestAsType = request as Type;
        if (typeof(DateRange).Equals(requestAsType))
        {
            var startTime = context.Create&lt;DateTime&gt;();
            var range = context.Create&lt;uint&gt;();
            return new DateRange(startTime, startTime.AddDays(range));
        }

        return new NoSpecimen();
    }
}
</code></pre>

<p>The tests can now be updated to use the <em>InlineCustomizedAutoDataAttribute</em> instead of the default <em>InlineAutoDataAttribute</em>. The tests are repeatable now as we can be sure that AutoFixture will always generate a valid DateRange object.</p>

<h3>Public vs. Private for Tests</h3>

<p>It often happens that we get into discussions on whether a function should be private or public. We think it is a bad idea to write production code in a way to suit tests. To test private methods, you can employ techniques of reflection or use <a href="https://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.internalsvisibletoattribute">InternalsVisibleTo attribute</a>. But this is a smell in itself.</p>

<p>Tests should be through public API of the class. If it gets difficult to test through the API, it hints that the code is dealing with different responsibilities or has too many dependencies.</p>

<blockquote><p><em>There are valid use cases for the private and internal access modifiers, but the majority of the time I see private and internal code, it merely smells of poor design. If you change the design, you could make types and members public, and feel good about it.</em></p>

<p>-<a href="http://blog.ploeh.dk/2015/09/22/unit-testing-internals/"><em>Unit Testing Internals, Mark Seemann</em></a></p></blockquote>

<p>Consider refactoring your code so that it is easier to test. Tests are the first consumers of code, and it helps shape the public API and the way it gets consumed. It is fine to have tests affect the way you write code. What is not fine is to have explicit loops within the production code, just for test code. The problem with having such code is that the other code loop never gets tested.</p>

<p>Tests act as a feedback tool and it is important that you listen to it. If you decide to bear the pain of writing tests ignoring the feedback just to meet some <a href="http://www.rahulpnath.com/blog/is-code-coverage-a-lie/">code coverage numbers</a> then you are doing it wrong. Most of the cases you will end up with hard to maintain code and fragile tests. Listen to the feedback and incorporate it into the code you write.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tip of the Week: AutoFixture - Make Your Unit Tests Robust]]></title>
    <link href="http://rahulpnath.com/blog/autofixture-make-your-unit-tests-robust/"/>
    <updated>2017-04-06T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/autofixture-make-your-unit-tests-robust</id>
    <content type="html"><![CDATA[<blockquote><p><em><a href="https://github.com/AutoFixture/AutoFixture">AutoFixture</a> is an open source library for .NET designed to minimize the &lsquo;<a href="http://wiki.c2.com/?ArrangeActAssert">Arrange</a>&rsquo; phase of your unit tests in order to maximize maintainability. Its primary goal is to allow developers to focus on what is being tested rather than how to setup the test scenario, by making it easier to create object graphs containing test data.</em></p></blockquote>

<p><img alt ="AutoFixture" class = "center" src="/images/autofixture.jpg" /></p>

<p>If you are on .NET platform and write tests (there is no reason you wouldn&rsquo;t) you should check out AutoFixture. AutoFixture makes test data setup easy. It is a generalization of the <a href="http://www.natpryce.com/articles/000714.html">Test Data Builder</a> pattern and helps make your tests more robust and maintainable. Below is a sample (as taken from the GitHub page) shows how minimal setup is required for testing. Check out the post, <a href="http://www.rahulpnath.com/blog/refactoring-test-code-removing-constructor-dependency/">Refactoring Test Code: Removing Constructor Dependency</a> to see in detail how AutoFixture can be used to make the tests more stable against changes.</p>

<pre><code class="csharp">[Theory, AutoData]
public void IntroductoryTest(
    int expectedNumber, MyClass sut)
{
    int result = sut.Echo(expectedNumber);
    Assert.Equal(expectedNumber, result);
}
</code></pre>

<p>If you are new to AutoFixture, I highly recommend checking out the <a href="https://github.com/AutoFixture/AutoFixture/wiki/Cheat-Sheet">Cheat Sheet</a> to get started. Check out my post on <a href="http://www.rahulpnath.com/blog/populating-data-for-tests/">Populating Data for Tests</a> for some common patterns of using AutoFixture and how it can reduce setup code. Understanding the <a href="https://github.com/AutoFixture/AutoFixture/wiki/Internal-Architecture">Internal Architecture</a> of AutoFixture helps if you want to extend it for customization. AutoFixture integrates well with the different testing frameworks and support libraries that are popular. I mostly use it with <a href="https://xunit.github.io/">xUnit</a> and <a href="https://github.com/Moq/moq4/wiki/Quickstart">Moq</a>.</p>

<p>Hope this helps with your testing!</p>

<p><em>I am happy to have <a href="https://github.com/AutoFixture/AutoFixture/pulls?q=is:pr+is:closed+author:rahulpnath">contributed</a> (minor) to such a great library.</em></p>
]]></content>
  </entry>
  
</feed>
