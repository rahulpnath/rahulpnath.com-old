<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: testing | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/testing/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2018-05-30T00:01:27+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Semantic Comparison: Improve Test Assertions]]></title>
    <link href="http://rahulpnath.com/blog/semantic-comparison-improve-test-assertions/"/>
    <updated>2017-06-20T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/semantic-comparison-improve-test-assertions</id>
    <content type="html"><![CDATA[<p>One of the traits of a good unit test is to have just <a href="http://osherove.com/blog/2005/4/14/try-to-avoid-multiple-asserts-in-a-single-unit-test.html">one Assert statement.</a>.</p>

<blockquote><p><em>Consider Assert failures as symptoms of a disease and Asserts as indication points or blood checks for the body of the software. The more symptoms you can find, the easier the disease will be to figure out and remove. If you have multiple asserts in one test - only the first failing one reveals itself as failed and you lose sight of other possible symptoms.</em></p>

<p>-<a href="http://osherove.com/">Roy Osherove</a></p></blockquote>

<p>When a test with multiple asserts fails, it is hard to tell the exact reason of test failure. To get more details on the actual failure we either have to debug the tests or look into the stack trace.</p>

<h3>Tests With Multiple Assertions</h3>

<p>Many times we end up needing to assert on more than one properties or behavior. Let&rsquo;s look at a few such examples and see how we can refactor the tests. <em>I have excluded the actual code that is getting is tested here as it is easy to understand what that will look like from the tests. (Drop a comment otherwise)</em></p>

<p><strong>Example 1:</strong> In the below test we have a <em>Name</em> class that represents FirstName and LastName of a user. It exposes a <em>Parse</em> method to make it easy for us to create a Name object from a string. Below are some tests for the Parse method. The test has multiple assertions to confirm that the first and last name properties get set as expected.</p>

<pre><code class="csharp Name class">[Theory]
[InlineData("Rahul", "Rahul", "")]
[InlineData("Rahul Nath", "Rahul", "Nath")]
[InlineData("Rahul P Nath", "Rahul", "P Nath")]
public void FirstNameOnlyProvidedResultsInFirstNameSet(
   string name,
   string expFirstName,
   string expLastName)
{
    var actual = Name.Parse(name);

    Assert.Equal(expFirstName, actual.FirstName);
    Assert.Equal(expLastName, actual.LastName);
}
</code></pre>

<p><strong>Example 2:</strong> The below test is for the <em>Controller</em> class to confirm that the <em>CustomerViewModel</em> passed to the <em>Post</em> method on the controller saves the <em>Customer</em> to the repository. The assert statement includes multiple properties of the customer object, which is just a shorthand version of writing multiple such assert statements on each of those properties.</p>

<pre><code class="csharp Controller Unit Test">[Theory, AutoWebData]
public void PostSavesToRepository(
    CustomerViewModel model,
    [Frozen]Mock&lt;ICustomerRepository&gt; customerRepository,
    CustomerController sut)
{
  var expected = model.ToCustomer();

  sut.Post(model);

  customerRepository.Verify(a =&gt;
    a.Upsert(It.IsAny&lt;Customer&gt;(customer =&gt; 
        customer.Name == expected.Name &amp;&amp;
        customer.Age == expected.Age &amp;&amp;
        customer.Phone == customer.Phone))
}
</code></pre>

<p><strong>Example 3:</strong> The below test ensures that all properties are set when transforming from DTO to domain entity (or any such object transformations at system boundaries). The test asserts on every property of the class.</p>

<pre><code class="csharp Comparing different object types">[Theory]
[AutoMoqData]
public void AllowanceToDomainModelMapsAllProperties(
    Persistence.Allowance allowance, 
    int random)
{
    allowance.EndDate = allowance.StartDate.AddDays(random);

    var actual = allowance.ToDomainModel();

    Assert.Equal(allowance.ClientId, actual.ClientId);
    Assert.Equal(allowance.Credit, actual.Credit);
    Assert.Equal(allowance.Data, actual.Data);
    Assert.Equal(allowance.StartDate, actual.Period.StartDate);
    Assert.Equal(allowance.EndDate, actual.Period.EndDate);
}
</code></pre>

<h3>Semantic Comparison Library</h3>

<p><a href="https://www.nuget.org/packages/SemanticComparison/">Semantic Comparison</a> is a library that allows deep comparison of similar looking objects. Originally part of <a href="http://www.rahulpnath.com/blog/autofixture-make-your-unit-tests-robust/">AutoFixture</a> library, it is also available as a separate <a href="https://www.nuget.org/packages/SemanticComparison/">Nuget package</a>.</p>

<blockquote><p><em>SemanticComparison makes it easier to compare instances of various objects to each other. Instead of performing a normal equality comparison, SemanticComparison compares objects that look semantically similar - even if they are of different types</em></p></blockquote>

<p>Using SemanticComparison, we can compare two objects and compare their properties for equality. It allows including/excluding properties when comparing objects.</p>

<h3>Refactoring Tests</h3>

<p><strong>Example 1:</strong> The <em>Name</em> is a perfect case for being a <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Value Object</a>. In this case, the class will override Equals, and it will be easier for us to write the tests. Converting to a Value Object is one of the cases where we <a href="http://www.rahulpnath.com/blog/tests-as-a-feedback-tool/">use tests as a feedback to improve code</a>. But in cases where you do not have the control over the class or do not want to make it a value object, we can use SemanticComparison to help check for equality as shown below.</p>

<pre><code class="csharp Name Class">[Theory]
[InlineData("Rahul", "Rahul", "")]
[InlineData("Rahul Nath", "Rahul", "Nath")]
[InlineData("Rahul P Nath", "Rahul", "P Nath")]
public void FirstNameOnlyProvidedResultsInFirstNameSet(
   string name,
   string expFirstName,
   string expLastName)
{
    var expected = new Name(expFirstName, expLastName);

    var actual = Name.Parse(name);

    expected
        .AsSource()
        .OfLikeness&lt;Name&gt;()
        .ShouldEqual(actual);
}
</code></pre>

<p><strong>Example 2:</strong>  Using SemanticComparison we can remove the need of asserting on each of the properties. In the below case since the Customer Id is set to a new Guid in the ToCustomer method, I ignore the Id property from the comparison using <em>Without</em>. When the <em>expected</em> objects gets compared against the <em>actual</em> all properties except <em>Id</em> will be compared for equality. Any number of properties can be excluded by chaining multiple <em>Without</em> methods.</p>

<pre><code class="csharp Controller Unit Test">[Theory, AutoWebData]
public void PostSavesToRepository(
    CustomerViewModel model,
    [Frozen]Mock&lt;ICustomerRepository&gt; customerRepository,
    CustomerController sut)
{
  var customer = model.ToCustomer();
  var expected = customer
      .AsSource()
      .OfLikeness&lt;Customer&gt;()
      .Without(a =&gt; a.Id);

  sut.Post(model);

  customerRepository.Verify(a =&gt;
    a.Upsert(It.IsAny&lt;Customer&gt;(actual =&gt; 
        expected.ShoudEqual(actual)));
}
</code></pre>

<p><strong>Example 3:</strong>  Using SemanticComparison we can remove the asserts on every property and also set custom comparisons. The StartDate and EndDate on the persistence entity are converted into a DateRange object (Period). By using the <em>With</em> method in combination with the <em>EqualsWhen</em> method we can set custom comparison behavior that needs to be performed when comparing objects. The same test will hold true even if we add new properties and will force mapping to be updated if any of the property mappings is missed. Here we also see how SemanticComparison can compare two different types.</p>

<pre><code class="csharp Comparing different object types">[Theory]
[AutoMoqData]
public void AllowanceToDomainModelMapsAllProperties(
    Persistence.Allowance allowance, 
    int random)
{
    allowance.EndDate = allowance.StartDate.AddDays(random);

    var actual = allowance.ToDomainModel();

    allowance
        .AsSource()
        .OfLikeness&lt;Allowance&gt;()
        .With(a =&gt; a.Period)
        .EqualsWhen((p, m) =&gt; { return m.Period.StartDate == p.StartDate &amp;&amp; m.Period.EndDate == p.EndDate; })
        .ShouldEqual(actual);
}
</code></pre>

<p>Using SemanticComparison library, we reduce the dependencies on the actual implementation and extract that into a more generic representation. Fewer dependencies on the actual implementation code/properties make the tests more robust and adaptable to change. Hope this helps you get started with Semantic Comparison and improve on your test assertions.</p>

<p><strong>References:</strong></p>

<ul>
<li><a href="http://blog.ploeh.dk/2012/06/21/TheResemblanceidiom/">The Resemblance Idiom</a></li>
<li><a href="http://blog.ploeh.dk/2010/06/29/IntroducingAutoFixtureLikeness/">Introducing AutoFixture Likeness</a></li>
<li><a href="http://blog.ploeh.dk/2012/06/22/ResemblanceandLikeness/">Resemblance and Likeness</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use Tests As A Feedback Tool To Improve Code]]></title>
    <link href="http://rahulpnath.com/blog/tests-as-a-feedback-tool/"/>
    <updated>2017-06-01T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/tests-as-a-feedback-tool</id>
    <content type="html"><![CDATA[<p>A unit test suite provides immediate feedback when you make a change. A passing test suite gives the confidence on the changes made. It&rsquo;s the confidence that the team has on the tests suite that matters more than the <a href="http://www.rahulpnath.com/blog/is-code-coverage-a-lie/">code coverage number</a>. Tests also provide feedback about the code. It suggests how easy or difficult it is to use the code just written since tests are the first consumers of the code. Different kinds of <a href="http://xunitpatterns.com/Test%20Smells.html">Test Smells</a> indicates a problem with the code that is getting tested or the test code itself and provides feedback to improve it.</p>

<p><img alt = "Test Feedback" src="/images/test_feedback.png" class = "center" /></p>

<p>Let&rsquo;s take a look at a couple of Test Smells and see what changes can be made to improve the code.</p>

<h3>Multiple Asserts on Class Properties</h3>

<p>Tests should ideally follow the Single Responsibility Principle (SRP). It should test one thing and try to limit that to one <em>Assert</em> statement. Often I come across tests that assert multiple things. At times this could just be that we are testing all side-effects of the method that is getting tested. Such tests can be broken down into separate tests which test just one thing each. In certain other cases, the effects of the method that is getting tested itself are spread across multiple properties. Let&rsquo;s see a simple example of one such case. Below is a DateRange class which takes in a StartDate and EndDate and creates a DateRange class if the endDate is greater than startDate.</p>

<pre><code class="csharp">public class DateRange
{
    public readonly DateTime StartDate;

    public readonly DateTime EndDate;

    public DateRange(DateTime startDate, DateTime endDate)
    {
        if (endDate &lt; startDate)
            throw new ArgumentException("End date cannot be less than start Date");

        StartDate = startDate;
        EndDate = endDate;
    }

    public static DateRange MonthsFromDate(DateTime date, int numOfMonths)
    {
        return new DateRange(date   , DateTime.Today.AddMonths(numOfMonths));
    }

    public bool IsInRange(DateTime theDateTime)
    {
        return theDateTime &gt;= StartDate &amp;&amp; theDateTime &lt;= EndDate;
    }
}
</code></pre>

<p>Let&rsquo;s take a look at one of the tests that check for the successful creation of a DateRange object using the MonthsFromDate function. In the tests below you can see that there are two statements to assert that the DateRange object is created successfully. In this particular case, the assertions are limited to two, but could often be more than that.</p>

<pre><code class="csharp">[Theory]
[InlineData("01-Jan-2017", 2, "01-Mar-2017")]
[InlineData("01-Jan-2017", 0, "01-Jan-2017")]
[InlineData("01-Jan-2017", 27, "01-Apr-2019")]
public void MonthsFromDateReturnsExpected(
    string startDateString,
    int monthsFromNow,
    string endDateString)
{
    var startDate = DateTime.Parse(startDateString);
    var endDate = DateTime.Parse(endDateString);

    var actual = DateRange.MonthsFromDate(startDate, monthsFromNow);

    Assert.Equal(startDate, actual.StartDate);
    Assert.Equal(endDate, actual.EndDate);
}
</code></pre>

<p>I can think if two ways to solve the above problem. One is to refactor the test code and the other to refactor the DateRange class itself. Both methods involve creating the expected DateRange object upfront and then comparing against it for equality. The tests can be refactored using <a href="https://www.nuget.org/packages/SemanticComparison">SemanticComparison</a> library.</p>

<pre><code class="csharp Refactor Test using SemanticComparison">[Theory]
[InlineData("01-Jan-2017", 2, "01-Mar-2017")]
[InlineData("01-Jan-2017", 0, "01-Jan-2017")]
[InlineData("01-Jan-2017", 27, "01-Apr-2019")]
public void MonthsFromDateReturnsExpectedUsingSemanticComparison(
   string startDateString,
   int monthsFromNow,
   string endDateString)
{
    var startDate = DateTime.Parse(startDateString);
    var endDate = DateTime.Parse(endDateString);
    var expected = new DateRange(startDate, endDate);

    var actual = DateRange.MonthsFromDate(startDate, monthsFromNow);

    expected
        .AsSource()
        .OfLikeness&lt;DateRange&gt;()
        .ShouldEqual(actual);
}
</code></pre>

<p>In this particular case looking closely at the <a href="http://xunitpatterns.com/SUT.html">system under test (SUT)</a>, the DateRange class, we understand that it can be a <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Value Object</a>. Any two instances of DateRange with the same start and end date can be considered equal. Equality is based on the value contained and not on any other identity. Though in all cases that you observe this behavior it might not be possible for you to convert it into a value object. In those case use the approach mentioned below. But in cases where you have control over it, override <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Equals and GetHashCode</a> to implement value equality. The test is much simpler and had less code</p>

<pre><code class="csharp Refactor DateRange to ValueObject">[Theory]
[InlineData("01-Jan-2017", 2, "01-Mar-2017")]
[InlineData("01-Jan-2017", 0, "01-Jan-2017")]
[InlineData("01-Jan-2017", 27, "01-Apr-2019")]
public void MonthsFromDateReturnsExpectedUsingValueObject(
   string startDateString,
   int monthsFromNow,
   string endDateString)
{
    var startDate = DateTime.Parse(startDateString);
    var endDate = DateTime.Parse(endDateString);
    var expected = new DateRange(startDate, endDate);

    var actual = DateRange.MonthsFromDate(startDate, monthsFromNow);

    Assert.Equal(expected, actual);
}
</code></pre>

<h3>Complicated Test Setup and Test Code Duplication</h3>

<p>At times we run into cases where setting up the sut is complicated and is a lot of code. Complicated setup often leads to <a href="http://xunitpatterns.com/Test%20Code%20Duplication.html">Test code duplication</a>.</p>

<blockquote><p><em>A complicated test setup warrants &lsquo;</em>cut-copy-paste<em>&rsquo; to test different aspects of the sut.</em></p></blockquote>

<p>From my experience, I have seen this happen more for the test setup phase. The test setup phase is identical across a set of tests with only the assertions being different. Let us look into some common reasons why test setup can becoming complicated leading to test code duplication as well.</p>

<h4><strong>Violating Single Responsibility Principle (SRP)</strong></h4>

<p>The test setup can get complicated when the sut violates Single Responsibility Principle (SRP). When there are too many things that are getting affected by the sut, the setup and the verification phases become complex. In these cases extracting the responsibilities as injected dependencies help reduce complexity. The tests can then use mocks to test the sut in isolation. The post, <a href="http://www.rahulpnath.com/blog/refactoring-to-improve-testability-extracting-dependencies/">Refactoring to Improve Testability: Extracting Dependencies</a> looks into an end to end scenario of this case and how it can be improved.</p>

<p>Violating SRP also leads to test code duplication as multiple aspects need testing and the setup looks almost similar. Refactoring the sut and the test code are ways that test code can be made more robust in these cases.</p>

<h4><strong>SUT Constraints</strong></h4>

<p>Test Code Duplication can occur when there are constraints on a constructor, and the test needs to construct it. Let&rsquo;s take the example of DateRange class we saw above. The DateRange constructor takes in two dates, startDate and endDate. But the constructor has a rule enforced that endDate must be greater than startDate. In such cases, I often see tests that have DateRange as a property directly or indirectly (as properties on other objects) creating them explicitly.</p>

<pre><code class="csharp Explicitly create objects with Constraints">[Theory]
[InlineData("1 Jan 2016", "1 Mar 2016", "20 Feb 2016")]
[InlineData("11 Apr 2016", "30 Mar 2017", "26 Dec 2016")]
public void DateInBetweenStartAndEndDateIsInRangeManualSetup(
    string startDateString,
    string endDateString,
    string dateInBetween)
{
    var startDate = DateTime.Parse(startDateString);
    var endDate = DateTime.Parse(endDateString);
    var date = DateTime.Parse(dateInBetween);
    var sut = new DateRange(startDate, endDate);

    var actual = sut.IsInRange(date);

    Assert.True(actual);
}
</code></pre>

<p>We cannot depend on the default behavior of AutoFixture to generate a DateRange object for us, as it does not know about this constraint and will always pass two random dates to the constructor. The below test is not repeatable and can fail at times if AutoFixture sends the endDate less than the start date.</p>

<pre><code class="csharp Using AutoFixture on classes that have constraints can lead to tests that are not repeatable">[Theory]
[InlineAutoData]
public void DateInBetweenStartAndEndDateIsInRange(DateRange sut)
{
    var rand = new Random();
    var date = sut.StartDate.AddDays(rand.Next(0, (sut.EndDate - sut.StartDate).Days - 1));
    var actual = sut.IsInRange(date);

    Assert.True(actual);
}
</code></pre>

<p>To make the test repeatable, we must be able to generate a DateRange class successfully every time we ask AutoFixture for one. For this, we add a DateRange <a href="https://github.com/AutoFixture/AutoFixture/wiki/Internal-Architecture">customization and plug it into the Fixture creation pipeline</a>. The customization makes sure that the DateRange class constructor parameters match the constraints.</p>

<pre><code class="csharp DateRange AutoFixture Customization">public class InlineCustomizedAutoDataAttribute : AutoDataAttribute
{
    public InlineCustomizedAutoDataAttribute()
        : base(new Fixture().Customize(new DateRangeCustomization()))
    {
    }
}

public class DateRangeCustomization : ICustomization
{
    public void Customize(IFixture fixture)
    {
        fixture.Customizations.Add(new DateRangeSpecimenBuilder());
    }
}
public class DateRangeSpecimenBuilder : ISpecimenBuilder
{
    public object Create(object request, ISpecimenContext context)
    {
        var requestAsType = request as Type;
        if (typeof(DateRange).Equals(requestAsType))
        {
            var startTime = context.Create&lt;DateTime&gt;();
            var range = context.Create&lt;uint&gt;();
            return new DateRange(startTime, startTime.AddDays(range));
        }

        return new NoSpecimen();
    }
}
</code></pre>

<p>The tests can now be updated to use the <em>InlineCustomizedAutoDataAttribute</em> instead of the default <em>InlineAutoDataAttribute</em>. The tests are repeatable now as we can be sure that AutoFixture will always generate a valid DateRange object.</p>

<h3>Public vs. Private for Tests</h3>

<p>It often happens that we get into discussions on whether a function should be private or public. We think it is a bad idea to write production code in a way to suit tests. To test private methods, you can employ techniques of reflection or use <a href="https://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.internalsvisibletoattribute">InternalsVisibleTo attribute</a>. But this is a smell in itself.</p>

<p>Tests should be through public API of the class. If it gets difficult to test through the API, it hints that the code is dealing with different responsibilities or has too many dependencies.</p>

<blockquote><p><em>There are valid use cases for the private and internal access modifiers, but the majority of the time I see private and internal code, it merely smells of poor design. If you change the design, you could make types and members public, and feel good about it.</em></p>

<p>-<a href="http://blog.ploeh.dk/2015/09/22/unit-testing-internals/"><em>Unit Testing Internals, Mark Seemann</em></a></p></blockquote>

<p>Consider refactoring your code so that it is easier to test. Tests are the first consumers of code, and it helps shape the public API and the way it gets consumed. It is fine to have tests affect the way you write code. What is not fine is to have explicit loops within the production code, just for test code. The problem with having such code is that the other code loop never gets tested.</p>

<p>Tests act as a feedback tool and it is important that you listen to it. If you decide to bear the pain of writing tests ignoring the feedback just to meet some <a href="http://www.rahulpnath.com/blog/is-code-coverage-a-lie/">code coverage numbers</a> then you are doing it wrong. Most of the cases you will end up with hard to maintain code and fragile tests. Listen to the feedback and incorporate it into the code you write.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tip of the Week: AutoFixture - Make Your Unit Tests Robust]]></title>
    <link href="http://rahulpnath.com/blog/autofixture-make-your-unit-tests-robust/"/>
    <updated>2017-04-06T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/autofixture-make-your-unit-tests-robust</id>
    <content type="html"><![CDATA[<blockquote><p><em><a href="https://github.com/AutoFixture/AutoFixture">AutoFixture</a> is an open source library for .NET designed to minimize the &lsquo;<a href="http://wiki.c2.com/?ArrangeActAssert">Arrange</a>&rsquo; phase of your unit tests in order to maximize maintainability. Its primary goal is to allow developers to focus on what is being tested rather than how to setup the test scenario, by making it easier to create object graphs containing test data.</em></p></blockquote>

<p><img alt ="AutoFixture" class = "center" src="/images/autofixture.jpg" /></p>

<p>If you are on .NET platform and write tests (there is no reason you wouldn&rsquo;t) you should check out AutoFixture. AutoFixture makes test data setup easy. It is a generalization of the <a href="http://www.natpryce.com/articles/000714.html">Test Data Builder</a> pattern and helps make your tests more robust and maintainable. Below is a sample (as taken from the GitHub page) shows how minimal setup is required for testing. Check out the post, <a href="http://www.rahulpnath.com/blog/refactoring-test-code-removing-constructor-dependency/">Refactoring Test Code: Removing Constructor Dependency</a> to see in detail how AutoFixture can be used to make the tests more stable against changes.</p>

<pre><code class="csharp">[Theory, AutoData]
public void IntroductoryTest(
    int expectedNumber, MyClass sut)
{
    int result = sut.Echo(expectedNumber);
    Assert.Equal(expectedNumber, result);
}
</code></pre>

<p>If you are new to AutoFixture, I highly recommend checking out the <a href="https://github.com/AutoFixture/AutoFixture/wiki/Cheat-Sheet">Cheat Sheet</a> to get started. Check out my post on <a href="http://www.rahulpnath.com/blog/populating-data-for-tests/">Populating Data for Tests</a> for some common patterns of using AutoFixture and how it can reduce setup code. Understanding the <a href="https://github.com/AutoFixture/AutoFixture/wiki/Internal-Architecture">Internal Architecture</a> of AutoFixture helps if you want to extend it for customization. AutoFixture integrates well with the different testing frameworks and support libraries that are popular. I mostly use it with <a href="https://xunit.github.io/">xUnit</a> and <a href="https://github.com/Moq/moq4/wiki/Quickstart">Moq</a>.</p>

<p>Hope this helps with your testing!</p>

<p><em>I am happy to have <a href="https://github.com/AutoFixture/AutoFixture/pulls?q=is:pr+is:closed+author:rahulpnath">contributed</a> (minor) to such a great library.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Populating Data for Tests]]></title>
    <link href="http://rahulpnath.com/blog/populating-data-for-tests/"/>
    <updated>2017-03-07T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/populating-data-for-tests</id>
    <content type="html"><![CDATA[<p>Populating data for tests is the section of the test that usually ends up making tests more coupled with the code that it is testing. Coupling makes tests more fragile and refactoring code harder because of breaking tests. We should try to avoid coupling with the implementation details when writing tests. Let us see a few options that we have to populate test data and constructing object graphs (chain of objects branched off from the root object). I use <a href="https://xunit.github.io/">xUnit.net</a> as my test framework, but you can use these techniques in your choice of framework.</p>

<p><a href="http://xunitpatterns.com/Data-Driven%20Test.html" class="center" title="Image from xUnit Test Patterns"><img class="center" alt="Populating Test Data" src="/images\test_data.gif" /></a></p>

<p>Let&rsquo;s start with some simple tests on a Customer class shown below.</p>

<pre><code class="csharp">public class Customer
{
    public Guid Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string FullName
    {
        get { return FirstName + " " + LastName; }
    }

    public Address Address { get; set; }
}
</code></pre>

<p>Let&rsquo;s say we need to test that the FullName property returns as expected. We will use a <em>Theory</em> type tests for testing different combinations of first and last name. xUnit.net includes support for two different major types of unit tests: facts and theories</p>

<blockquote><p><em>Facts are tests which are always true. They test invariant conditions.</em></p>

<p><em>Theories are tests which are only true for a particular set of data.</em></p></blockquote>

<p>Theories allow us to create parameterized tests with which we can run a given test with different parameter options. Like in this example we need to test the Customer class with different set of First and Last Name combinations. As you can see below the test is attributed with Theory Attribute, and we use the InlineData attribute to pass static values to the test. Using these parameters we are now able to test for different combinations of first and last names. The test populates only the required properties on Customer object for testing FullName.</p>

<pre><code class="csharp">[Theory]
[InlineData("Adobe", "Photoshop", "Adobe Photoshop")]
[InlineData("Visual", "Studio", "Visual Studio")]
[InlineData("Rode", "Podcaster", "Rode Podcaster")]
public void CustomerFullNameReturnsExpected(string firstName, string lastName, string expected)
{
    // Fixture setup
    var customer = new Customer() { FirstName = firstName, LastName = lastName };
    // Exercise system
    var actual = customer.FullName;
    // Verify outcome
    Assert.Equal(expected, actual);
    // Teardown
}
</code></pre>

<blockquote><p><em>Tests help refine the public API as they are the first consumers</em></p></blockquote>

<p>The tests above acts as a clue indicating that the three properties - FirstName, LastName, FullName are related and go hand-in-hand. These tests are a strong indication that these properties can be grouped together into a class and possibly tested separately. We can extract these properties into a <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Value Object</a> for e.g. Name. I will not go into the implementation details of that, and I hope you can do that you own.</p>

<p>The above tests still have a high dependency on the code that it is testing - <strong><em>the constructor</em></strong>. Imagine if we had a lot of such tests that constructs the Consumer class inline in the setup phase. All tests will break if the class constructor changes. We saw in the <a href="http://www.rahulpnath.com/blog/refactoring-test-code-removing-constructor-dependency/">refactoring to remove constructor dependency</a> how to remove such dependencies and make the tests independent of the constructor dependencies.  We can introduce Object Mother or Test Data Builder pattern as mentioned in the article. Optimizing further we can also use <a href="https://github.com/AutoFixture/AutoFixture">AutoFixture</a> to generate test data. Moving into these patterns or AutoFixture brings in an added benefit as well; the rest of properties on the Customer class also gets populated by default.</p>

<h3>Explicitly Setting Properties</h3>

<p>By introducing AutoFixture, we no longer need to create the Customer object explicitly. We can use the Fixture class generate a Customer class for us. Using AutoFixture, this can be achieved in at least two ways (I am not sure if there are more ways of doing this).</p>

<pre><code class="csharp Using Fixture class">[Theory]
[InlineData("Adobe", "Photoshop", "Adobe Photoshop")]
[InlineData("Visual", "Studio", "Visual Studio")]
[InlineData("Rode", "Podcaster", "Rode Podcaster")]
public void CustomerFullNameReturnsExpected(string firstName, string lastName, string expected)
{
    // Fixture setup
    var fixture = new Fixture();
    var customer = fixture.Build&lt;Customer&gt;()
        .With(a =&gt; a.FirstName, firstName)
        .With(a =&gt; a.LastName, lastName)
        .Create();
    // Exercise system
    var actual = customer.FullName;
    // Verify outcome
    Assert.Equal(expected, actual);
    // Teardown
}
</code></pre>

<pre><code class="csharp Using Injected Object">[Theory]
[InlineAutoData("Adobe", "Photoshop", "Adobe Photoshop")]
[InlineAutoData("Visual", "Studio", "Visual Studio")]
[InlineAutoData("Rode", "Podcaster", "Rode Podcaster")]
public void CustomerFullNameReturnsExpected(string firstName, string lastName, string expected, Customer customer)
{
    // Fixture setup
    customer.FirstName = firstName;
    customer.LastName = lastName;
    // Exercise system
    var actual = customer.FullName;
    // Verify outcome
    Assert.Equal(expected, actual);
    // Teardown
}
</code></pre>

<p>In both cases, we explicitly set the required properties. The above test is similar to the previous test that we wrote without AutoFixture. But no longer are we dependent on the constructor. In the second way of using AutoFixture I used <em>InlineAutoData</em> attribute, that is part of <em>Ploeh.AutoFixture.Xunit2</em>. This attribute automatically does the fixture initialization and injects the Customer object for us. For all the values that it can match from the inline parameter list, it uses the provided values. It starts generating random values once all the parameters passed inline are used. In this case, only Customer object is created by AutoFixture.</p>

<h3>AutoFixture and Immutable types</h3>

<p>When using immutable types or properties with private setters, we cannot set the property value after it is created.</p>

<blockquote><p><em>AutoFixture was originally build as a tool for Test-Driven Development (TDD), and TDD is all about feedback. In the spirit of GOOS, you should listen to your tests. If the tests are hard to write, you should consider your API design. AutoFixture tends to amplify that sort of feedback.</em></p>

<p>-<em><a href="http://stackoverflow.com/a/20816487/1948745">Mark Seemann</a> (creator of AutoFixture)</em></p></blockquote>

<p>In these cases, the suggested approach is something closer to the manual <a href="http://www.natpryce.com/articles/000714.html">Test Data Builder</a> we saw in the <a href="http://www.rahulpnath.com/blog/refactoring-test-code-removing-constructor-dependency/">refactoring example</a>. We can either have an explicit test data builder class or define extension methods on the immutable type such that it changes just the specified property and returns all other values same, as shown below.</p>

<pre><code class="csharp">public class Name
{
    public readonly string FirstName;
    public readonly string LastName;
    public string FullName
    {
        get
        {
            return FirstName + " " + LastName;
        }
    }

    public Name(string firstName, string lastName)
    {
        // Enforce parameter constraints
        FirstName = firstName;
        LastName = lastName;
    }

    public Name WithFirstName(string firstName)
    {
        return new Name(firstName, this.LastName);
    }
}
</code></pre>

<p>As shown the <em>WithFirstName</em> method returns a new Name class with just the first name changed. Again we do not need these <em>WithXXX</em> methods for all the properties. Only when there is a need to change any of the property values as part of the requirement do we need to introduce such methods and even test it. This again drives to the above point of using tests to guide the API design, from the feedback.</p>

<h3>Customization</h3>

<p>In cases where we have validations in constructor to hold the class constraints, we cannot rely on the random values generated by AutoFixture. For example.
- The string should be at least ten characters in length for a Name class
- Start date should be less than the End date for a date range class</p>

<p>Without any custom code if we are to rely on AutoFixture to generate us, such classes, the tests will not be predictable. Depending on the random value that AutoFixture generates it might create a valid instance or throw an exception. To make this consistent, we can add Customization to ensure predictability.</p>

<p>For the DateRange class below we can add the following Customization.</p>

<pre><code class="csharp">public class DateRange
{
    public readonly DateTime EndDate;
    public readonly DateTime StartDate;

    public DateRange(DateTime startDate, DateTime endDate)
    {
        if (endDate &lt; startDate)
            throw new Exception("End date cannot be less than the start date");

        StartDate = startDate;
        EndDate = endDate;
    }
}
</code></pre>

<pre><code class="csharp DateRange Customization">public class DateRangeCustomization : ICustomization
{
    public void Customize(IFixture fixture)
    {
        fixture.Customizations.Add(new DateRangeSpecimenBuilder());
    }
}

public class DateRangeSpecimenBuilder : ISpecimenBuilder
{
    public object Create(object request, ISpecimenContext context)
    {
        var requestAsType = request as Type;
        if (typeof(DateRange).Equals(requestAsType))
        {
            var times = context.CreateMany&lt;DateTime&gt;();
            return new DateRange(times.Min(), times.Max());
        }

        return new NoSpecimen();
    }
}
</code></pre>

<p>The customization gets invoked every time a DateRange object is requested using the fixture. It then invokes this custom code that we have added in and creates a valid DateRange object. For the tests use the customization as part of the fixture either using a custom data attribute or explicitly adding the customization into the Fixture class.</p>

<h3>Mocking behavior</h3>

<p><a href="http://xunitpatterns.com/Mock%20Object.html">Mock Objects</a> is a popular way to unit test classes in isolation. For the external dependencies that a <a href="http://xunitpatterns.com/SUT.html">System Under Test</a> (SUT) has, the dependencies are mocked using a mocking framework. In these cases, we can setup the external dependencies to return different values as we expect for different tests and test the logic of the SUT and how it responds. Such tests are usually more coupled with the implementation as we have to setup the mocks prior. So we need to have an understanding of the return values expected from dependencies and the parameters expected by the dependencies. I use Moq framework for mocking, and AutoFixture has a library that helps integrate well with it.</p>

<pre><code class="csharp">public HttpResponseMessage Get(Guid id)
{
    var customer = CustomerRepository.Get(id);

    if (customer == null)
        return Request.CreateResponse(HttpStatusCode.NotFound, "Customer not Found with id " + id);

    return Request.CreateResponse(HttpStatusCode.OK, customer);
}
</code></pre>

<pre><code class="csharp">[Theory]
[InlineAutoMoqData]
public void CustomerControllerGetWithNoCustomerReturnsNotFound(
    Guid customerId,
    [Frozen]Mock&lt;ICustomerRepository&gt; customerRepository,
    CustomerController sut)
{
    // Fixture setup
    customerRepository.Setup(a =&gt; a.Get(customerId)).Returns(null);
    var expected = HttpStatusCode.NotFound;

    // Exercise system
    var actual = sut.Get(customerId).StatusCode;

    // Verify outcome
    Assert.Equal(expected, actual);
}
</code></pre>

<p>The tests above uses <a href="http://blog.nikosbaxevanis.com/2012/07/31/autofixture-xunit-net-and-auto-mocking/">InlineAutoMoqData attribute</a> which is a customized xUnit data attribute that uses Moq framework to inject dependencies. The Mock<ICustomerRepository> represents a mocked interface implementation. Behavior is setup on the mock using the Setup method. By using <a href="http://blog.ploeh.dk/2010/03/17/AutoFixtureFreeze/">Frozen</a> attribute for the Mock parameter, we tell AutoFixture to create only one instance of the mocked object and then use the same instance for any future requests of that type. This forces the same instance of the repository to be injected into the CustomerController class as well when it asks for a ICustomerRepository to AutoFixture.</p>

<p>Creating test data is an important aspect of any test. Making sure that you minimize the dependencies on the implementation detail is important to make your tests more robust. This allows the code to be refactored as long as some of the core contracts that we are testing remain the same. AutoFixture helps minimize the code in <a href="http://xunitpatterns.com/Four%20Phase%20Test.html">Fixture Setup phase</a>, which otherwise tends to grow bigger. Hope this helps you with your tests!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simulating delays in HTTP Calls For Manual Tests]]></title>
    <link href="http://rahulpnath.com/blog/simulating-delays-in-http-calls-for-manual-tests/"/>
    <updated>2017-01-09T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/simulating-delays-in-http-calls-for-manual-tests</id>
    <content type="html"><![CDATA[<p>At one of my clients, we were facing an issue of missing some part of a form data when processing a <em>Submit</em> request on the form. As per the current design, the form autosaves data to the database as and when user types in. When the user finally submits the form to be processed the Controller gets all the relevant data from the database and sends for processing. But we noticed that the processing requests missed parts of data in the request send for processing even though the database had those values. This was a clear case where the forms submit request got processed even before all the forms data was saved. The UI was enabling the Submit button right after all the UI validations were made and asynchronously firing off saves to the database.</p>

<p>Let&rsquo;s not go into the design discussion of whether the UI should be sending in all the data to be processed as part of the Submit request as opposed to just sending a reference id and have the controller get all the data from the database (which it is currently doing). The quick fix for this problem was to enable the submit button only after all the asynchronous save requests (the ones for autosave) came back with a success response. The fix was simple but testing this was a challenge.</p>

<blockquote><p><em>We wanted to delay a few HTTP requests to check how the UI behaved</em></p></blockquote>

<p>When using automated tests there are a lot of frameworks that can help delay requests. But in this case, we were relying on manual tests.</p>

<h3>Using Fiddler to Delay Requests</h3>

<p><a href="http://www.telerik.com/fiddler">Fiddler</a> is an HTTP debugging proxy server application, that captures HTTP and HTTPS traffic and displays to the user. It is one of the <a href="http://www.rahulpnath.com/blog/tools-that-I-use/">tools that I use almost every other day</a>. In Fiddler, we can create rules on web requests and modify how they are handled and responded. Most of the functionality is available under the <a href="http://docs.telerik.com/fiddler/KnowledgeBase/AutoResponder#latency">AutoResponder</a> tab. We had seen earlier how to <a href="http://www.rahulpnath.com/blog/using-fiddler-to-help-in-manual-testing/">compose web requests and also simulate error conditions in Fiddler</a>. Here we will see how to use Fiddler to delay request/response time. In Fiddler, we can either delay the request itself being sent to the server or delay the handover of response back to the calling application once it is received from the server.</p>

<h4><strong>Delay</strong></h4>

<p>By setting <a href="http://docs.telerik.com/fiddler/KnowledgeBase/AutoResponder#delay">delay</a> on a request we can specify the time to delay sending the request to the server. The value is specified in milliseconds. When a request that <a href="http://docs.telerik.com/fiddler/KnowledgeBase/AutoResponder#matching-rules">matches</a> the condition set (in this case an EXACT match with a URL) fiddler delays sending this request to the server by the set amount of time.</p>

<blockquote><p><em>Delay sending request to the server by #### of milliseconds</em></p></blockquote>

<p>Drag&#8217;n Drop the request the URL (1) into the AutoResponder tab (2) and from the dropdown (3) under the Rule Editor choose delay and set the delay time. Click Save (4). Make sure that the request and rules are enabled (5 &amp; 6).</p>

<p><img class="center" alt="Posts per month - 2016" src="/images/fiddler_delay.png"/></p>

<h4><strong>Latency</strong></h4>

<p>By setting <a href="http://docs.telerik.com/fiddler/KnowledgeBase/AutoResponder#latency">latency</a> on a request we can specify the delay before a response is received. When a request that <a href="http://docs.telerik.com/fiddler/KnowledgeBase/AutoResponder#matching-rules">matches</a> the condition set fiddler sends the requests to the server immediately. Once the response is received it delays passing the response back to the calling application by the set delay time in milliseconds.</p>

<blockquote><p><em>Induce a delay (latency) before a response is returned.</em></p></blockquote>

<p>Drag&#8217;n Drop the request URL (1) into the AutoResponder tab (2). Right click on the URL and select &lsquo;Set Latency&rsquo; (3). Enter the latency time in milliseconds and OK. Make sure that rules and latency options are enabled (4 &amp; 5)</p>

<p><img class="center" alt="Posts per month - 2016" src="/images/fiddler_latency.png"/></p>

<p>Using these options we delayed all the autosave requests going off the form. This delayed saving the data in the database and the forms Submit request once processed did not have all the required data. It also helped us test after the fix and helped ensure that the submit button was enabled only after all form data was saved. In both the above examples, I chose EXACT match condition to set the delay/latency. This will delay only the specific requests. To modify all the requests you can use a different regex match condition. To simulate a random time delay or latency among different requests you can even use <a href="http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse">Fiddler Scripting</a> and set the delay time using a random number. This helps simulate a slow internet connection scenario and test how the application responds to it.</p>
]]></content>
  </entry>
  
</feed>
