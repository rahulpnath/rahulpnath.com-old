<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/programming/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2017-02-17T00:01:24+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Defensive Coding]]></title>
    <link href="http://rahulpnath.com/blog/defensive-coding/"/>
    <updated>2017-02-07T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/defensive-coding</id>
    <content type="html"><![CDATA[<p>Often when writing code or in code review discussions it comes up - &lsquo;<em>Should I be doing a null check here?</em>.&rsquo; and we start off long discussions. Like in most cases, there is no definite answer to this. In this post let us examine some of the pros and cons of having defensive checks and how and when we can avoid it to make the code more readable.</p>

<p><img alt="Defensive Coding" src="/images/defensive_coding.jpg" /></p>

<p>Let&rsquo;s see an example to explore more. The below code aggregated details from different repository classes and returns a combined model. I have kept this simple with just three dependencies.</p>

<pre><code class="csharp">public PersonDetails GetPersonDetails(Guid personId)
{
    var person = personRepository.GetPerson(personId);
    var subscriptionPlan = subscriptionRepository.GetSubscriptionForPerson(person.Email);
    var billingSummary = billingRepository.GetSummary(subscriptionPlan.Id);

    return new PersonDetails() {...};
}
</code></pre>

<p>As you see, there are no null checks on any of the values returned from external dependencies. The code expects all calls to be successful with no exceptions - &lsquo;<a href="https://en.wikipedia.org/wiki/Happy_path">happy path</a>&rsquo; scenario.
The problem is when an error happens; the exception stack trace will look like something below.</p>

<pre><code class="text">Object reference not set to an instance of an object.
at UserQuery.GetPersonDetails(Guid personId)
  at UserQuery.Main()
</code></pre>

<p>We will not be able to tell which of the values was null, making it hard to debug the error. We have to manually go through the code checking how each of the dependencies retrieves values and check which one possibly was null. Debugging takes a lot of time and might be difficult depending on the complexity of the dependencies. The advantage of the above code though is that it is readable and there is <strong><em>noise</em></strong> in the code.</p>

<h3>Extensive Defense</h3>

<p>Let us now modify the above example to see how it would be to add defensive code and check for nulls.</p>

<pre><code class="csharp">public PersonDetails GetPersonDetails(Guid personId)
{
    if (personId == Guid.Empty)
        throw new ArgumentNullException(nameof(personId);

    var person = personRepository.GetPerson(personId);
    if (person == null)
        throw new Exception("Person is null");

    if (person.Email == null)
        throw new Exception("Email is null for person " + personId);

    var subscriptionPlan = subscriptionRepository.GetSubscriptionForPerson(person.Email);
    if (subscriptionPlan == null)
        throw new Exception("Subscription Plan is null");

    var billingSummary = billingRepository.GetSummary(subscriptionPlan.Id);
    if (billingSummary == null)
        throw new Exception("BillingSummary is null");

    return new PersonDetails() { };
}
</code></pre>

<p> The defensive checks added for guarding against invalid values makes the code harder to read. Defensive checks are there for incoming parameters as well and validate if they are null/default value (for Guid). However when an error happens the stack trace will mention the name of the property which was null. Debugging is fast and easy and makes the exception message useful. But we don&rsquo;t want our code filled with defensive checks like this.</p>

<h3>Team Conventions and Practices</h3>

<p>Let us dig a bit deeper into why we had to put in the defensive checks in the first place. We had to check for null on <em>person</em> since the repository decided to return a null when it could not find the person given an id. Does it even make sense or add any value in returning a null reference from the repository? Unless the business works in a way that there is a high possibility of something returning null this does not add any value. Even in cases like that, we should revert to other options which we will see in a while. When most of the time we expect a person to exists, it is better for the repository to throw an exception right away that the person does not exist. If the validations and the defensive checks are performed at the boundaries, then we do not need to do a null check anymore when getting a person or any similar functions.</p>

<pre><code class="csharp">public Person GetPerson(Guid personId)
{
    if (personId == Guid.Empty)
        throw new ArgumentNullException(nameof(personId));

    var person = DataContext.Get(personId);
    if (person == null)
        throw new UserDoesNotExistsException("Person does not exists with id ", personId);

    return person;
} 
</code></pre>

<p>For cases where there are possibilities of a value existing or not you can resort to <a href="http://www.rahulpnath.com/blog/stronger-code-contracts/">Stronger Code Contracts</a>. Using the Maybe type to indicate a value might or might not be present is a good way to force defensive checks. Maybe type ensures that any consumer of the code handles the case where the object does not exist. Readability of the code also improves in this case.</p>

<p>If you have noticed in the above code when checking for null&rsquo;s, I checked the Email property for null as well. Setting up team conventions that properties cannot be null, help reduce defensive checks for it. You could use various techniques to ensure properties are not null like setting a default value for the property in the constructor, <a href="https://en.wikipedia.org/wiki/Null_Object_pattern">Null object pattern</a>, checking for null&rsquo;s when setting property values or modeling the object in a way that optional parameters are not direct properties on the object.</p>

<pre><code class="csharp">public class Person
{
    private Email email;

    public Person()
    {
       Email = Email.Empty;
    }

    public Email Email
    {
        get { return email; }
        set
        {
            if (value == null)
                throw new ArgumentNullException("email cannot be null");

            email = value;
        }
    }
}
</code></pre>

<p>With the updated repository code and the property changes, we can rewrite the original code much similar as it was before introducing the defensive checks. The guard clauses at the start of the function, checking for the parameters is still important. Validating for input parameters helps find the problems earlier in the code stack and follows the <a href="https://en.wikipedia.org/wiki/Fail-fast">fail fast</a> pattern. It helps us find exactly where the null was introduced and address the issue faster. The defensive code is at the beginning of the function and can be easily skipped over while reading. If you are not that keen to write this on all functions, you can also write some helper classes which Validates a list of parameters (<a href="https://msdn.microsoft.com/en-au/library/w5zay9db.aspx">params</a>). I prefer the explicit check and used to skipping over them when reading code.</p>

<pre><code class="csharp">public PersonDetails GetPersonDetails(Guid personId)
{
   if (personId == Guid.Empty)
        throw new ArgumentNullException(nameof(personId);

    var person = personRepository.GetPerson(personId);
    var subscriptionPlan = subscriptionRepository.GetSubscriptionForPerson(person.Email);
    var billingSummary = billingRepository.GetSummary(subscriptionPlan.Id);

    return new PersonDetails() {...};
}
</code></pre>

<h3>Value Objects and Defensive Coding</h3>

<p>Let us now look at other ways to improve defensive checks on properties. Modeling properties as <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Value Objects</a> helps contain the defensive code within the property. Like in the above case where email cannot be null, the checks to make sure that it is a valid email can be within the Email class. Containing this logic in the class removes the need for the rest of the code to check for it. If an email object exists, it will be valid. It is the same with names, date ranges, money, etc. The lesser we expose primitive type properties, the less defensive code we need to write. It also removes the problems of checking <em>string.IsNullOrEmpty</em> at some places and just for nulls at others.</p>

<p>Though this is not an extensive examination of all possible cases, we have still seen some common scenarios. Defensive coding is required. It is about striking a balance and making <a href="http://www.rahulpnath.com/blog/stronger-code-contracts/">code contracts stronger</a> to convey the intent. The defensive checks are within the classes responsible for the object and exist at a central place. It removes the need to check for it elsewhere in the code. This is a simple application of <a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming">Encapsulation</a>. So the next time you check for null make sure it is where it should be!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tip of the Week: Quick Launch in Visual Studio]]></title>
    <link href="http://rahulpnath.com/blog/quick-launch-in-visual-studio/"/>
    <updated>2017-02-02T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/quick-launch-in-visual-studio</id>
    <content type="html"><![CDATA[<p><img alt="Visual Studio Quick Launch" src="/images/visualstudio_quicklaunch.png" /></p>

<p>As a .NET developer, I spent the majority of my time in Visual Studio. Knowing to navigate fast within the IDE or quickly find what I want is important. Many times finding specific settings or navigating to individual windows can take a while, especially if you are not familiar with it and don&rsquo;t know exactly where to look. Visual Studio has a quick launch toolbar that is designed exactly for this. Be it opening the Package Manager Console or changing the font style you can use the quick launch to search and navigate to it.</p>

<blockquote><p><em>You can use <a href="https://msdn.microsoft.com/en-us/library/hh417697.aspx">Quick Launch</a> to quickly search and execute actions for IDE assets such as options, templates, menus. You can&rsquo;t use Quick Launch to search for code and symbols. The Quick Launch search box is located at the top-right corner of the menu bar and is accessible by choosing the <strong>Ctrl+Q</strong> keys.</em></p></blockquote>

<p>The added advantage is that you can use the quick launch bar to <strong><em>learn new keyboard shortcuts</em></strong>. Searching for an item also shows the keyboard shortcut for it next to it. Over time you can remember the direct keyboard shortcut and avoid quick launch as well.</p>

<p><img alt="Visual Studio Quick Launch learn keyboard shortcuts" src="/images/visualstudio_quicklaunch_keyboardShortcuts.png" /></p>

<p>Knowing the tools that you use is an important part of development. Able to navigate fast within the IDE enables to remove any time wasted poking around the IDE. Use that time to read and write code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Avoid State Mutation]]></title>
    <link href="http://rahulpnath.com/blog/avoid-state-mutation/"/>
    <updated>2017-02-01T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/avoid-state-mutation</id>
    <content type="html"><![CDATA[<p>How many times have you had to navigate down a long chain of function calls to find out that some code deep down was changing the value of an object passed to it? The change could either be setting the value to null or modifying the value in itself. When passing around reference types, it&rsquo;s easy to run into this situation very often.  This happens not just when debugging existing code, but also when looking at the code we have just finished writing. Maintaining state transitions and object state based on the order in which functions are invoked on them can soon become confusing and buggy. So the best way is to try and avoid them in the first place.</p>

<p><img alt="Avoid State Mutation" src="/images/mutation.png" /></p>

<h3>What is state Mutation</h3>

<p>The process of changing the value of a variable or an object over time after creation is called mutation. In simpler terms when you are changing the value of an object, you are mutating the state. I am sure that everyone would have had some time getting their head around the below statement when starting off with programming (I did)</p>

<pre><code class="csharp">var x = 1;
x = x + 1;
</code></pre>

<p>By second nature (depending on the programming languages one is exposed to e.g. csharp, java, etc.) you would say the above statement is perfectly fine and not think twice about anything. But show it to someone who is new to programming. They will find it hard to understand those two statements, the same phase that we have all gone through. &lsquo;=&rsquo; has turned into an assignment operator while it is an equality operator in mathematics. There are languages where &lsquo;=&rsquo; still stands for equality (like FSharp). In the example above the value of x is mutated - it is changed from 1 to 2.</p>

<blockquote><p><em>The process of actually changing a variable’s value over time, within a single context, is called mutation.</em></p></blockquote>

<h3>Risks of Mutation</h3>

<p>Mutable types can pose risks when passing a mutable value as function parameters or when returning mutable values from functions.</p>

<h4><strong>Passing Mutable Value</strong></h4>

<p>Let us take a simple example below. I have a list of integers, and I want to check if the first item of the incoming list and the sorted one are same. I have a simple sort method which implements <a href="https://en.wikipedia.org/wiki/Bubble_sort">Bubble sort</a>. What do you think will be the output?</p>

<pre><code class="csharp">{
    var list = new List&lt;int&gt;() { 2, 1, 3 };
    var sortedList = Sort(list);
    if (sortedList.First() == list.First())
        Console.WriteLine("First item is in place");
}

public IEnumerable&lt;int&gt; Sort(IEnumerable&lt;int&gt; list)
{
    var listEvaluated = list as IList&lt;int&gt; ?? list.ToList();
    int size = listEvaluated.Count();
    for (int i = 1; i &lt; size; i++)
    {
        for (int j = 0; j &lt; (size - i); j++)
        {
            if (listEvaluated[j] &gt; listEvaluated[j + 1])
            {
                int temp = listEvaluated[j];
                listEvaluated[j] = listEvaluated[j + 1];
                listEvaluated[j + 1] = temp;
            }
        }
    }

    return listEvaluated;
}
</code></pre>

<p>Yes, it prints out the message that the <em>First item is in place</em>. Before getting into the details of the issue, let us set our expectations correct. When calling the Sort method, we do not expect it to change the contents of the original list. Given that the function&rsquo;s signature is that of a Query (returns a value), we expect it not to create any <a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science">side effects</a>). According to <a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">Command Query Separation</a> (CQS) by Bertrand Meyer in <a href="http://amzn.to/2hZ4P9C">Object Oriented Software Construction</a></p>

<blockquote><p><em>Every method should either be a command that performs an action, or a query that returns data to the caller, but not both. In other words, Asking a question should not change the answer. More formally, methods should return a value only if they are referentially transparent and hence possess no side effects.</em></p></blockquote>

<p>Applying CQS means that any method can either be a Query or a Command. A command changes the state of the system but does not return a value (void). A query does not change the state of the system and returns a value and should be idempotent. Such functions are also referred to as <a href="https://en.wikipedia.org/wiki/Pure_function">pure functions</a>. The above Sort function only partially confirms to being a query. It does return the same output given the same input, the sorted list. But it changes the state of the system and has side effects - it mutates the list passed. The issue in the implementation of the Sort is that it casts the list passed in as <em>IList<int></em>, if it is already one. So when the parameter list is of type IList, listEvaluated points to the same list. If you force copy the list irrespective of it being a list or not will fix the issue. I will discuss more on how this kind of a conditional evaluation got in here in a separate post.</p>

<pre><code class="csharp">var listEvaluated = list.ToList();
</code></pre>

<p>This kind of change is only possible if the development team owns the Sort function. If this is a third-party library that you are consuming then the only way to avoid the problem will be to send in a copy of the list. Even trying to pass the list <a href="https://msdn.microsoft.com/en-us/library/e78dcd75(v=vs.110).aspx">AsReadOnly</a> will not work here. Check it out if you are not sure why.</p>

<pre><code class="csharp">var sortedList = Sort(list.ToList());
</code></pre>

<p>The above solution does not imply that every time we need to pass in a list to a function we should defensively copy it (using ToList). <em>It depends</em>. Within a development team, there can be a convention that it sticks to CQS principle. In case of exceptions, make sure that it is communicated to everyone. Communication to developers is done best by naming the function to reflect that or adding a comment that shows up in the IDE intellisense (if any). For code that you consume from third parties or open sources make sure you understand well how the library behaves and check the documentation before using it. Ensure you have <a href="http://www.rahulpnath.com/blog/category/tdd/">unit tests</a> asserting the assumptions and behavior in all cases.</p>

<h4><strong>Returning Mutable Values</strong></h4>

<p>Let us take an example to see the possible effects of returning mutable values from a function. Below is a configuration helper class which returns a configuration object. The helper method is used in three different places of the application shown as <em>config1, config2, config3</em>. In one of the cases, the business logic requires the Duration value to be twice that in configuration. Since the real configuration helper reaches out to the database for its values, it was decided to cache the values after the first call. The ConfigurationHelper uses &lsquo;<em><a href="https://en.wikipedia.org/wiki/Singleton_pattern">Singleton Pattern</a></em> to achieve the caching Below is the implementation. Do you see any problems?</p>

<pre><code class="csharp">{
    var config1 = ConfigurationHelper.Get();
    Console.WriteLine(config1);
    ...
    var config2 = ConfigurationHelper.Get();
    config2.Duration = config2.Duration * 2;
    Console.WriteLine(config2);
    ...
    var config3 = ConfigurationHelper.Get();
    Console.WriteLine(config3);
}

public class ConfigurationHelper
{
    private static Configuration configuration;
    public static Configuration Get()
    {
        if (configuration == null)
            configuration = new Configuration { Duration = 1 };

        return configuration;
    }
}

public class Configuration
{
    public int Duration { get; set; }
}
</code></pre>

<p>The first caller will get the configuration value 1, as expected. The second caller also gets the configuration value 1, but it goes on to set the value as two times, so it becomes 2. The third caller, which does not have any idea of the second caller or its specific business requirements also gets the configuration value as 2. They get a wrong configuration because the second caller updated the same object that the ConfigurationHelper holds. Again this is a side effect of how the ConfigurationHelper returns the configuration. There are two or more ways to solve this problem. The ConfigurationHelper class can return a new instance of the Configuration class every time someone requests for it. To return a new instance requires removing the private variable and the conditional check associated with it. Removing the check is similar to the defensive copying that we discussed in the previous example and also every call to get the configuration, now needs to hit the database. One could argue that only one caller mutates the object and it is unnecessary to create a new instance for the rest. We can remove the public setter&rsquo;s on the Configuration class properties. Without a setter, the second caller cannot change the Duration property of the Configuration class. Removing the setter means that we add a constructor as well to take in the parameters that it requires as below.</p>

<pre><code class="csharp">public class Configuration
{
    public int Duration { get; private set; }

    public Configuration(int duration)
    {
            Duration = duration;
    }
}
</code></pre>

<p>The above ensures that nobody can change the value of the configuration object once created. So the second caller can longer assign the new duration value to the same object. If it wants to continue using a configuration object it needs to create a new Configuration object with the new duration. If there are more properties on the configuration object you can create extension methods like WithDuration to create a new Configuration class copying all the values as is from the old object and replace just the Duration.</p>

<pre><code class="csharp">public static class ConfigurationExtension
{
    public static Configuration WithDuration(this Configuration configuration, int duration)
    {
        return new Configuration(duration, configuration.OtherValue);
    }
}
</code></pre>

<p>As we have seen the above two cases, mutation can cause undesired effects unless those are intended for. It does not mean that mutating is bad and you should stop it immediately. But if you start writing your code using immutable types, <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Value Objects</a>, etc. you will slowly move to a point where you no longer need to mutate values. When you do not mutate state, it is easier to reason about code. You no longer need to wade through those method calls to find who is changing the value of a property. Immutability is one of the key features of functional languages and changes how programs are written. You take away most of the problems involved in multi-threading when a function can no longer mutate the state of the object. So the next time you make change check if you are changing the state of the object, think twice and see if you can find a way around!</p>

<p><strong>References:</strong></p>

<ul>
<li><a href="http://web.cs.wpi.edu/~cs2102/common/kathi-notes/mutation-part2.html">Mutation</a></li>
<li><a href="http://web.mit.edu/6.005/www/fa15/classes/09-immutability/">Mutability &amp; Immutability</a></li>
<li><a href="https://www.cs.utexas.edu/~wcook/anatomy/anatomy.htm#Mutable">Mutable State</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Making Code Reviews Effective]]></title>
    <link href="http://rahulpnath.com/blog/code-review/"/>
    <updated>2017-01-03T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/code-review</id>
    <content type="html"><![CDATA[<p>Code review is an essential practice of the development life cycle. It helps improve the code quality, unify team practices, share knowledge, mentoring etc. over a longer period of time. It helps find mistakes that are overlooked while developing and helps improve the overall quality of the software. This helps accelerate the deployment process as changes are more likely to pass through testing.</p>

<blockquote><p><em>Peer review—an activity in which people other than the author of a software deliverable examine it for defects and improvement opportunities—is one of the most powerful software quality tools available. Peer review methods include inspections, walkthroughs, peer desk checks, and other similar activities.</em></p>

<p>-<a href="http://www.processimpact.com/articles/humanizing_reviews.html"><strong> Karl E. Wiegers</strong></a></p></blockquote>

<p><img class="center" alt="Posts per month - 2016" src="/images/codereview_friendly.png"/></p>

<p>Below are some of my thoughts on the various aspects involved in a Code Review.</p>

<h3>Sending a Review</h3>

<p>Before sending for a code review make sure that only the necessary files for the change are added in the review. Often it happens that when we write code there are remains of things that we tried and discarded, like new files, packages, changes to project metadata files etc. Double check and make sure that the changes are what are just required. Ensure that the code builds successfully. If there are any build scripts that your team uses, make sure that those are run and passes successfully. When submitting a code review make sure that you reference the associated work item - be it a bug, story, task etc. Add <a href="http://www.rahulpnath.com/blog/category/testing/">tests</a>. Add in a description detailing the change and any reasoning behind it to add in more context. This will help the reviewer understand the code much faster. Add in relevant people for the review and submit a request. Check out <a href="http://blog.ploeh.dk/2015/01/15/10-tips-for-better-pull-requests/">some great tips for a better-looking review request</a>.</p>

<h3>Handling Review Comments</h3>

<p>One of the key things in a code review and one that&rsquo;s often missed and drives people frustrated is that they try to take it all in.</p>

<blockquote><p><em>Not all comments in a review needs to be addressed</em></p></blockquote>

<p>If a review comment points out a mistake in logic or business functionality or conflict with other code you need to fix them, unless you think the reviewer is wrong. But for suggestions on how better to structure your code or refactor into a more readable code, naming, style formatting etc needs addressing only if you feel they are adding value. But make sure to communicate well with the reviewer and reach an agreement.</p>

<p>Look at comments as a way to improve your code and help the team and business. Go in with a positive attitude. When seen as an overhead or an extra ritual, code reviews can be really painful and depressing. Make a note of commonly occurring comments or mistakes you are making and try to handle them at the time of development. Rather than mechanically going through the code review and making changes to the code, internalize on the change and try to see the benefits of a change. This helps to incorporate such suggestions in future reviews as well.</p>

<h3>Responding to a Code Review</h3>

<p>I usually find myself following the below three variations when coming to replying to a code review request</p>

<ul>
<li><p><strong>Comment and Wait</strong>
I leave comments on the review but do not approve. This means that I would like to have those comments actioned and a new pull request be raised for that. This often falls into those cases where there are logic or business issues.</p></li>
<li><p><strong>Comment and Approve</strong>
I leave comments (if any) but also approve the code review. This means that the code <em>Looks Good To Me</em> (LGTM), but would be better with the comments addressed. These comments generally relate to better formatting, improved on naming or refactoring readability.</p></li>
<li><p><strong>Add Relevant People</strong>
Add in reviewers that I feel are missed and relevant for the part of the code that is changed.  This I do irrespective of the above two options if I feel someone else needs to take a look. In these cases, if it was my review that gets added in an extra reviewer I would wait to get a sign off from that person too.</p></li>
</ul>


<h4><strong>Business Aspect</strong></h4>

<p>When reviewing code look first for the functionality that the code change addresses. It is possible that we get carried away just by the technical aspect of code and ignore the business aspect altogether. If you have <a href="https://www.leadingagile.com/2014/09/acceptance-criteria/">Acceptance Criteria</a> defined for tasks then it&rsquo;s worth reading it before doing the code review to get more context.</p>

<h4><strong>Technical aspect</strong></h4>

<p>Once the business aspect is covered have a look at the technical aspect of the change. Whether the code is decoupled, has the correct abstractions, follows team conventions (best if automated). Check for commonly occurring problems like improper usage of dispose pattern, magic numbers, large methods, all code flow paths not handled etc. See if the new code fits into the overall architecture of the application. Look for tests and ensure the validity of the test data. Look out for <a href="https://en.wikipedia.org/wiki/Overengineering">overengineering</a> or <a href="https://en.wikipedia.org/wiki/Not_invented_here">not invented here syndrome</a>.</p>

<h4><strong>Aesthetic</strong></h4>

<p>Code formatting is as important as the code itself. Code is read more often than written, so we should try and optimize code for reading. I would prefer to automate this as far as possible so that people don&rsquo;t need to look for these in reviews. I feel that is often time not well spent and also tends to lead to longer discussions (<a href="https://blog.codinghorror.com/death-to-the-space-infidels/">tabs vs Spaces</a>). When it is part of the build and automated people seldom complain about it and in a very short period of time, the formatting rules become second nature to them. If you currently do not have automated checks you can gradually <a href="http://www.rahulpnath.com/blog/introducing-code-formatting-into-a-large-codebase/">introduce formatting checks into your builds for a large code base</a>.</p>

<blockquote><p><em>Don&rsquo;t go by &lsquo;It&rsquo;s done like that everywhere so I will keep it the same&rsquo;</em></p></blockquote>

<p>There might be a lot of practices that is being followed over the period of time. But if you find any of the practices making it harder on a day-to-day functioning of the team, take a step towards changing the practice. I am not a fan of &lsquo;<em>clean it all at once</em>&rsquo; style of approach. I prefer to gradually introduce the change for two reasons</p>

<ul>
<li>No need to stop or allocate people to repeatedly do the same task of cleaning it everywhere. (Unless there is a very strong business justification to it)</li>
<li>You get gradually introduced to the new way of doing things. This gives time to reflect and compare with the old way. You have time to correct yourself if the new approach is not fitting well either or causing more trouble than previous.</li>
</ul>


<h3>Handling Conflicts</h3>

<p><img class="center" alt="Posts per month - 2016" src="/images/codereview_wtf.png"/></p>

<p>Foster environments where you don&rsquo;t curb discussions or other people&rsquo;s ideas but encourage everyone to actively participate and throw around even the stupidest of an idea.</p>

<blockquote><p><em>Psychological safety is a “shared belief, held by members of a team, that the group is a safe place for taking risks.” It is “a sense of confidence that the team will not embarrass, reject, or punish someone for speaking up,” Edmondson wrote in a 1999 paper. “It describes a team climate characterized by interpersonal trust and mutual respect in which people are comfortable being themselves.</em></p>

<p><a href="https://www.linkedin.com/pulse/what-google-learned-from-its-quest-build-perfect-team-charles-duhigg"><strong>- Charles Duhigg</strong>, <em>What Google Learned From Its Quest to Build the Perfect Team</em></a></p></blockquote>

<p>Code reviews should also be seen as a way to incorporate better practices from fellow developers and as a learning mechanism. Don&rsquo;t take comments personal, but look at it for what they are. When you have a conflicting opinion you can reply to the comment with your thoughts and cross check with the reviewer. Rarely it can happen that you have conflicting opinions on code review comments and you are not able to solve it among the people involved.  Walk up to the person (if you are co-located) or have a conversation over your teams messaging application. But make sure that it stays healthy. In case the discussion is not going the intended way you can involve senior team members or other fellow team members to seek their opinions too. If such kinds of conflicts are happening more often then the team needs to analyze the nature of review comments that these occur on, if it&rsquo;s between specific groups of people or any visible patterns and try to address them.</p>

<p>When taken in isolation any practices that a team does take time. So disregard any activity just because it adds more time to your process. When seen as part of the overall development cycle and the benefits it brings to the business, Code Reviews proves to be an essential practice. Different teams tend to have different guidelines and checklists for the reviews. Follow what works best for your team. Do you do code reviews as part of your development cycle? What do you feel important in a Code Review? Sound off in the comments!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Make Your Code Contracts Stronger]]></title>
    <link href="http://rahulpnath.com/blog/stronger-code-contracts/"/>
    <updated>2016-12-12T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/stronger-code-contracts</id>
    <content type="html"><![CDATA[<p>How often have you gone into a class to see the implementation when consuming the class or an interface? I do this almost every other day and it&rsquo;s mostly to check how the code handles boundary conditions. What does it do when there is no value to return, does it need all parameters etc. Reading code is hard and time-consuming, even if it&rsquo;s a code that you yourself have written a few minutes back. Imagine every developer having to go into the implementation detail anytime they consume a class?    Bertrand Meyer in connection with his design of the Eiffel programming language coined the term <a href="https://en.wikipedia.org/wiki/Design_by_contract">Design By Contract</a>, an approach for designing software. The central idea of Design By Contract is to improve the contracts shared between different components in the code base. In this post, we will see how we can improve our C# code and avoid unnecessary guard statements across out code base.</p>

<p><a href="http://nebula.wsimg.com/6e7b8057c7f32b90d4f144424c8a7ae1?AccessKeyId=00F174C5B1CCF865161D&disposition=0&alloworigin=1">
<img style="box-shadow:none;" class="center" alt="Stronger Code Contracts" src="/images/strong_code_contracts.jpg"/>
</a></p>

<h3>Leaky Abstraction</h3>

<p>These days in programming we tend to abstract a lot more than what we really need. <a href="http://www.rahulpnath.com/blog/category/dependency-injection/">Dependency Injection</a> and use of IOC containers have started forcing ourselves to think that everything needs to be an interface. But essentially this is not the case. But the bigger problem lies not in the abstraction, but on depending on the implementation details after abstracting. A <a href="https://en.wikipedia.org/wiki/Leaky_abstraction">leaky abstraction</a> is an abstraction that exposes details and limitations of its underlying implementation to its users that should ideally be hidden away.</p>

<blockquote><p><em>Consuming abstractions assuming a certain implementation is bad practice</em></p></blockquote>

<p>Recently I came across the below code during a code review. Even though an empty string was not a valid configuration value that was not being checked here as the repository implementation returns a null when there is no entry.</p>

<pre><code class="csharp">string config = repository.GetConfig();
if(config == null)
{
    ...
}
</code></pre>

<p>This is a common practice and I have myself fallen for this a lot of times. The fact that the repository returns only a null value is an abstraction detail and is not clear from the contract that it exposes. Anyone could change the repository to start returning an empty string. This will then start failing this code. When taken in isolation the code that uses &lsquo;config&rsquo; must check for null and empty to avoid invalid values. The abstraction contracts (function signatures) must convey whether it always returns a value, whether it can be empty or null. This helps remove unnecessary guarding code or makes guarding mandatory across the code base and also indicates a clear intent.</p>

<p>The <a href="https://en.wikipedia.org/wiki/Robustness_principle">Robustness Principle</a> is a general design guideline for software</p>

<blockquote><p><em>Be conservative in what you do, be liberal in what you accept from others (often reworded as &ldquo;Be conservative in what you send, be liberal in what you accept&rdquo;).</em></p></blockquote>

<p>Applying this principle in this context, we must be conservative in what we return from our function (be it a class or interface) contract. The contract should be as explicit as possible to indicate the nature of values that it returns.</p>

<h3>Stronger Return Types</h3>

<p>A repository returning a string is a weak contract, as it does not clearly express the nature of value it returns. It can return either of these three values - null, an empty string or a valid configuration string. In our application, assuming that null and empty string are invalid we should be having a single representation for this state in the application. C# by its very design encourages us to use this pattern as it embraces the concept of null&rsquo;s - <a href="https://www.linkedin.com/pulse/20141126171912-7082046-tony-hoare-invention-of-the-null-reference-a-billion-dollar-mistake">the billion dollar mistake</a>. But this does not mean we are restricted by it. We can bring in concepts from other languages to help us solve this problem. In F# for example, the Option type represents presence or absence of a value. This is similar to the <a href="https://msdn.microsoft.com/en-us/library/1t3y8s4s.aspx">Nullable type in C#</a>, but not just restricted to value types. <a href="http://fsharpforfunandprofit.com/posts/the-option-type/">Option type</a> is defined as union type with two cases : Some and None. Whenever consuming an option type the compiler forces us to handle both the cases</p>

<blockquote><p><em>In pure F#, <a href="https://fsharpforfunandprofit.com/posts/correctness-exhaustive-pattern-matching/">nulls cannot exist accidentally</a>. A string or object must always be assigned to something at creation, and is immutable thereafter</em></p></blockquote>

<pre><code class="fsharp">let config = getConfig
match config with
| None -&gt; printfn "Invalid config"
| Some c -&gt; printgn "Valid config"
</code></pre>

<p>Though C# does not have anything out of the box to define optional values, we can define one of our own. The <a href="https://github.com/ploeh/Booking/blob/master/BookingDomainModel/Maybe.cs">Maybe</a> class is one such implementation of an optional concept. The name is influenced by the option type in Haskell, <a href="https://wiki.haskell.org/Maybe">Maybe</a>. There are also other implementations of Maybe but the concept remains the same - we can represent an optional type in C#.  The code contracts are stronger using Maybe as a return type. If a function always returns a value, say a string, the function contract should remain as a string. If a function cannot return a value always and can return null/empty (assuming that these are invalid values) then it returns a <em>Maybe<string></em>. This makes it clearer for consuming code on whether they should check for null/empty values.</p>

<pre><code class="csharp">Maybe&lt;string&gt; config = repository.GetConfig();
config.Do(value =&gt; LoadFromFile(value));
</code></pre>

<p>You can write different extension methods on the Maybe class, depending on how you want to process the value. In the above example, I have a Do extension method that calls on to a function with the configuration value if any exists. By explicitly stating that a value may or may not be present we have more clarity in code. No longer do we need any unnecessary null checks in the case where a value is always present. This is best achieved when agreed upon as a convention by the development team and enforced through tooling (like code analysis).</p>

<h3>Value Objects</h3>

<p>One of the root problem for having a lot of null/empty checks scattered across the code is <a href="http://blog.ploeh.dk/2015/01/19/from-primitive-obsession-to-domain-modelling/">Primitive Obsession</a>. Just because you can represent a value as a string, it doesn&rsquo;t mean that you always should. Enforcing structural restrictions imposed by the business is best done by encapsulating these constraints within a class, also known as a <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Value Object</a>. This leads to classes for representing various non-nullable values for e.g. Name, configuration, Age etc. You can use this in conjunction with <a href="https://en.wikipedia.org/wiki/Null_Object_pattern">Null Object</a> pattern if required. A value object is a class whose equality is based on the value that it holds. So two class instances with same values will be treated equally. In F# you get this by default but in C# you need to override Equals and GetHashCode functions to enforce this equality.</p>

<pre><code class="csharp">public class Configuration
{
    private string configuration;

    public Configuration(string configuration)
    {
        if (string.IsNullOrEmpty(configuration))
            throw new ArgumentNullException(nameof(configuration), "Configuration value cannot be null");

        this.configuration = configuration;
    }

    // override Equals and GetHashCode
}
</code></pre>

<p>Modeling concepts in the domain as classes helps you to contain the domain/business constraints in a single place. This prevents the need to have null checks elsewhere in the code. Value objects being immutable helps enforce class invariants.</p>

<p>The above two methods help create a stronger contract in code. As with any conventions, this is useful only when followed by the whole team. Conventions are best followed if enforced through tooling. You can create custom code analysis rules to enforce return type to be of type if any method is returning null. Even if you are introducing this into a large existing code base you can do this incrementally, by starting to enforce them on commits (if you are using git) like when <a href="http://www.rahulpnath.com/blog/introducing-code-formatting-into-a-large-codebase/">introducing styling into an existing project</a>. What other contracts do you find helpful to make the code more expressive?</p>
]]></content>
  </entry>
  
</feed>
