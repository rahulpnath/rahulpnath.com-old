<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tdd | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/tdd/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2018-12-17T00:02:04+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Semantic Comparison: Improve Test Assertions]]></title>
    <link href="http://rahulpnath.com/blog/semantic-comparison-improve-test-assertions/"/>
    <updated>2017-06-20T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/semantic-comparison-improve-test-assertions</id>
    <content type="html"><![CDATA[<p>One of the traits of a good unit test is to have just <a href="http://osherove.com/blog/2005/4/14/try-to-avoid-multiple-asserts-in-a-single-unit-test.html">one Assert statement.</a>.</p>

<blockquote><p><em>Consider Assert failures as symptoms of a disease and Asserts as indication points or blood checks for the body of the software. The more symptoms you can find, the easier the disease will be to figure out and remove. If you have multiple asserts in one test - only the first failing one reveals itself as failed and you lose sight of other possible symptoms.</em></p>

<p>-<a href="http://osherove.com/">Roy Osherove</a></p></blockquote>

<p>When a test with multiple asserts fails, it is hard to tell the exact reason of test failure. To get more details on the actual failure we either have to debug the tests or look into the stack trace.</p>

<h3>Tests With Multiple Assertions</h3>

<p>Many times we end up needing to assert on more than one properties or behavior. Let&rsquo;s look at a few such examples and see how we can refactor the tests. <em>I have excluded the actual code that is getting is tested here as it is easy to understand what that will look like from the tests. (Drop a comment otherwise)</em></p>

<p><strong>Example 1:</strong> In the below test we have a <em>Name</em> class that represents FirstName and LastName of a user. It exposes a <em>Parse</em> method to make it easy for us to create a Name object from a string. Below are some tests for the Parse method. The test has multiple assertions to confirm that the first and last name properties get set as expected.</p>

<pre><code class="csharp Name class">[Theory]
[InlineData("Rahul", "Rahul", "")]
[InlineData("Rahul Nath", "Rahul", "Nath")]
[InlineData("Rahul P Nath", "Rahul", "P Nath")]
public void FirstNameOnlyProvidedResultsInFirstNameSet(
   string name,
   string expFirstName,
   string expLastName)
{
    var actual = Name.Parse(name);

    Assert.Equal(expFirstName, actual.FirstName);
    Assert.Equal(expLastName, actual.LastName);
}
</code></pre>

<p><strong>Example 2:</strong> The below test is for the <em>Controller</em> class to confirm that the <em>CustomerViewModel</em> passed to the <em>Post</em> method on the controller saves the <em>Customer</em> to the repository. The assert statement includes multiple properties of the customer object, which is just a shorthand version of writing multiple such assert statements on each of those properties.</p>

<pre><code class="csharp Controller Unit Test">[Theory, AutoWebData]
public void PostSavesToRepository(
    CustomerViewModel model,
    [Frozen]Mock&lt;ICustomerRepository&gt; customerRepository,
    CustomerController sut)
{
  var expected = model.ToCustomer();

  sut.Post(model);

  customerRepository.Verify(a =&gt;
    a.Upsert(It.IsAny&lt;Customer&gt;(customer =&gt; 
        customer.Name == expected.Name &amp;&amp;
        customer.Age == expected.Age &amp;&amp;
        customer.Phone == customer.Phone))
}
</code></pre>

<p><strong>Example 3:</strong> The below test ensures that all properties are set when transforming from DTO to domain entity (or any such object transformations at system boundaries). The test asserts on every property of the class.</p>

<pre><code class="csharp Comparing different object types">[Theory]
[AutoMoqData]
public void AllowanceToDomainModelMapsAllProperties(
    Persistence.Allowance allowance, 
    int random)
{
    allowance.EndDate = allowance.StartDate.AddDays(random);

    var actual = allowance.ToDomainModel();

    Assert.Equal(allowance.ClientId, actual.ClientId);
    Assert.Equal(allowance.Credit, actual.Credit);
    Assert.Equal(allowance.Data, actual.Data);
    Assert.Equal(allowance.StartDate, actual.Period.StartDate);
    Assert.Equal(allowance.EndDate, actual.Period.EndDate);
}
</code></pre>

<h3>Semantic Comparison Library</h3>

<p><a href="https://www.nuget.org/packages/SemanticComparison/">Semantic Comparison</a> is a library that allows deep comparison of similar looking objects. Originally part of <a href="http://www.rahulpnath.com/blog/autofixture-make-your-unit-tests-robust/">AutoFixture</a> library, it is also available as a separate <a href="https://www.nuget.org/packages/SemanticComparison/">Nuget package</a>.</p>

<blockquote><p><em>SemanticComparison makes it easier to compare instances of various objects to each other. Instead of performing a normal equality comparison, SemanticComparison compares objects that look semantically similar - even if they are of different types</em></p></blockquote>

<p>Using SemanticComparison, we can compare two objects and compare their properties for equality. It allows including/excluding properties when comparing objects.</p>

<h3>Refactoring Tests</h3>

<p><strong>Example 1:</strong> The <em>Name</em> is a perfect case for being a <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Value Object</a>. In this case, the class will override Equals, and it will be easier for us to write the tests. Converting to a Value Object is one of the cases where we <a href="http://www.rahulpnath.com/blog/tests-as-a-feedback-tool/">use tests as a feedback to improve code</a>. But in cases where you do not have the control over the class or do not want to make it a value object, we can use SemanticComparison to help check for equality as shown below.</p>

<pre><code class="csharp Name Class">[Theory]
[InlineData("Rahul", "Rahul", "")]
[InlineData("Rahul Nath", "Rahul", "Nath")]
[InlineData("Rahul P Nath", "Rahul", "P Nath")]
public void FirstNameOnlyProvidedResultsInFirstNameSet(
   string name,
   string expFirstName,
   string expLastName)
{
    var expected = new Name(expFirstName, expLastName);

    var actual = Name.Parse(name);

    expected
        .AsSource()
        .OfLikeness&lt;Name&gt;()
        .ShouldEqual(actual);
}
</code></pre>

<p><strong>Example 2:</strong>  Using SemanticComparison we can remove the need of asserting on each of the properties. In the below case since the Customer Id is set to a new Guid in the ToCustomer method, I ignore the Id property from the comparison using <em>Without</em>. When the <em>expected</em> objects gets compared against the <em>actual</em> all properties except <em>Id</em> will be compared for equality. Any number of properties can be excluded by chaining multiple <em>Without</em> methods.</p>

<pre><code class="csharp Controller Unit Test">[Theory, AutoWebData]
public void PostSavesToRepository(
    CustomerViewModel model,
    [Frozen]Mock&lt;ICustomerRepository&gt; customerRepository,
    CustomerController sut)
{
  var customer = model.ToCustomer();
  var expected = customer
      .AsSource()
      .OfLikeness&lt;Customer&gt;()
      .Without(a =&gt; a.Id);

  sut.Post(model);

  customerRepository.Verify(a =&gt;
    a.Upsert(It.IsAny&lt;Customer&gt;(actual =&gt; 
        expected.ShoudEqual(actual)));
}
</code></pre>

<p><strong>Example 3:</strong>  Using SemanticComparison we can remove the asserts on every property and also set custom comparisons. The StartDate and EndDate on the persistence entity are converted into a DateRange object (Period). By using the <em>With</em> method in combination with the <em>EqualsWhen</em> method we can set custom comparison behavior that needs to be performed when comparing objects. The same test will hold true even if we add new properties and will force mapping to be updated if any of the property mappings is missed. Here we also see how SemanticComparison can compare two different types.</p>

<pre><code class="csharp Comparing different object types">[Theory]
[AutoMoqData]
public void AllowanceToDomainModelMapsAllProperties(
    Persistence.Allowance allowance, 
    int random)
{
    allowance.EndDate = allowance.StartDate.AddDays(random);

    var actual = allowance.ToDomainModel();

    allowance
        .AsSource()
        .OfLikeness&lt;Allowance&gt;()
        .With(a =&gt; a.Period)
        .EqualsWhen((p, m) =&gt; { return m.Period.StartDate == p.StartDate &amp;&amp; m.Period.EndDate == p.EndDate; })
        .ShouldEqual(actual);
}
</code></pre>

<p>Using SemanticComparison library, we reduce the dependencies on the actual implementation and extract that into a more generic representation. Fewer dependencies on the actual implementation code/properties make the tests more robust and adaptable to change. Hope this helps you get started with Semantic Comparison and improve on your test assertions.</p>

<p><strong>References:</strong></p>

<ul>
<li><a href="http://blog.ploeh.dk/2012/06/21/TheResemblanceidiom/">The Resemblance Idiom</a></li>
<li><a href="http://blog.ploeh.dk/2010/06/29/IntroducingAutoFixtureLikeness/">Introducing AutoFixture Likeness</a></li>
<li><a href="http://blog.ploeh.dk/2012/06/22/ResemblanceandLikeness/">Resemblance and Likeness</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use Tests As A Feedback Tool To Improve Code]]></title>
    <link href="http://rahulpnath.com/blog/tests-as-a-feedback-tool/"/>
    <updated>2017-06-01T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/tests-as-a-feedback-tool</id>
    <content type="html"><![CDATA[<p>A unit test suite provides immediate feedback when you make a change. A passing test suite gives the confidence on the changes made. It&rsquo;s the confidence that the team has on the tests suite that matters more than the <a href="http://www.rahulpnath.com/blog/is-code-coverage-a-lie/">code coverage number</a>. Tests also provide feedback about the code. It suggests how easy or difficult it is to use the code just written since tests are the first consumers of the code. Different kinds of <a href="http://xunitpatterns.com/Test%20Smells.html">Test Smells</a> indicates a problem with the code that is getting tested or the test code itself and provides feedback to improve it.</p>

<p><img alt = "Test Feedback" src="/images/test_feedback.png" class = "center" /></p>

<p>Let&rsquo;s take a look at a couple of Test Smells and see what changes can be made to improve the code.</p>

<h3>Multiple Asserts on Class Properties</h3>

<p>Tests should ideally follow the Single Responsibility Principle (SRP). It should test one thing and try to limit that to one <em>Assert</em> statement. Often I come across tests that assert multiple things. At times this could just be that we are testing all side-effects of the method that is getting tested. Such tests can be broken down into separate tests which test just one thing each. In certain other cases, the effects of the method that is getting tested itself are spread across multiple properties. Let&rsquo;s see a simple example of one such case. Below is a DateRange class which takes in a StartDate and EndDate and creates a DateRange class if the endDate is greater than startDate.</p>

<pre><code class="csharp">public class DateRange
{
    public readonly DateTime StartDate;

    public readonly DateTime EndDate;

    public DateRange(DateTime startDate, DateTime endDate)
    {
        if (endDate &lt; startDate)
            throw new ArgumentException("End date cannot be less than start Date");

        StartDate = startDate;
        EndDate = endDate;
    }

    public static DateRange MonthsFromDate(DateTime date, int numOfMonths)
    {
        return new DateRange(date   , DateTime.Today.AddMonths(numOfMonths));
    }

    public bool IsInRange(DateTime theDateTime)
    {
        return theDateTime &gt;= StartDate &amp;&amp; theDateTime &lt;= EndDate;
    }
}
</code></pre>

<p>Let&rsquo;s take a look at one of the tests that check for the successful creation of a DateRange object using the MonthsFromDate function. In the tests below you can see that there are two statements to assert that the DateRange object is created successfully. In this particular case, the assertions are limited to two, but could often be more than that.</p>

<pre><code class="csharp">[Theory]
[InlineData("01-Jan-2017", 2, "01-Mar-2017")]
[InlineData("01-Jan-2017", 0, "01-Jan-2017")]
[InlineData("01-Jan-2017", 27, "01-Apr-2019")]
public void MonthsFromDateReturnsExpected(
    string startDateString,
    int monthsFromNow,
    string endDateString)
{
    var startDate = DateTime.Parse(startDateString);
    var endDate = DateTime.Parse(endDateString);

    var actual = DateRange.MonthsFromDate(startDate, monthsFromNow);

    Assert.Equal(startDate, actual.StartDate);
    Assert.Equal(endDate, actual.EndDate);
}
</code></pre>

<p>I can think if two ways to solve the above problem. One is to refactor the test code and the other to refactor the DateRange class itself. Both methods involve creating the expected DateRange object upfront and then comparing against it for equality. The tests can be refactored using <a href="https://www.nuget.org/packages/SemanticComparison">SemanticComparison</a> library.</p>

<pre><code class="csharp Refactor Test using SemanticComparison">[Theory]
[InlineData("01-Jan-2017", 2, "01-Mar-2017")]
[InlineData("01-Jan-2017", 0, "01-Jan-2017")]
[InlineData("01-Jan-2017", 27, "01-Apr-2019")]
public void MonthsFromDateReturnsExpectedUsingSemanticComparison(
   string startDateString,
   int monthsFromNow,
   string endDateString)
{
    var startDate = DateTime.Parse(startDateString);
    var endDate = DateTime.Parse(endDateString);
    var expected = new DateRange(startDate, endDate);

    var actual = DateRange.MonthsFromDate(startDate, monthsFromNow);

    expected
        .AsSource()
        .OfLikeness&lt;DateRange&gt;()
        .ShouldEqual(actual);
}
</code></pre>

<p>In this particular case looking closely at the <a href="http://xunitpatterns.com/SUT.html">system under test (SUT)</a>, the DateRange class, we understand that it can be a <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Value Object</a>. Any two instances of DateRange with the same start and end date can be considered equal. Equality is based on the value contained and not on any other identity. Though in all cases that you observe this behavior it might not be possible for you to convert it into a value object. In those case use the approach mentioned below. But in cases where you have control over it, override <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Equals and GetHashCode</a> to implement value equality. The test is much simpler and had less code</p>

<pre><code class="csharp Refactor DateRange to ValueObject">[Theory]
[InlineData("01-Jan-2017", 2, "01-Mar-2017")]
[InlineData("01-Jan-2017", 0, "01-Jan-2017")]
[InlineData("01-Jan-2017", 27, "01-Apr-2019")]
public void MonthsFromDateReturnsExpectedUsingValueObject(
   string startDateString,
   int monthsFromNow,
   string endDateString)
{
    var startDate = DateTime.Parse(startDateString);
    var endDate = DateTime.Parse(endDateString);
    var expected = new DateRange(startDate, endDate);

    var actual = DateRange.MonthsFromDate(startDate, monthsFromNow);

    Assert.Equal(expected, actual);
}
</code></pre>

<h3>Complicated Test Setup and Test Code Duplication</h3>

<p>At times we run into cases where setting up the sut is complicated and is a lot of code. Complicated setup often leads to <a href="http://xunitpatterns.com/Test%20Code%20Duplication.html">Test code duplication</a>.</p>

<blockquote><p><em>A complicated test setup warrants &lsquo;</em>cut-copy-paste<em>&rsquo; to test different aspects of the sut.</em></p></blockquote>

<p>From my experience, I have seen this happen more for the test setup phase. The test setup phase is identical across a set of tests with only the assertions being different. Let us look into some common reasons why test setup can becoming complicated leading to test code duplication as well.</p>

<h4><strong>Violating Single Responsibility Principle (SRP)</strong></h4>

<p>The test setup can get complicated when the sut violates Single Responsibility Principle (SRP). When there are too many things that are getting affected by the sut, the setup and the verification phases become complex. In these cases extracting the responsibilities as injected dependencies help reduce complexity. The tests can then use mocks to test the sut in isolation. The post, <a href="http://www.rahulpnath.com/blog/refactoring-to-improve-testability-extracting-dependencies/">Refactoring to Improve Testability: Extracting Dependencies</a> looks into an end to end scenario of this case and how it can be improved.</p>

<p>Violating SRP also leads to test code duplication as multiple aspects need testing and the setup looks almost similar. Refactoring the sut and the test code are ways that test code can be made more robust in these cases.</p>

<h4><strong>SUT Constraints</strong></h4>

<p>Test Code Duplication can occur when there are constraints on a constructor, and the test needs to construct it. Let&rsquo;s take the example of DateRange class we saw above. The DateRange constructor takes in two dates, startDate and endDate. But the constructor has a rule enforced that endDate must be greater than startDate. In such cases, I often see tests that have DateRange as a property directly or indirectly (as properties on other objects) creating them explicitly.</p>

<pre><code class="csharp Explicitly create objects with Constraints">[Theory]
[InlineData("1 Jan 2016", "1 Mar 2016", "20 Feb 2016")]
[InlineData("11 Apr 2016", "30 Mar 2017", "26 Dec 2016")]
public void DateInBetweenStartAndEndDateIsInRangeManualSetup(
    string startDateString,
    string endDateString,
    string dateInBetween)
{
    var startDate = DateTime.Parse(startDateString);
    var endDate = DateTime.Parse(endDateString);
    var date = DateTime.Parse(dateInBetween);
    var sut = new DateRange(startDate, endDate);

    var actual = sut.IsInRange(date);

    Assert.True(actual);
}
</code></pre>

<p>We cannot depend on the default behavior of AutoFixture to generate a DateRange object for us, as it does not know about this constraint and will always pass two random dates to the constructor. The below test is not repeatable and can fail at times if AutoFixture sends the endDate less than the start date.</p>

<pre><code class="csharp Using AutoFixture on classes that have constraints can lead to tests that are not repeatable">[Theory]
[InlineAutoData]
public void DateInBetweenStartAndEndDateIsInRange(DateRange sut)
{
    var rand = new Random();
    var date = sut.StartDate.AddDays(rand.Next(0, (sut.EndDate - sut.StartDate).Days - 1));
    var actual = sut.IsInRange(date);

    Assert.True(actual);
}
</code></pre>

<p>To make the test repeatable, we must be able to generate a DateRange class successfully every time we ask AutoFixture for one. For this, we add a DateRange <a href="https://github.com/AutoFixture/AutoFixture/wiki/Internal-Architecture">customization and plug it into the Fixture creation pipeline</a>. The customization makes sure that the DateRange class constructor parameters match the constraints.</p>

<pre><code class="csharp DateRange AutoFixture Customization">public class InlineCustomizedAutoDataAttribute : AutoDataAttribute
{
    public InlineCustomizedAutoDataAttribute()
        : base(new Fixture().Customize(new DateRangeCustomization()))
    {
    }
}

public class DateRangeCustomization : ICustomization
{
    public void Customize(IFixture fixture)
    {
        fixture.Customizations.Add(new DateRangeSpecimenBuilder());
    }
}
public class DateRangeSpecimenBuilder : ISpecimenBuilder
{
    public object Create(object request, ISpecimenContext context)
    {
        var requestAsType = request as Type;
        if (typeof(DateRange).Equals(requestAsType))
        {
            var startTime = context.Create&lt;DateTime&gt;();
            var range = context.Create&lt;uint&gt;();
            return new DateRange(startTime, startTime.AddDays(range));
        }

        return new NoSpecimen();
    }
}
</code></pre>

<p>The tests can now be updated to use the <em>InlineCustomizedAutoDataAttribute</em> instead of the default <em>InlineAutoDataAttribute</em>. The tests are repeatable now as we can be sure that AutoFixture will always generate a valid DateRange object.</p>

<h3>Public vs. Private for Tests</h3>

<p>It often happens that we get into discussions on whether a function should be private or public. We think it is a bad idea to write production code in a way to suit tests. To test private methods, you can employ techniques of reflection or use <a href="https://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.internalsvisibletoattribute">InternalsVisibleTo attribute</a>. But this is a smell in itself.</p>

<p>Tests should be through public API of the class. If it gets difficult to test through the API, it hints that the code is dealing with different responsibilities or has too many dependencies.</p>

<blockquote><p><em>There are valid use cases for the private and internal access modifiers, but the majority of the time I see private and internal code, it merely smells of poor design. If you change the design, you could make types and members public, and feel good about it.</em></p>

<p>-<a href="http://blog.ploeh.dk/2015/09/22/unit-testing-internals/"><em>Unit Testing Internals, Mark Seemann</em></a></p></blockquote>

<p>Consider refactoring your code so that it is easier to test. Tests are the first consumers of code, and it helps shape the public API and the way it gets consumed. It is fine to have tests affect the way you write code. What is not fine is to have explicit loops within the production code, just for test code. The problem with having such code is that the other code loop never gets tested.</p>

<p>Tests act as a feedback tool and it is important that you listen to it. If you decide to bear the pain of writing tests ignoring the feedback just to meet some <a href="http://www.rahulpnath.com/blog/is-code-coverage-a-lie/">code coverage numbers</a> then you are doing it wrong. Most of the cases you will end up with hard to maintain code and fragile tests. Listen to the feedback and incorporate it into the code you write.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tip of the Week: AutoFixture - Make Your Unit Tests Robust]]></title>
    <link href="http://rahulpnath.com/blog/autofixture-make-your-unit-tests-robust/"/>
    <updated>2017-04-06T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/autofixture-make-your-unit-tests-robust</id>
    <content type="html"><![CDATA[<blockquote><p><em><a href="https://github.com/AutoFixture/AutoFixture">AutoFixture</a> is an open source library for .NET designed to minimize the &lsquo;<a href="http://wiki.c2.com/?ArrangeActAssert">Arrange</a>&rsquo; phase of your unit tests in order to maximize maintainability. Its primary goal is to allow developers to focus on what is being tested rather than how to setup the test scenario, by making it easier to create object graphs containing test data.</em></p></blockquote>

<p><img alt ="AutoFixture" class = "center" src="/images/autofixture.jpg" /></p>

<p>If you are on .NET platform and write tests (there is no reason you wouldn&rsquo;t) you should check out AutoFixture. AutoFixture makes test data setup easy. It is a generalization of the <a href="http://www.natpryce.com/articles/000714.html">Test Data Builder</a> pattern and helps make your tests more robust and maintainable. Below is a sample (as taken from the GitHub page) shows how minimal setup is required for testing. Check out the post, <a href="http://www.rahulpnath.com/blog/refactoring-test-code-removing-constructor-dependency/">Refactoring Test Code: Removing Constructor Dependency</a> to see in detail how AutoFixture can be used to make the tests more stable against changes.</p>

<pre><code class="csharp">[Theory, AutoData]
public void IntroductoryTest(
    int expectedNumber, MyClass sut)
{
    int result = sut.Echo(expectedNumber);
    Assert.Equal(expectedNumber, result);
}
</code></pre>

<p>If you are new to AutoFixture, I highly recommend checking out the <a href="https://github.com/AutoFixture/AutoFixture/wiki/Cheat-Sheet">Cheat Sheet</a> to get started. Check out my post on <a href="http://www.rahulpnath.com/blog/populating-data-for-tests/">Populating Data for Tests</a> for some common patterns of using AutoFixture and how it can reduce setup code. Understanding the <a href="https://github.com/AutoFixture/AutoFixture/wiki/Internal-Architecture">Internal Architecture</a> of AutoFixture helps if you want to extend it for customization. AutoFixture integrates well with the different testing frameworks and support libraries that are popular. I mostly use it with <a href="https://xunit.github.io/">xUnit</a> and <a href="https://github.com/Moq/moq4/wiki/Quickstart">Moq</a>.</p>

<p>Hope this helps with your testing!</p>

<p><em>I am happy to have <a href="https://github.com/AutoFixture/AutoFixture/pulls?q=is:pr+is:closed+author:rahulpnath">contributed</a> (minor) to such a great library.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Populating Data for Tests]]></title>
    <link href="http://rahulpnath.com/blog/populating-data-for-tests/"/>
    <updated>2017-03-07T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/populating-data-for-tests</id>
    <content type="html"><![CDATA[<p>Populating data for tests is the section of the test that usually ends up making tests more coupled with the code that it is testing. Coupling makes tests more fragile and refactoring code harder because of breaking tests. We should try to avoid coupling with the implementation details when writing tests. Let us see a few options that we have to populate test data and constructing object graphs (chain of objects branched off from the root object). I use <a href="https://xunit.github.io/">xUnit.net</a> as my test framework, but you can use these techniques in your choice of framework.</p>

<p><a href="http://xunitpatterns.com/Data-Driven%20Test.html" class="center" title="Image from xUnit Test Patterns"><img class="center" alt="Populating Test Data" src="/images\test_data.gif" /></a></p>

<p>Let&rsquo;s start with some simple tests on a Customer class shown below.</p>

<pre><code class="csharp">public class Customer
{
    public Guid Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string FullName
    {
        get { return FirstName + " " + LastName; }
    }

    public Address Address { get; set; }
}
</code></pre>

<p>Let&rsquo;s say we need to test that the FullName property returns as expected. We will use a <em>Theory</em> type tests for testing different combinations of first and last name. xUnit.net includes support for two different major types of unit tests: facts and theories</p>

<blockquote><p><em>Facts are tests which are always true. They test invariant conditions.</em></p>

<p><em>Theories are tests which are only true for a particular set of data.</em></p></blockquote>

<p>Theories allow us to create parameterized tests with which we can run a given test with different parameter options. Like in this example we need to test the Customer class with different set of First and Last Name combinations. As you can see below the test is attributed with Theory Attribute, and we use the InlineData attribute to pass static values to the test. Using these parameters we are now able to test for different combinations of first and last names. The test populates only the required properties on Customer object for testing FullName.</p>

<pre><code class="csharp">[Theory]
[InlineData("Adobe", "Photoshop", "Adobe Photoshop")]
[InlineData("Visual", "Studio", "Visual Studio")]
[InlineData("Rode", "Podcaster", "Rode Podcaster")]
public void CustomerFullNameReturnsExpected(string firstName, string lastName, string expected)
{
    // Fixture setup
    var customer = new Customer() { FirstName = firstName, LastName = lastName };
    // Exercise system
    var actual = customer.FullName;
    // Verify outcome
    Assert.Equal(expected, actual);
    // Teardown
}
</code></pre>

<blockquote><p><em>Tests help refine the public API as they are the first consumers</em></p></blockquote>

<p>The tests above acts as a clue indicating that the three properties - FirstName, LastName, FullName are related and go hand-in-hand. These tests are a strong indication that these properties can be grouped together into a class and possibly tested separately. We can extract these properties into a <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Value Object</a> for e.g. Name. I will not go into the implementation details of that, and I hope you can do that you own.</p>

<p>The above tests still have a high dependency on the code that it is testing - <strong><em>the constructor</em></strong>. Imagine if we had a lot of such tests that constructs the Consumer class inline in the setup phase. All tests will break if the class constructor changes. We saw in the <a href="http://www.rahulpnath.com/blog/refactoring-test-code-removing-constructor-dependency/">refactoring to remove constructor dependency</a> how to remove such dependencies and make the tests independent of the constructor dependencies.  We can introduce Object Mother or Test Data Builder pattern as mentioned in the article. Optimizing further we can also use <a href="https://github.com/AutoFixture/AutoFixture">AutoFixture</a> to generate test data. Moving into these patterns or AutoFixture brings in an added benefit as well; the rest of properties on the Customer class also gets populated by default.</p>

<h3>Explicitly Setting Properties</h3>

<p>By introducing AutoFixture, we no longer need to create the Customer object explicitly. We can use the Fixture class generate a Customer class for us. Using AutoFixture, this can be achieved in at least two ways (I am not sure if there are more ways of doing this).</p>

<pre><code class="csharp Using Fixture class">[Theory]
[InlineData("Adobe", "Photoshop", "Adobe Photoshop")]
[InlineData("Visual", "Studio", "Visual Studio")]
[InlineData("Rode", "Podcaster", "Rode Podcaster")]
public void CustomerFullNameReturnsExpected(string firstName, string lastName, string expected)
{
    // Fixture setup
    var fixture = new Fixture();
    var customer = fixture.Build&lt;Customer&gt;()
        .With(a =&gt; a.FirstName, firstName)
        .With(a =&gt; a.LastName, lastName)
        .Create();
    // Exercise system
    var actual = customer.FullName;
    // Verify outcome
    Assert.Equal(expected, actual);
    // Teardown
}
</code></pre>

<pre><code class="csharp Using Injected Object">[Theory]
[InlineAutoData("Adobe", "Photoshop", "Adobe Photoshop")]
[InlineAutoData("Visual", "Studio", "Visual Studio")]
[InlineAutoData("Rode", "Podcaster", "Rode Podcaster")]
public void CustomerFullNameReturnsExpected(string firstName, string lastName, string expected, Customer customer)
{
    // Fixture setup
    customer.FirstName = firstName;
    customer.LastName = lastName;
    // Exercise system
    var actual = customer.FullName;
    // Verify outcome
    Assert.Equal(expected, actual);
    // Teardown
}
</code></pre>

<p>In both cases, we explicitly set the required properties. The above test is similar to the previous test that we wrote without AutoFixture. But no longer are we dependent on the constructor. In the second way of using AutoFixture I used <em>InlineAutoData</em> attribute, that is part of <em>Ploeh.AutoFixture.Xunit2</em>. This attribute automatically does the fixture initialization and injects the Customer object for us. For all the values that it can match from the inline parameter list, it uses the provided values. It starts generating random values once all the parameters passed inline are used. In this case, only Customer object is created by AutoFixture.</p>

<h3>AutoFixture and Immutable types</h3>

<p>When using immutable types or properties with private setters, we cannot set the property value after it is created.</p>

<blockquote><p><em>AutoFixture was originally build as a tool for Test-Driven Development (TDD), and TDD is all about feedback. In the spirit of GOOS, you should listen to your tests. If the tests are hard to write, you should consider your API design. AutoFixture tends to amplify that sort of feedback.</em></p>

<p>-<em><a href="http://stackoverflow.com/a/20816487/1948745">Mark Seemann</a> (creator of AutoFixture)</em></p></blockquote>

<p>In these cases, the suggested approach is something closer to the manual <a href="http://www.natpryce.com/articles/000714.html">Test Data Builder</a> we saw in the <a href="http://www.rahulpnath.com/blog/refactoring-test-code-removing-constructor-dependency/">refactoring example</a>. We can either have an explicit test data builder class or define extension methods on the immutable type such that it changes just the specified property and returns all other values same, as shown below.</p>

<pre><code class="csharp">public class Name
{
    public readonly string FirstName;
    public readonly string LastName;
    public string FullName
    {
        get
        {
            return FirstName + " " + LastName;
        }
    }

    public Name(string firstName, string lastName)
    {
        // Enforce parameter constraints
        FirstName = firstName;
        LastName = lastName;
    }

    public Name WithFirstName(string firstName)
    {
        return new Name(firstName, this.LastName);
    }
}
</code></pre>

<p>As shown the <em>WithFirstName</em> method returns a new Name class with just the first name changed. Again we do not need these <em>WithXXX</em> methods for all the properties. Only when there is a need to change any of the property values as part of the requirement do we need to introduce such methods and even test it. This again drives to the above point of using tests to guide the API design, from the feedback.</p>

<h3>Customization</h3>

<p>In cases where we have validations in constructor to hold the class constraints, we cannot rely on the random values generated by AutoFixture. For example.
- The string should be at least ten characters in length for a Name class
- Start date should be less than the End date for a date range class</p>

<p>Without any custom code if we are to rely on AutoFixture to generate us, such classes, the tests will not be predictable. Depending on the random value that AutoFixture generates it might create a valid instance or throw an exception. To make this consistent, we can add Customization to ensure predictability.</p>

<p>For the DateRange class below we can add the following Customization.</p>

<pre><code class="csharp">public class DateRange
{
    public readonly DateTime EndDate;
    public readonly DateTime StartDate;

    public DateRange(DateTime startDate, DateTime endDate)
    {
        if (endDate &lt; startDate)
            throw new Exception("End date cannot be less than the start date");

        StartDate = startDate;
        EndDate = endDate;
    }
}
</code></pre>

<pre><code class="csharp DateRange Customization">public class DateRangeCustomization : ICustomization
{
    public void Customize(IFixture fixture)
    {
        fixture.Customizations.Add(new DateRangeSpecimenBuilder());
    }
}

public class DateRangeSpecimenBuilder : ISpecimenBuilder
{
    public object Create(object request, ISpecimenContext context)
    {
        var requestAsType = request as Type;
        if (typeof(DateRange).Equals(requestAsType))
        {
            var times = context.CreateMany&lt;DateTime&gt;();
            return new DateRange(times.Min(), times.Max());
        }

        return new NoSpecimen();
    }
}
</code></pre>

<p>The customization gets invoked every time a DateRange object is requested using the fixture. It then invokes this custom code that we have added in and creates a valid DateRange object. For the tests use the customization as part of the fixture either using a custom data attribute or explicitly adding the customization into the Fixture class.</p>

<h3>Mocking behavior</h3>

<p><a href="http://xunitpatterns.com/Mock%20Object.html">Mock Objects</a> is a popular way to unit test classes in isolation. For the external dependencies that a <a href="http://xunitpatterns.com/SUT.html">System Under Test</a> (SUT) has, the dependencies are mocked using a mocking framework. In these cases, we can setup the external dependencies to return different values as we expect for different tests and test the logic of the SUT and how it responds. Such tests are usually more coupled with the implementation as we have to setup the mocks prior. So we need to have an understanding of the return values expected from dependencies and the parameters expected by the dependencies. I use Moq framework for mocking, and AutoFixture has a library that helps integrate well with it.</p>

<pre><code class="csharp">public HttpResponseMessage Get(Guid id)
{
    var customer = CustomerRepository.Get(id);

    if (customer == null)
        return Request.CreateResponse(HttpStatusCode.NotFound, "Customer not Found with id " + id);

    return Request.CreateResponse(HttpStatusCode.OK, customer);
}
</code></pre>

<pre><code class="csharp">[Theory]
[InlineAutoMoqData]
public void CustomerControllerGetWithNoCustomerReturnsNotFound(
    Guid customerId,
    [Frozen]Mock&lt;ICustomerRepository&gt; customerRepository,
    CustomerController sut)
{
    // Fixture setup
    customerRepository.Setup(a =&gt; a.Get(customerId)).Returns(null);
    var expected = HttpStatusCode.NotFound;

    // Exercise system
    var actual = sut.Get(customerId).StatusCode;

    // Verify outcome
    Assert.Equal(expected, actual);
}
</code></pre>

<p>The tests above uses <a href="http://blog.nikosbaxevanis.com/2012/07/31/autofixture-xunit-net-and-auto-mocking/">InlineAutoMoqData attribute</a> which is a customized xUnit data attribute that uses Moq framework to inject dependencies. The Mock<ICustomerRepository> represents a mocked interface implementation. Behavior is setup on the mock using the Setup method. By using <a href="http://blog.ploeh.dk/2010/03/17/AutoFixtureFreeze/">Frozen</a> attribute for the Mock parameter, we tell AutoFixture to create only one instance of the mocked object and then use the same instance for any future requests of that type. This forces the same instance of the repository to be injected into the CustomerController class as well when it asks for a ICustomerRepository to AutoFixture.</p>

<p>Creating test data is an important aspect of any test. Making sure that you minimize the dependencies on the implementation detail is important to make your tests more robust. This allows the code to be refactored as long as some of the core contracts that we are testing remain the same. AutoFixture helps minimize the code in <a href="http://xunitpatterns.com/Four%20Phase%20Test.html">Fixture Setup phase</a>, which otherwise tends to grow bigger. Hope this helps you with your tests!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduce Tests when Fixing Bugs]]></title>
    <link href="http://rahulpnath.com/blog/introduce-tests-when-fixing-bugs/"/>
    <updated>2016-09-26T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/introduce-tests-when-fixing-bugs</id>
    <content type="html"><![CDATA[<p><em>When creating a subscription for a client, the calculated number of months was off by one at times</em> - This was a bug reported from production application that I was currently working on. Though, not a blocker, it was creating enough issues for the end users that it required a hotfix. One of my friends picked this issue up and started working on it. A while later, while I was checking the status of that bug I noticed him playing around with  <a href="https://www.linqpad.net/">Linqpad</a>. He was testing a method to calculate the number of months between two dates with different values.</p>

<p><a href="https://www.flickr.com/photos/toomore/23066277453" class="center" title="Image By Toomore Chiang, from https://www.flickr.com/photos/toomore/23066277453"><img src="/images\testing.jpg" class="center" alt="Testing"></a></p>

<p>We often test our code elsewhere because it&rsquo;s coupled with other code making it difficult to test at the source itself. The fact that we need to test an isolated part of a larger piece of code is a &lsquo;<a href="https://en.wikipedia.org/wiki/Code_smell">Code smell</a>&rsquo;. There possibly is a class or method that can be extracted and unit tested separately.</p>

<blockquote><p><em>Having to test code elsewhere other than the source is a Smell. Look for a method or class waiting to be extracted</em></p></blockquote>

<p>In this specific case, below is how the code that calculates month difference between two dates looked like. As you can see below, the code is coupled with the newAccount, which in turn is coupled with a few other entities that I have omitted. Added to this, this method existed in an MVC controller, which had other dependencies.</p>

<pre><code class="csharp Existing Code">...
var date1 = newAccount.StartDate;
var date2 = newAccount.EndDate;
int monthsApart = Math.Abs(12 * (date1.Year - date2.Year) + date1.Month - date2.Month) - 1;
decimal daysInMonth1 = DateTime.DaysInMonth(date1.Year, date1.Month);
decimal daysInMonth2 = DateTime.DaysInMonth(date2.Year, date2.Month);
decimal dayPercentage = ((daysInMonth1 - date1.Day) / daysInMonth1)
                      + (date2.Day / daysInMonth2);
var months = (int)Math.Ceiling(monthsApart + dayPercentage);
...
</code></pre>

<p>This explains why it was easier to copy this code across and test it in Linqpad. It was difficult to construct the whole hierarchy of objects and to test this. So the easiest thing to fix the bug in is to test elsewhere and fit back in its original place.</p>

<h3>Extract Method Refactoring</h3>

<p>This is one of the scenario where <a href="http://refactoring.com/catalog/extractMethod.html">Extract Method</a> Refactoring fits in best. According to the definition</p>

<blockquote><p><em>You have a code fragment that can be grouped together. <strong>Turn the fragment into a method whose name explains the purpose of the method.</strong></em></p></blockquote>

<p>Extract Method Refactoring is also referred in <a href="http://www.amazon.com/gp/product/0131177052/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0131177052&amp;linkCode=as2&amp;tag=rahulpnath-20&amp;linkId=TTKEEYQLEMTOXPPQ">Working Effectively With Legacy Code</a> and <a href="http://www.amazon.com/gp/product/0131495054/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0131495054&amp;linkCode=as2&amp;tag=rahulpnath-20&amp;linkId=XR55UAOEPPMVMFK3">xUnit Test Patterns</a> (to refactor test code).  It helps separate logic from rest of the object hierarchy and test individually. In this scenario, we can extract the logic to calculate the number of months between two dates into a separate method.</p>

<p>For <a href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd">Test driving</a> the extracted method, all I do initially is to extract the method. As the method purely depends on its passed in parameters and not on any instance variables, I mark it as a static method. This removes the dependency from the MVC controller class parameters and the need to construct them in the tests . The test cases includes the failed &lsquo;off by one&rsquo; case (<em>(&ldquo;25-Aug-2017&rdquo;, &ldquo;25-Feb-2018&rdquo;, 6)</em>). With tests that pass and fail it&rsquo;s now safe to make changes to the extracted method to fix the failing cases.</p>

<pre><code class="csharp Tests">[Theory]
[InlineData("10-Feb-2016", "10-Mar-2016", 1)]
[InlineData("10-Feb-2016", "11-Mar-2016", 2)]
[InlineData("10-Feb-2015", "11-Mar-2016", 14)]
[InlineData("01-Feb-2015", "01-Mar-2015", 1)]
[InlineData("21-Sep-2016", "22-Sep-2016", 1)]
[InlineData("25-Aug-2017", "25-Feb-2018", 6)]
[InlineData("12-Aug-2016", "15-Mar-2019", 32)]
public void MonthsToReturnsExpectedMonths(
    string date1,
    string date2,
    int expected)
{
    var actual = SubscriptionController.MonthsTo(DateTime.Parse(date1), DateTime.Parse(date2));
    Assert.Equal(expected, actual);
}
</code></pre>

<p>More than the algorithm used to solve the original issue what is more important is in identifying such scenarios and extracting them as a method. Make the least possible change to make it testable and fix step by step.</p>

<blockquote><p><em>Whenever there are code fragments that depend only on a subset of properties of your class or function inputs, it could be extracted into a separate method.</em></p></blockquote>

<pre><code class="csharp Extracted method after Refactoring.">public static int MonthsTo(DateTime date1, DateTime date2)
{
    int months = Math.Abs(12*(date1.Year - date2.Year) + date1.Month - date2.Month);
    if (date2.Date.Day &gt; date1.Date.Day)
        months = months + 1;

    return months;
}
</code></pre>

<h3>Introduce Value Object</h3>

<p>Now that we have fixed the bug and have tests covering the different combinations, let&rsquo;s see if this method can live elsewhere and make it reusable. The start date and end date on account always go together and is a domain concept that can be extracted out as an &lsquo;Account Term Range&rsquo;. It can be represented as a DateRange <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Value Object</a>. We can then introduce a method in the DateRange Value Object to return the number of months in the range. This makes the function reusable and also <a href="http://www.rahulpnath.com/blog/refactoring-to-improve-readability-separating-business-language-and-programming-language-semantics/">code more readable</a>. I made the original refactored method as an extension method on DateTime and used it from DateRange Value Object.</p>

<pre><code class="csharp Encapsulate into Value Object">public static class DateTimeExtensions 
{
    public static int MonthsTo(this DateTime date1, DateTime date2)
    {
        int months = Math.Abs(12*(date1.Year - date2.Year) + date1.Month - date2.Month);
        if (date2.Date.Day &gt; date1.Date.Day)
            months = months + 1;

        return months;
    }
}

public class DateRange
{
    public DateTime StartDate { get; private set; }
    public DateTime EndDate { get; private set; }

    public DateRange(DateTime startDate, DateTime endDate)
    {
        // Ignoring null checks
        if (endDate &lt; startDate)
            throw new ArgumentException("End Date cannot be less than Start Date");

        this.StartDate = startDate;
        this.EndDate = endDate;
    }

    public int GetMonths()
    {
        return StartDate.MonthsTo(EndDate);
    }
}
... // Rest of Value Object Code to override Equals and GetHashCode
</code></pre>

<p>If you are new to TDD or just getting started with tests, introducing tests while fixing bugs is a good place to start. This might also help make code decoupled and readable. Try <a href="http://www.rahulpnath.com/blog/is-code-coverage-a-lie/">covering a fix with tests</a> the next time you fix a bug!</p>

<h4><strong>References</strong></h4>

<div>
    <div class="row">
        <div class="col-sm-6 col-md-3">
            <div class="thumbnail">
                <a href="http://www.amazon.com/gp/product/0131495054/ref=as_li_tl?ie=UTF8&camp=1789&creative=390957&creativeASIN=0131495054&linkCode=as2&tag=rahulpnath-20&linkId=XR55UAOEPPMVMFK3">
                    <img src="http://rahulpnath.com/images/books_xunit.jpg" data-holder-rendered="true" style="display: block;">
                </a>
            </div>
        </div>
        <div class="col-sm-6 col-md-3">
            <div class="thumbnail">
                <a href="http://www.amazon.com/gp/product/0321503627/ref=as_li_tl?ie=UTF8&camp=1789&creative=390957&creativeASIN=0321503627&linkCode=as2&tag=rahulpnath-20&linkId=TR6UCCVP6CMGBBZQ">
                    <img src="http://rahulpnath.com/images/books_goos.jpeg" data-holder-rendered="true" style="display: block;">
                </a>
            </div>
        </div>
        <div class="col-sm-6 col-md-3">
            <div class="thumbnail">
                <a href="http://www.amazon.com/gp/product/0131177052/ref=as_li_tl?ie=UTF8&camp=1789&creative=390957&creativeASIN=0131177052&linkCode=as2&tag=rahulpnath-20&linkId=TTKEEYQLEMTOXPPQ">
                    <img src="http://rahulpnath.com/images/books_welc.jpg" data-holder-rendered="true" style="display: block;">
                </a>
            </div>
        </div>
    </div>
</div>

]]></content>
  </entry>
  
</feed>
