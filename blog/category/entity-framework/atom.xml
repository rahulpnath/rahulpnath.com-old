<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: entity framework | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/entity-framework/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2018-12-28T00:03:03+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Query Object Pattern and Entity Framework - Making Readable Queries]]></title>
    <link href="http://rahulpnath.com/blog/query-object-pattern-and-entity-framework-making-readable-queries/"/>
    <updated>2018-12-20T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/query-object-pattern-and-entity-framework-making-readable-queries</id>
    <content type="html"><![CDATA[<p>Search is a common requirement for most of the applications that we build today. Searching for data often includes multiple fields, data types, and data from multiple tables (especially when using a relational database). I was recently building a Search page which involved searching for Orders - users needed the ability to search by different criteria such as the employee who created the order, orders for a customer, orders between particular dates, order status, an address of delivery. Order criteria are optional, and they allow to narrow down on your search with additional parameters. We were building an API endpoint to query this data based on the parameters using EF Core backed by Azure SQL.</p>

<p>In this post, we go through the code iterations that I made to improve on the readability of the query and keep it contained in a single place. The intention is to create a Query Object like structure that contains all query logic and keep it centralized and readable.</p>

<blockquote><p><em>A <a href="https://martinfowler.com/eaaCatalog/queryObject.html">Query Object</a> is an interpreter [Gang of Four], that is, a structure of objects that can form itself into a SQL query. You can create this query by referring to classes and fields rather than tables and columns. In this way, those who write the queries can do so independently of the database schema, and changes to the schema can be localized in a single place.</em></p></blockquote>

<pre><code class="csharp Query Object capturing the Search Criteria">public class OrderSummaryQuery
{
    public int? CustomerId { get; set; }
    public DateRange DateRange { get; set; }
    public string Employee { get; set; }
    public string Address { get; set;}
    public OrderStatus OrderStatus { get; set; }
}
</code></pre>

<p>I have removed the final projection in all the queries below to keep the code to a minimum. We will go through all the iterations to make the code more readable, keeping the generated SQL query efficient as possible.</p>

<h3>Iteration 1 - Crude Form</h3>

<p>Let&rsquo;s start with the crudest form of the query stating all possible combinations of the query. Since all properties are nullable, check if a value exists before using it in the query.</p>

<pre><code class="csharp">(from order in _context.Order
join od in _context.OrderDelivery on order.Id equals od.OrderId
join customer in _context.Customer on order.CustomerId equals customer.Id
where order.Status == OrderStatus.Quote &amp;&amp;
      order.Active == true &amp;&amp;
      (query.Employee == null || 
      (order.CreatedBy == query.Employee || customer.Employee == query.Employee)) &amp;&amp;
      (!query.CustomerId.HasValue ||
      customer.Id == query.CustomerId.Value) &amp;&amp;
      (query.DateRange == null || 
      order.Created &gt;= query.DateRange.StartDate &amp;&amp; order.Created &lt;= query.DateRange.EndDate))
</code></pre>

<h3>Iteration 2 - Separating into Multiple Lines</h3>

<p>With all those explicit AND (&amp;&amp;) clauses the query is hard to understand and keep up. Splitting them into multiple where clauses make it more cleaner and keep each search criteria independent. The end SQL query that gets generated remains the same in this case.</p>

<blockquote><p><a href="https://rahulpnath.com/blog/left-align-your-code-for-better-readability/">Aesthetics of code</a> is as important as the code you write. Aligning is an important part that contributes to the overall aesthetics of code.</p></blockquote>

<pre><code class="csharp">from order in _context.Order
join od in _context.OrderDelivery on order.Id equals od.OrderId
join customer in _context.Customer on order.CustomerId equals customer.Id
where order.Status == orderStatus &amp;&amp; order.Active == true
where query.Employee == null ||
      order.CreatedBy == query.Employee || customer.Employee == query.Employee
where !query.CustomerId.HasValue || customer.Id == query.CustomerId.Value
where query.DateRange == null ||
      (order.Created &gt;= query.DateRange.StartDate &amp;&amp; order.Created &lt;= query.DateRange.EndDate)
</code></pre>

<h3>Iteration 3 - Refactor to Expressions</h3>

<p>Now that each criterion is independently visible let&rsquo;s make each of the <em>where</em> clause more readable. Refactoring them into C# class functions makes the generated SQL inefficient, as EF cannot transform C# functions into SQL.  Such conditions in a standard C# function gets evaluated on the client site, after retrieving all data from the server. Depending on the size of your data, this is something you need <a href="https://docs.microsoft.com/en-us/ef/core/querying/client-eval#client-evaluation-performance-issues">to be aware of</a>.</p>

<p>However, if you use <a href="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/ef/language-reference/expressions-in-linq-to-entities-queries">Expressions</a> those get transformed to evaluate on the server. Since all of the conditions on our where clauses can be represented as an Expression, let&rsquo;s move those to the Query object class as properties returning Expressions. Since we need data from multiple tables, the intermediate projection <em>OrderSummaryQueryResult</em> helps to work with data from the multiple tables. All our expressions take the <em>OrderSummaryQueryResult</em> projection and perform the appropriate conditions on them.</p>

<pre><code class="csharp   ">public class OrderSummaryQuery
{
    public Expression&lt;Func&lt;OrderSummaryQueryResult, bool&gt;&gt; BelongsToUser
    {
        get
        {
            return (a) =&gt; Employee == null ||
                      a.Order.CreatedBy == Employee || a.Customer.Employee == Employee;
        }
    }

    public Expression&lt;Func&lt;OrderSummaryQueryResult, bool&gt;&gt; IsActiveOrder...
    public Expression&lt;Func&lt;OrderSummaryQueryResult, bool&gt;&gt; ForCustomer...
    public Expression&lt;Func&lt;OrderSummaryQueryResult, bool&gt;&gt; InDateRange...
}
</code></pre>

<pre><code class="csharp Refactored to use Expressions ">(from order in _context.Order
 join od in _context.OrderDelivery on order.Id equals od.OrderId
 join customer in _context.Customer on order.CustomerId equals customer.Id
 select new OrderSummaryQueryResult() 
    { Customer = customer, Order =    order, OrderDelivery = od })
.Where(query.IsActiveOrder)
.Where(query.BelongsToUser)
.Where(query.ForCustomer)
.Where(query.InDateRange)
</code></pre>

<pre><code class="sql Generated SQL when order status and employee name is set">SELECT [customer].[Name] AS [Customer], [order].[OrderNumber] AS [Number],
       [od].[Address], [order].[Created] AS [CreatedDate]
FROM [Order] AS [order]
INNER JOIN [OrderDelivery] AS [od] ON [order].[Id] = [od].[OrderId]
INNER JOIN [Customer] AS [customer] ON [order].[CustomerId] = [customer].[Id]
WHERE (([order].[Active] = 1) AND ([order].[Status] = @__OrderStatus_0)) AND 
      (([order].[CreatedBy] = @__employee_1) OR ([customer].[Employee] = @__employee_2))
</code></pre>

<div class="alert alert-warning">
If you use constructor initialization for intermediate projection, *OrderSummaryQueryResult* the where clauses gets executed on the client side. So use the object initializer syntax to create the intermediate projection.
</div>


<h3>Iteration 4 - Refactoring to Extension method</h3>

<p>After the last iteration, we have a query that is easy to read and understand. We also have all queries consolidated within the query object, and it acts as a one place holding all the queries. However, something still felt not right, and I had a quick chat with my friend <a href="https://twitter.com/zpbappi">Bappi</a>, and we refined it further. The above query has too many where clauses and it was just repeating for each of the filters. To encapsulate this further, I moved all the filter expressions to be returned as an Enumerable and wrote an extension method, <em>ApplyAllFilters</em>, to execute them all.</p>

<pre><code class="csharp Expose one property for all the filters   ">public class OrderSummaryQuery
{
    public IEnumerable&lt;Expression&lt;Func&lt;OrderSummaryQueryResult, bool&gt;&gt;&gt; AllFilters
    {
        get
        {
            yield return IsActiveOrderStatus;
            yield return BelongsToUser;
            yield return BelongsToCustomer;
            yield return FallsInDateRange;
        }
    }

    private Expression&lt;Func&lt;OrderSummaryQueryResult, bool&gt;&gt; BelongsToUser...
    private Expression&lt;Func&lt;OrderSummaryQueryResult, bool&gt;&gt; IsActiveOrder...
    private Expression&lt;Func&lt;OrderSummaryQueryResult, bool&gt;&gt; ForCustomer...
    private Expression&lt;Func&lt;OrderSummaryQueryResult, bool&gt;&gt; InDateRange...
}

... 

// Extension Method on IQueryable
{
    public static IQueryable&lt;T&gt; ApplyAllFilters&lt;T&gt;(
        this IQueryable&lt;T&gt; queryable,
        IEnumerable&lt;Expression&lt;Func&lt;T, bool&gt;&gt;&gt; filters)
    {
        foreach (var filter in filters)
            queryable = queryable.Where(filter);

        return queryable;
    }
}
</code></pre>

<pre><code class="csharp">{
    (from order in _context.Order
    join od in orderDeliveries on order.Id equals od.OrderId
    join customer in _context.Customer on order.CustomerId equals customer.Id
    select new OrderSummaryQueryResult() { Customer = customer, Order = order, OrderDelivery = od })
    .ApplyAllFilters(query.AllFilters)

    ...
}
</code></pre>

<p>The search query is much more readable than what we started with in Iteration 1. One thing you should always be careful about with EF is making sure that the generated SQL is optimized and you are across what gets executed on the server and the client. Using a SQL Profiler or <a href="https://docs.microsoft.com/en-us/ef/core/miscellaneous/logging">configure logging</a> to see the generated SQL. You can also <a href="https://docs.microsoft.com/en-us/ef/core/querying/client-eval#optional-behavior-throw-an-exception-for-client-evaluation">configure to throw an exception</a> (in your development environment) for client evaluation.</p>

<p>Hope this helps to write cleaner and readable queries. Sound off in the comments if you have thoughts on refining this further or of any other patterns that you use.</p>
]]></content>
  </entry>
  
</feed>
