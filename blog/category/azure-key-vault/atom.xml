<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: azure key vault | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/azure-key-vault/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2017-06-27T00:02:07+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Azure Key Vault From Node.js]]></title>
    <link href="http://rahulpnath.com/blog/azure-key-vault-from-node-dot-js/"/>
    <updated>2017-06-12T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/azure-key-vault-from-node-dot-js</id>
    <content type="html"><![CDATA[<p><img src="/images/nodejs_keyvault.png" alt="Azure Key Vault from Node js" class="center" /></p>

<p>If you develop on Node.js, you can use the <a href="https://github.com/Azure/azure-sdk-for-node">Azure SDK for Node</a> that makes it easy to consume and manage Microsoft Azure Services. In this post let&rsquo;s explore how to use the node SDK to connect to Azure Key Vault and interact with the vault objects. If you are new to key vault check out my <a href="http://www.rahulpnath.com/blog/category/azure-key-vault/">other posts here to get started</a>.</p>

<p>The <a href="https://www.npmjs.com/package/azure-keyvault">azure-keyvault</a> npm (node package manager) package allows accessing keys, secrets, and certificates on Azure Key Vault. It required Node.js version 6.x.x or higher. You can get the <a href="https://nodejs.org/en/">latest Node.js version here</a>.</p>

<blockquote><p><strong>Package Features</strong></p>

<ul>
<li><p><em>Manage keys: create, import, update, delete, backup, restore, list and get.</em></p></li>
<li><p><em>Key operations: sign, verify, encrypt, decrypt, wrap, unwrap.</em></p></li>
<li><p><em>Secret operations: set, get, update and list.</em></p></li>
<li><p><em>Certificate operations: create, get, update, import, list, and manage contacts and issuers.</em></p></li>
</ul>
</blockquote>

<p>It is easy to setup a new project and execute code using Node. The ease of setup is one of the things that I liked about node. To try out the Key Vault package, you can start fresh in a new folder and create a javascript file - <em>main.js</em> (you can name it anything you want).</p>

<p>The following packages are <em>required</em> to connect to the vault and authenticate. The <em><a href="https://www.npmjs.com/package/azure-keyvault">azure-keyvault</a></em> package as we saw above provides capabilities to interact with the vault. The <a href="https://www.npmjs.com/package/adal-node"><em>adal-node</em></a> is the Windows Active Directory Authentication Library for Node. The package makes it easy to authenticate to AAD to access AAD protected web resources. Applications using key vault need to <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">authenticate using a token from an Azure AD Application</a>.</p>

<pre><code class="js">const KeyVault = require('azure-keyvault');
const { AuthenticationContext } = require('adal-node')
</code></pre>

<h4><strong>Authenticate Using ClientId and Secret</strong></h4>

<p>Create the Azure AD application and the Secret key as shown in <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">this post</a>. Grab the ClientId and Secret for authentication from the node application.</p>

<pre><code class="js">const clientId = "CLIENT ID";
const secret = "SECRET";

var secretAuthenticator = function (challenge, callback) {

    var context = new AuthenticationContext(challenge.authorization);
    return context.acquireTokenWithClientCredentials(
        challenge.resource,
        clientId,
        secret,
        function (err, tokenResponse) {
            if (err) throw err;

            var authorizationValue = tokenResponse.tokenType + ' ' + tokenResponse.accessToken;
            return callback(null, authorizationValue);
        });
};
</code></pre>

<p>To access the vault, we need to create an instance of the KeyVaultClient object which taken in a Credentials as shown below. The KeyVaultClient has different methods exposes to interact with keys, secrets, and certificates in the vault. For e.g. To retrieve a secret from the vault the <em>getSecret</em> method is used passing in the secret identifier.</p>

<pre><code class="js">const secretUrl = "https://rahulkeyvault.vault.azure.net/secrets/ApiKey/b56396d7a46f4f848481de2e149ef069";
var credentials = new KeyVault.KeyVaultCredentials(secretAuthenticator);
var client = new KeyVault.KeyVaultClient(credentials);

client.getSecret(secretUrl, function (err, result) {
    if (err) throw err;

    console.log(result);
});
</code></pre>

<h4><strong>Authenticate Using ClientId and Certificate</strong></h4>

<p>To authenticate using ClientId and Certificate the AuthenticationContext exposes a function <em>acquireTokenWithClientCertificate</em> which takes in the certificate (pem format) and the certificate thumbprint. If you already have a certificate go ahead and use that. If not create a new test certificate as shown below</p>

<pre><code class="bash">makecert -sv mykey.pvk -n "cn=AD Test Vault Application" ADTestVaultApplication.cer -b 03/03/2017 -e 06/05/2018 -r
pvk2pfx -pvk mykey.pvk -spc ADTestVaultApplication.cer -pfx ADTestVaultApplication.pfx -po test
</code></pre>

<p>Create a new AD application and set it to use certificate authentication. Assign the application permissions to access the key vault.</p>

<pre><code class="powershell">$certificateFilePath = "C:\certificates\ADTestVaultApplication.cer"
$certificate = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
$certificate.Import($certificateFilePath)
$rawCertificateData = $certificate.GetRawCertData()
$credential = [System.Convert]::ToBase64String($rawCertificateData)
$startDate= [System.DateTime]::Now
$endDate = $startDate.AddYears(1)
$adApplication = New-AzureRmADApplication -DisplayName "CertAdApplication" -HomePage  "http://www.test.com" -IdentifierUris "http://www.test.com" -CertValue $credential  -StartDate $startDate -EndDate $endDate

$servicePrincipal = New-AzureRmADServicePrincipal -ApplicationId $adApplication.ApplicationId

Set-AzureRmKeyVaultAccessPolicy -VaultName 'RahulKeyVault' -ServicePrincipalName $servicePrincipal.ServicePrincipalNames[0] -PermissionsToSecrets all -PermissionToKeys all 
</code></pre>

<p>To convert the pvk file into the pem format that is required by adal-node to authenticate with the AD application use the below command.</p>

<pre><code class="bash">openssl rsa -inform pvk -in mykey.pvk -outform pem -out mykey.pem
</code></pre>

<p>Using the pem encoded certificate private key, we can authenticate with the vault as shown below.</p>

<pre><code class="js">function getPrivateKey(filename) {
    var privatePem = fs.readFileSync(filename, { encoding: 'utf8' });
    return privatePem;
}

var certificateAuthenticator = function (challenge, callback) {
    var context = new AuthenticationContext(challenge.authorization);

    return context.acquireTokenWithClientCertificate(
        challenge.resource,
        clientId,
        getPrivateKey("mykey.pem"),
        "CERTIFICATE THUMBPRINT",
        function (err, tokenResponse) {
            if (err) throw err;

            var authorizationValue = tokenResponse.tokenType + ' ' + tokenResponse.accessToken;
            return callback(null, authorizationValue);
        }
    )
};
</code></pre>

<p>Using the <em>certificateAuthenticator</em> is the same as using the <em>secretAuthenticator</em>, by passing it to <em>KeyVaultCredentials</em></p>

<pre><code class="js">var credentials = new KeyVault.KeyVaultCredentials(certificateAuthenticator);
var client = new KeyVault.KeyVaultClient(credentials);

client.getSecret(secretUrl, function (err, result) {
    if (err) throw err;

    console.log(result);
});
</code></pre>

<p>To run the application first run <em>npm install</em> to install all the required packages and then execute the js file using <em>node main.js</em>. It fetches the secret value from the key vault using the certificate or secret authenticator. Hope this helps you to get started with Azure Key Vault from Node.js.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Azure Key Vault From Azure Functions - Certificate Based Authentication]]></title>
    <link href="http://rahulpnath.com/blog/azure-key-vault-from-azure-functions-certificate-based-authentication/"/>
    <updated>2017-05-25T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/azure-key-vault-from-azure-functions-certificate-based-authentication</id>
    <content type="html"><![CDATA[<p>In the previous post we saw how to connect to <a href="/blog/azure-key-vault-from-azure-functions/">Azure Key Vault from Azure Functions</a>. We used the <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">Application Id and Secret to authenticate with the Azure AD Application</a>. Since the general recommendation is to use certificate-based authentication, in this post, we will see how we can use certificates to authenticate from within an Azure Function.</p>

<p>First, we need to create an Azure AD application and set it up to use certificate-based authentication. Create a new service principal for the AD application and associate that with the Azure Key Vault. Authorize the AD application with the permissions required. In this case, I am providing all access to keys and secrets.</p>

<pre><code class="powershell">$certificateFilePath = "C:\certificates\ADTestVaultApplication.cer"
$certificate = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
$certificate.Import($certificateFilePath)
$rawCertificateData = $certificate.GetRawCertData()
$credential = [System.Convert]::ToBase64String($rawCertificateData)
$startDate= [System.DateTime]::Now
$endDate = $startDate.AddYears(1)
$adApplication = New-AzureRmADApplication -DisplayName "CertAdApplication" -HomePage  "http://www.test.com" -IdentifierUris "http://www.test.com" -CertValue $credential  -StartDate $startDate -EndDate $endDate

$servicePrincipal = New-AzureRmADServicePrincipal -ApplicationId $adApplication.ApplicationId

Set-AzureRmKeyVaultAccessPolicy -VaultName 'RahulKeyVault' -ServicePrincipalName $servicePrincipal.ServicePrincipalNames[0] -PermissionsToSecrets all -PermissionToKeys all 
</code></pre>

<p>Create an Azure Function App under your subscription as shown below. You can also use the same application created in the previous post (if you did create one).</p>

<p><img src="/images/azureFunction_newFunctionApp.png" alt="Azure Function New App" class="center" /></p>

<p>In the Function Apps page, select the app just created. Add a new function like in the last post. Selecting the Function App shows the available set of actions. Under the <em>Platform Features</em> tab we can upload the SSL certificates first and then update the Application Certificates to make the certificate available for the function.</p>

<p><img src="/images/azureFunction_PlatformFeatures.png" alt="Azure Function Platform Features" class="center" /></p>

<p>Upload the certificate by selecting it from your folder system.</p>

<p><img src="/images/azureFunction_addCertificate.png" alt="Azure Function Upload Certificate" class="center" /></p>

<p>For the certificate to be available for use in the Azure Functions an entry should be present in Application Settings. Under <em>Application Settings</em> in the <em>Platform Features</em> tab add App settings key and value - <em>WEBSITE_LOAD_CERTIFICATES</em> and the certificate thumbprint This makes the certificate available for consumption within the function. Multiple thumbprints can be specified comma separated if required.</p>

<p><img src="/images/azureFunction_AppSetting.png" alt="Azure Function Certificates App Settings" class="center" /></p>

<p>Using a certificate to authenticate with the Key Vault is the same as we have <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">seen before</a>.</p>

<pre><code class="csharp">using System;
using Microsoft.Azure.KeyVault;
using Microsoft.IdentityModel.Clients.ActiveDirectory;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;

private const string applicationId = "AD Application ID";
private const string certificateThumbprint = "Certificate Thumbprint";

public async static Task Run(TimerInfo myTimer, TraceWriter log)
{
    var keyClient = new KeyVaultClient(async (authority, resource, scope) =&gt;
{
    var authenticationContext = new AuthenticationContext(authority, null);
    X509Certificate2 certificate;
    X509Store store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
    try
    {
        store.Open(OpenFlags.ReadOnly);
        X509Certificate2Collection certificateCollection = store.Certificates.Find(X509FindType.FindByThumbprint, certificateThumbprint, false);
        if (certificateCollection == null || certificateCollection.Count == 0)
        {
            throw new Exception("Certificate not installed in the store");
        }

        certificate = certificateCollection[0];
    }
    finally
    {
        store.Close();
    }

    var clientAssertionCertificate = new ClientAssertionCertificate(applicationId, certificate);
    var result = await authenticationContext.AcquireTokenAsync(resource, clientAssertionCertificate);
    return result.AccessToken;
});

    var secretIdentifier = "https://rahulkeyvault.vault.azure.net/secrets/mySecretName";
    var secret = await keyClient.GetSecretAsync(secretIdentifier);

    log.Info($"Secret Value: {secret}"); 
}
</code></pre>

<p>Make sure you add in the <em>project.json</em> as seen in the <a href="/blog/azure-key-vault-from-azure-functions/">previous post</a> to enable the required NuGet packages. The Azure function now uses the certificate to authenticate with Key Vault and retrieve the secret.</p>

<p>Hope this helps!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Azure Key Vault From Azure Functions]]></title>
    <link href="http://rahulpnath.com/blog/azure-key-vault-from-azure-functions/"/>
    <updated>2017-05-01T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/azure-key-vault-from-azure-functions</id>
    <content type="html"><![CDATA[<p><em><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview">Azure Functions</a> is a solution for easily running small pieces of code, or &ldquo;functions,&rdquo; in the cloud. You can write just the code you need for the problem at hand, without worrying about a whole application or the infrastructure to run it. Functions can make development even more productive, and you can use your development language of choice, such as C#, F#, Node.js, Python or PHP. Pay only for the time your code runs and trust Azure to scale as needed. Azure Functions lets you develop serverless applications on Microsoft Azure.</em></p>

<p>Even when developing with Azure Functions you want to keep your sensitive data protected. Like for example if the function needs to connect to a database you might want to get the connection string from <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">Azure Key Vault</a>. If you are new to Azure Key Vault check out <a href="http://www.rahulpnath.com/blog/category/azure-key-vault/">these posts to get started</a>. In this post, we will explore how we can consume objects in Azure Key Vault from an Azure Function.</p>

<p><strong>Create Azure Function App</strong>: Let&rsquo;s first create an Azure Function App from the Azure portal. Under <em>New - Compute - Function App</em> you can create a new Azure Function.</p>

<p><img src="/images/azureFunction_new.png" alt="" class="center" /></p>

<p>Enter the details of the new function app and press Create. Each function app has an associated storage account. You can choose an existing one or create a new one.</p>

<p><img src="/images/azureFunction_create.png" alt="" class="center" /></p>

<p>You can view all Azure Functions Apps in the subscription under <em>More services - Function Apps</em></p>

<p><img src="/images/azureFunction_all.png" alt="" class="center" /></p>

<p><strong>Create Function</strong>: To create a function you can create from an existing template or create a custom function. In this example, I will use a timer based function in C#.</p>

<p><img src="/images/azureFunction_createFunction.png" alt="" class="center" /></p>

<p>In the <em>run.csx</em> file add in the code for the function. The below code fetches the secret value from the Key Vault and logs it. You need to provide the <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">Azure AD Application Id and secret</a> to authenticate with it. Make sure you add in the relevant <em>using</em> statements for the KeyVault client Azure Active Directory Authentication libraries (ADAL).</p>

<pre><code class="csharp">using System;
using Microsoft.Azure.KeyVault;
using Microsoft.IdentityModel.Clients.ActiveDirectory;

private const string applicationId = "AD Application Id";
private const string applicationSecret = "AD Application Secret";

public async static Task Run(TimerInfo myTimer, TraceWriter log)
{
    var keyClient = new KeyVaultClient(async (authority, resource, scope) =&gt;
    {
        var adCredential = new ClientCredential(applicationId, applicationSecret);
        var authenticationContext = new AuthenticationContext(authority, null);
        return (await authenticationContext.AcquireTokenAsync(resource, adCredential)).AccessToken;
    });

    var secretIdentifier = "https://rahulkeyvault.vault.azure.net/secrets/mySecretName";
    var secret = await keyClient.GetSecretAsync(secretIdentifier);

    log.Info($"C# Timer trigger function executed at: {secret}"); 
}
</code></pre>

<p><img src="/images/azureFunction_code.png" alt="" class="center" /></p>

<p>Since the KeyVaultClient and the ADAL libraries are NuGet packages, we need to specify these as dependencies for the Azure Function. To use NuGet packages, create a <em>project.json</em> file in the functions folder. Add in both the NuGet packages name and required version.</p>

<pre><code class="json">{
  "frameworks": {
    "net46":{
      "dependencies": {
        "Microsoft.Azure.KeyVault": "1.0.0",
        "Microsoft.IdentityModel.Clients.ActiveDirectory": "2.14.201151115"
      }
    }
   }
}
</code></pre>

<p><img src="/images/azureFunction_nuget.png" alt="" class="center" /></p>

<p>Executing the function, retrieves the secret details from the Key Vault and logs it as shown below.</p>

<p><img src="/images/azureFunction_run.png" alt="" class="center" /></p>

<p>Hope this helps you to get started with Key Vault in Azure Functions and keep your sensitive data secure.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tip of the Week: Switching Subscriptions Under Same Azure Account to Access Key Vaults]]></title>
    <link href="http://rahulpnath.com/blog/switching-between-subscriptions-under-same-azure-account-to-access-key-vault/"/>
    <updated>2017-03-02T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/switching-between-subscriptions-under-same-azure-account-to-access-key-vault</id>
    <content type="html"><![CDATA[<p><img class="center" alt="Azure Powershell Get-AzureRmContext" src="/images/powershell_azurermcontext.png" /></p>

<p>When accessing Key Vault using Powershell it can be a bit tricky when you have multiple subscriptions under the same account. The Key Vault cmdlets being under the <a href="http://www.rahulpnath.com/blog/how-the-deprecation-of-switch-azuremode-affects-azure-key-vault/">Resource Manager (RM) mode</a> depends on the current RM Subscription. The Key Vault cmdlets enable you to manage only the key vaults under the selected subscription. To access the key vaults in other subscriptions, you need to switch the selected RM subscription.</p>

<blockquote><p><em>Use <strong>Select-AzureRmSubscription</strong> to switch the selected RM subscription</em></p></blockquote>

<p> The <a href="https://docs.microsoft.com/en-us/powershell/resourcemanager/azurerm.profile/v2.2.0/get-azurermcontext">Get-AzureRmContext</a> returns the metadata used for RM requests. The SubscriptionId/SubscriptionName property indicates the selected subscription. Any Key Vault cmdlets (or RM cmdlets) will work based off that selected subscription. To change the selected Azure RM subscription use the Select-AzureRmSubscription cmdlet. Pass in the SubscriptionId or the Subscription Name that you wish to switch to and the RM Subscription will be set to that. To get the SubscriptionId/SubscriptionName of the subscriptions under your account use <a href="https://msdn.microsoft.com/en-us/library/dn495302.aspx">Get-AzureSubscription</a> cmdlet.</p>

<pre><code class="` powershell"> Get-AzureRmContext
 Get-AzureRmSubscription
 Select-AzureRmSubscription -SubscriptionName  "Your Subscription Name"
 Select-AzureRmSubscription -SubscriptionId  a5287dad-d5a2-4060-81bc-4a06c7087e72
</code></pre>

<p> I struggled with this for some time, so hope it helps you!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manage Certificates in Azure Key Vault]]></title>
    <link href="http://rahulpnath.com/blog/manage-certificates-in-azure-key-vault/"/>
    <updated>2017-03-01T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/manage-certificates-in-azure-key-vault</id>
    <content type="html"><![CDATA[<p><a href="http://perspecsys.com/" class="center" title="Image By Perspecsys Photos, from https://www.flickr.com/photos/111692634@N04/15855489588"><img class="center" alt="Security" src="/images\pfx_security.jpg" /></a></p>

<p>In one of my earlier posts, <a href="http://www.rahulpnath.com/blog/pfx-certificate-in-azure-key-vault/">PFX Certificate in Azure Key Vault</a>, we saw how to save PFX Certificate files in Key Vault as Secrets. Azure Key Vault now <a href="https://blogs.technet.microsoft.com/kv/2016/09/26/get-started-with-azure-key-vault-certificates/">supports certificates as a first class citizen</a>. This means one can manage certificates as a separate entity in KeyVault. At the time of writing, Key Vault supports managing certificates using Powershell. The <a href="http://www.rahulpnath.com/blog/managing-key-vault-through-azure-portal/">portal UI</a> is still to catch up on this feature. Using the Key Vault&rsquo;s certificate feature, we can create a new certificate: self-signed or signed by a supported certificate authority, import an existing certificate, retrieve the certificate with or without a private key part.</p>

<h3>Setting up the Vault</h3>

<p>With the introduction of the certificates feature, a new command line switch is added to <a href="https://docs.microsoft.com/en-us/powershell/resourcemanager/azurerm.keyvault/v2.2.0/set-azurermkeyvaultaccesspolicy">Set-AzureRmKeyVaultAccessPolicy</a> cmdlet <em><a href="https://docs.microsoft.com/en-us/powershell/resourcemanager/azurerm.keyvault/v2.2.0/set-azurermkeyvaultaccesspolicy#PermissionsToCertificates">-PermissionToCertificates</a></em>. It supports the following values - <em>all, get, create, delete, import, list, update, deleteissuers, getissuers, listissuers, setissuers, managecontacts</em>. For a key vault created after the introduction of this feature, the property is set to <em>all</em> for the creator&rsquo;s access policy. For any vault created before the introduction of the feature, this property needs to be explicitly set to start using it.</p>

<h3>Create Certificate</h3>

<p>To create a new certificate in the vault use the <a href="https://docs.microsoft.com/en-us/powershell/resourcemanager/azurerm.keyvault/v2.2.0/add-azurekeyvaultcertificate">Add-AzureKeyVaultCertificate</a> cmdlet. The cmdlet requires a Certificate Policy that specifies the subject name, issuer name, validity, etc.</p>

<pre><code class="powershell">$certificatepolicy = New-AzureKeyVaultCertificatePolicy   -SubjectName "CN=www.rahulpnath.com"   -IssuerName Self   -ValidityInMonths 12
Add-AzureKeyVaultCertificate -VaultName "VaultFromCode" -Name "TestCertificate" -CertificatePolicy $certificatepolicy 
</code></pre>

<p>Executing the above creates a certificate in the vault with the given name. To retrieve the certificates in the key vault use the. The certificate object identifier is similar to that of Keys and Secrets as shown below. This identifier is used to identify a certificate uniquely.</p>

<pre><code class="text">https://vaultfromcode.vault.azure.net:443/certificates/TestCertificate
</code></pre>

<p>To retrieve all the certificates in a vault use the <a href="https://docs.microsoft.com/en-us/powershell/resourcemanager/azurerm.keyvault/v2.2.0/get-azurekeyvaultcertificate">Get-AzureKeyVaultCertificate</a> cmdlet passing in the VaultName. To get details of a certificate pass in the Certificate Name as well.</p>

<p><img class="center" alt="Azure Key Vault, GetAzureKeyVaultCertificate" src="/images\keyvault_getazurekeyvaultcertificate.png" /></p>

<p>When creating a new certificate make sure that a Key or Secret does not exist with the same name in the vault. Azure adds in a key and secret with the same name as that of the certificate when creating a new certificate as shown in the above image. The key is required when for certificates created with non-exportable key (-<a href="https://docs.microsoft.com/en-us/powershell/resourcemanager/azurerm.keyvault/v2.1.0/new-azurekeyvaultcertificatepolicy#KeyNotExportable">KeyNotExportable</a>). Non-exportable certificates do not have the private portion contained in secret. Any certificate operation requiring the private part should use the key. For consistency, the key exists for exportable certificates as well.</p>

<p>To import an existing certificate into the key vault, we can use <a href="https://docs.microsoft.com/en-us/powershell/resourcemanager/azurerm.keyvault/v2.1.0/import-azurekeyvaultcertificate">Import-AzureKeyVaultCertificate</a> cmdlet. The certificate file should be either PFX or PEM format.</p>

<h3>Recreate Certificate Locally from Key Vault</h3>

<p>Often we will have to recreate the certificate on the machine where the application using it is running. To create the private portion of the certificate retrieve it from the Secret, load it into a certificate collection, export and save the file locally.</p>

<pre><code class="powershell">$kvSecret = Get-AzureKeyVaultSecret -VaultName 'VaultFromCode' -Name 'TestCertificate'
$kvSecretBytes = [System.Convert]::FromBase64String($kvSecret.SecretValueText)
$certCollection = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2Collection
$certCollection.Import($kvSecretBytes,$null,[System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable)
$protectedCertificateBytes = $certCollection.Export([System.Security.Cryptography.X509Certificates.X509ContentType]::Pkcs12, 'test')
$pfxPath = 'C:\cert\test.pfx'
</code></pre>

<p>Similarly to export the public portion of the certificate</p>

<pre><code class="powershell">$cert = Get-AzureKeyVaultCertificate -VaultName 'VaultFromCode' -Name 'TestCertificate'
$filePath ='C:\cert\TestCertificate.cer'
$certBytes = $cert.Certificate.Export([System.Security.Cryptography.X509Certificates.X509ContentType]::Cert)
</code></pre>

<h3>Delete Certificate</h3>

<p>To delete a certificate use the Remove-AzureKeyVaultCertificate cmdlet and pass in the vault name and certificate name.</p>

<pre><code class="powershell">Remove-AzureKeyVaultCertificate -VaultName 'VaultFromCode' -Name 'TestCertificate'
</code></pre>

<p>Hope this helps you to get started with managing certificates in Azure Key Vault.</p>
]]></content>
  </entry>
  
</feed>
