<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: azure key vault | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/azure-key-vault/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2016-11-01T03:51:02+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Managing Key Vault Through Azure Portal]]></title>
    <link href="http://rahulpnath.com/blog/managing-key-vault-through-azure-portal/"/>
    <updated>2016-11-01T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/managing-key-vault-through-azure-portal</id>
    <content type="html"><![CDATA[<p>You can now manage Key Vault through the Azure portal. Prior to this the Key Vault&rsquo;s were managed either using <a href="http://www.rahulpnath.com/blog/how-the-deprecation-of-switch-azuremode-affects-azure-key-vault/">Powershell</a>, <a href="http://www.rahulpnath.com/blog/managing-azure-key-vault-using-azure-resource-manager-arm-templates/">ARM Templates</a> or <a href="http://www.rahulpnath.com/blog/managing-azure-key-vault-over-the-rest-api/">REST API</a>. Managing key Vault is now easy and user-friendly for the nontechnical people. In this post, I will walk through the new features in Azure Portal to manage key vault.</p>

<blockquote><p><em>If you find any difference between what you see in the portal versus those in the screenshots below, it&rsquo;s likely that the portal is updated</em></p></blockquote>

<p>In the new Azure portal search for &lsquo;key vault&rsquo; to access this new feature. Or you can go to &lsquo;More Services&rsquo; and scroll down to &lsquo;Security + Identity&rsquo; section in the menu. Selecting Key Vault takes you to all the available Key Vaults under your subscription. You can further filter the Vault&rsquo;s list by the vault name using the filter box or based on your subscriptions.</p>

<p><img  alt="Key Vault in Azure Portal" src="/images/keyvaultportal_menu_option.png"/></p>

<h4><strong>Creating Key Vault</strong></h4>

<p>To create a new Key Vault select the &lsquo;Create&rsquo; option. By entering the Vault Name, Subscription, Resource Group and Location you can create a new Key Vault.</p>

<p><img  alt="Create Key Vault in Azure Portal" src="/images/keyvaultportal_create_key_vault.png"/></p>

<p>The pricing tier defaults to Standard and it does not support HSM backed keys. This means you will be only able to create Software keys. You can select the  Premium pricing tier if you need HSM backed keys. By default the login with which you create the subscription with gets granted access to the vault and is added to the access policies. You can grant additional applications or users access and control the permissions. Below I am adding in an AD application.</p>

<p><img  alt="Key Vault Add Access Policy" src="/images/keyvaultportal_access_policy.png"/></p>

<p>You can specify the Key Permissions and the Secret Permissions that the ServicePrincipal.</p>

<p><img  alt="Access Policy set Secret Permissions" src="/images/keyvaultportal_secretpermissions.png"/></p>

<h4><strong>Keys and Secrets</strong></h4>

<p>Once the Vault is created you can add in Keys and Secrets into the vault. This can be done by selecting the Vault that was just created from the Vaults list. From here you can manage different aspects of the Vault and also manage Keys and Secrets.</p>

<p><img  alt="Access Policy set Secret Permissions" src="/images/keyvaultportal_keyvault.png"/></p>

<p>The Azure Portal experience of Key Vault is good. It covers most of the functionalities needed when using a Key Vault. How do you find the new UI experience?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keeping Sensitive Configuration Data Out of Source Control]]></title>
    <link href="http://rahulpnath.com/blog/keeping-sensitive-configuration-data-out-of-source-control/"/>
    <updated>2016-09-19T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/keeping-sensitive-configuration-data-out-of-source-control</id>
    <content type="html"><![CDATA[<p>Most applications today deals with some form of sensitive information. The most commonly seen are database connection strings, API keys, token etc. The web.config seems the best place to have these values, but it definitely is not. In most cases it gets pushed into the source control systems as well. If it is a private repository then you at least have one level of security on top of it. It still exposes sensitive information to anyone who has access to the repository. It’s worse when the <a href="http://www.internetnews.com/blog/skerner/github-search-exposes-passwords.html">repository is public</a>.</p>

<p><img alt="Keep sensitive data out of source control" src="/images/sensitivedata_source_control.png" /></p>

<p>There are different ways you can  avoid pushing sensitive data into source control. In this post, I will explore options that I am familiar with.</p>

<blockquote><p><em>Use configuration files as template definitions for the configuration data your application requires. Have the actual values stored elsewhere</em></p></blockquote>

<h3>Azure App Settings</h3>

<p>If you are deploying your application as a Web App on Azure, you can store <a href="https://azure.microsoft.com/en-us/blog/windows-azure-web-sites-how-application-strings-and-connection-strings-work/">application settings and connection strings in Azure</a>. At runtime, Windows Azure Web Sites automatically retrieves these values for you and makes them available to code running in your website. This removes the need for having sensitive data in the configuration file.</p>

<p><img alt="Azure App Settings and Connection Strings" src="/images/sensitiveData_azure_app_settings.png" /></p>

<h3>Release Management Tools</h3>

<p>Release management tools like Octopus Deploy, Microsoft Release Management, that performs configuration transformation. It supports creating different environments (development, production) and corresponding configurations. On creating a package for an environment, it applies the corresponding environment configurations</p>

<p><img alt="Release Management Tools - Octopus Deploy" src="/images/sensitiveData_releaseManagement_tool_octopus.png" /></p>

<p>Packaging embeds the configuration value into the configuration file. This makes it available to anyone who has access to the host systems.</p>

<h3>Azure Key Vault</h3>

<p>Azure Key Vault acts as a centralized repository for all sensitive information. Key vault stores cryptographic keys and Secrets and makes them available over a HTTP Api. The objects (keys and secrets) in key vault has unique identifier to retrieve them. Check <a href="http://www.rahulpnath.com/blog/azure-key-vault-in-a-real-world-application/">Azure Key Vault in real world application</a> for more details on how to achieve this. A client application can <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">authenticate with Azure Key Vault using a ClientID/secret or ClientID/certificate</a>. Using certificate to authenticate is the preferred approach. To get Keys/Secret from key vault all you need is the AD Application Id, the client secret or certificate identifier and the key/secret names. The certificate itself can be deployed separately into the application host.</p>

<pre><code class="XML">&lt;appSettings&gt;
  &lt;add key="KeyVaultUrl" value="https://testvaultrahul.vault.azure.net"/&gt;
  &lt;add key="ADApplicationId" value="" /&gt;
  &lt;add key="ADCertificateThumbprint" value="" /&gt;
  &lt;add key="DbConnectionString" value="SqlConnectionString"/&gt;
  &lt;add key ="ApiToken" value="ApiToken/cfedea84815e4ca8bc19cf8eb943ee13"/&gt;
&lt;/appSettings&gt;
</code></pre>

<p>If you are using the &lsquo;client secret&rsquo; to authenticate then the configuration file will have the Secret. In either cases, you should follow either of the previous approaches to keep the Application Id and authentication information out of configuration. The advantage of using <a href="http://www.rahulpnath.com/blog/category/azure-key-vault/">Key Vault</a> is that it is a centralized  repository for all your sensitive data, across different applications. You can also restrict access permissions per application.</p>

<p>These are some approaches to keep sensitive information out of source control. What approach do you use? Irrespective of the approach you use, make sure that you don’t check them in!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Managing Azure Key Vault using Azure Resource Manager (ARM) Templates]]></title>
    <link href="http://rahulpnath.com/blog/managing-azure-key-vault-using-azure-resource-manager-arm-templates/"/>
    <updated>2016-06-05T06:15:31+00:00</updated>
    <id>http://rahulpnath.com/blog/managing-azure-key-vault-using-azure-resource-manager-arm-templates</id>
    <content type="html"><![CDATA[<p>Creating and managing Azure Key Vault was mostly supported through PowerShell cmdlets <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">initially</a>, but there are multiple ways of achieving this now - <a href="http://www.rahulpnath.com/blog/managing-azure-key-vault-over-the-rest-api/">REST API</a>, <a href="http://www.rahulpnath.com/blog/how-the-deprecation-of-switch-azuremode-affects-azure-key-vault/">PowerShell</a>, CLI or ARM templates. In this post, we will look into how we can use <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-group-authoring-templates/">Azure Resource Manager</a> (ARM) templates to create and manage a Key Vault.</p>

<h3>Azure Resource Manager and Templates</h3>

<p>Simply put, the <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-group-overview/">Azure Resource Manager</a>(ARM) allows to group different resources in your solution that form a logical unit and manage them together. It allows to spin up all the resources required for your system and deploy them as and when required. You can achieve this using custom PowerShell scripts or creating a template (in JSON format) - Azure Resource Manager Template.</p>

<blockquote><p><em>Within the ARM template, you define the infrastructure for your app, how to configure that infrastructure, and how to publish your app code to that infrastructure.</em></p></blockquote>

<p>You can <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-manager-export-template/">export a template from existing resources</a> for a starting point and then work off that. But in this post, I will start with an empty template as it helps to understand all the template parts. A template is nothing but a JSON file with a specific <a href="http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#">schema</a>. All templates have the below format where a few of the elements are not mandatory. If you are not familiar with the template format and the different elements that make it, I&rsquo;ll wait while you read more about the <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-group-authoring-templates/#template-format">Template format</a></p>

<pre><code class="json">{
   "$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
   "contentVersion": "",
   "parameters": {  },
   "variables": {  },
   "resources": [  ],
   "outputs": {  }
}
</code></pre>

<h3>Key Vault ARM Template</h3>

<p>The <a href="https://github.com/Azure/azure-resource-manager-schemas/blob/c301d6ed1d8876cad60af1f81d420e9249a80594/schemas/2015-06-01/Microsoft.KeyVault.json">Key Vault schema</a> is authored here and is part of the root schema URL that we had <a href="http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#">seen above</a>. Though it might not be able to fully understand the schema details, it helps to understand at a high level what are the different parameters that are allowed when defining a Key Vault. At present, the schema allows only creating <a href="http://www.rahulpnath.com/blog/moving-sensitive-information-from-configuration-file-to-azure-key-vault/">Secrets</a> within a Key Vault and <a href="http://www.rahulpnath.com/blog/how-the-deprecation-of-switch-azuremode-affects-azure-key-vault/">Keys have to be created separately</a>.</p>

<p>Like we did using the <a href="http://www.rahulpnath.com/blog/managing-azure-key-vault-over-the-rest-api/">REST API</a>, with this ARM template I want to create or update a Key Vault with a specified set of properties (like Vault Name, tenant etc), the access policies to specify the AD objects (applications/users) that have access to the Vault and create a few secrets.</p>

<p>Create a new JSON file with any name you like (<em>azuredeploy.json</em>) and copy the above template structure into it. For the content version, you can use any value that you like for e.g. 1.0.0. Next, we need to define the parameters that we need, that are specific to each Key Vault deployment. Without parameters, we will be always deploying the resources with the same name and properties, so it is a good practice to externalize it and use it as required. <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-group-authoring-templates/#parameters">Parameters</a> have a defined structure and allows to have basic validation for the input values. All parameters that does not have a <em>defaultValue</em> needs to be passed in while using the template.</p>

<h4><strong>Parameters</strong></h4>

<p>Let&rsquo;s see a few of the different parameter types that we use in this template. The <em>keyVaultName</em> parameter is a simple string value and is required to be passed in as it does not have a default value specified, where as the <em>enableVaultForVolumeEncryption</em> is an optional parameter and defaults to false. The parameters <em>accessPolicies</em> and <em>secrets</em> are of type <em>array</em> and takes in any valid JSON array. But in this specific case, I want it to be in a specific format but I am yet not sure if I can specify a format structure for the JSON input. Sound off in the comments if you know of a way.</p>

<pre><code>"parameters": {
    "keyVaultName": {
        "type": "string",
        "metadata": {
            "description": "Name of the Key Vault"
        }
    },
    "accessPolicies": {
        "type": "array",
        "defaultValue": "{}",
        "metadata": {
            "description": "Access policies object {"tenantId":"","objectId":"",
                    "permissions":{"keys":[""],"secrets":[""]}}"
        }
    },
    "enableVaultForVolumeEncryption": {
        "type": "bool",
        "defaultValue": false,
        "metadata": {
            "description": "Specifies if the vault is enabled for volume encryption"
        }
    },
    "secrets": {
        "type": "array",
        "defaultValue": "{}",
        "metadata": {
            "description": "all secrets {"secretName":"","secretValue":""}"
        }
    }
    ...
}
</code></pre>

<h4><strong>Resources</strong></h4>

<p>The Resources section of the template defines the resources to be deployed or updated and takes in an array of values. Resource manager supports two modes of deployment - <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-group-template-deploy/#incremental-and-complete-deployments">Incremental and Complete deployment</a> - and the way you define the resources here will affect what and how things get deployed. The template supports the use of certain <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-group-authoring-templates/#expressions-and-functions">Expressions and Functions</a>, to enable dynamic creation of values. Expressions are enclosed in square brackets ([]) and can appear anywhere is a JSON string value and evaluated when the template is deployed. To use a literal string that starts with a bracket [, use two brackets [[.</p>

<p>The <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-group-template-functions/#parameters">parameter function</a> is used to get the value of a parameter that is passed in. I use this to access the Vault name, accessPolicies and other parameters that we had defined earlier. Since accessPolicies in the template expects an array I pass in the parameter object as is to it.</p>

<p>Secrets are defined as nested resources within the Key Vault and can be defined as a nested property within the Key Vault resource as shown in the <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-manager-template-keyvault/#examples">example here</a>. Since here we are interested in dynamically generating the Secrets based on the array value passed in as <em>secrets</em> parameter, I use the <em><a href="https://azure.microsoft.com/en-us/documentation/articles/resource-group-create-multiple/#copy-copyindex-and-length">copy, copyIndex and length function</a></em> to iterate through the array and generate the required template. The <em>copy</em> function iterates and produces the same template structure with different values as specified by the parameter values.</p>

<p>Since the Secret is defined as a separate resource, <em>name</em> property needs to indicate that it is a nested resource, hence we are concatenating the Vault Name with it. Without that I was getting the error :</p>

<p><span style='color: red;'><em>A nested resource type must have an identical number of segments as its resource name. A root resource type must have segment length one greater than its resource name.</em></span>.</p>

<p>The <em><a href="https://azure.microsoft.com/en-us/documentation/articles/resource-group-define-dependencies/#dependson">dependsOn</a></em> element specifies that the Secret resource is dependent on the Key Vault resource.</p>

<pre><code class="json"> "resources": [
    {
        "type": "Microsoft.KeyVault/vaults",
        "name": "[parameters('keyVaultName')]",
        "accessPolicies": "[parameters('accessPolicies')]",
        ...
    },
    {
        "type": "Microsoft.KeyVault/vaults/secrets",
        "name": "[concat(parameters('keyVaultName'), '/', parameters('secrets')[copyIndex()].secretName)]",
        "properties": {
            "value": "[parameters('secrets')[copyIndex()].secretValue]"
        },
        "dependsOn": [
            "[concat('Microsoft.KeyVault/vaults/', parameters('keyVaultName'))]"
        ],
        "copy": {
            "name": "secretsCopy",
            "count": "[length(parameters('secrets'))]"
        }
    }
]
</code></pre>

<h3>Deploying with ARM Templates</h3>

<p>To deploy the ARM template we need to pass in the required parameters and run the template.</p>

<h4><strong>Parameter File</strong></h4>

<p>Parameters can be passed in individually or as a <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-group-template-deploy/#parameter-file">Parameter File</a>. Parameter file (<em>azuredeploy.parameters.json</em>) is a JSON file with a specific format. Below is a sample parameter file for our Key Vault ARM template. We can have different such templates for each of our deployment environments with values specific for the environment.</p>

<pre><code class="json">    {
        "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
        "contentVersion": "1.0.0.0",
        "parameters": {
            "keyVaultName": {
                "value": "NewARMVaultP"
            },
            "tenantId": {
                "value": ""
            },
            "accessPolicies": {
                "value": [
                    {
                        "tenantId": "&lt;TENANT ID&gt;",
                        "objectId": "&lt;AD OBJECT ID&gt;",
                        "permissions": {
                            "keys": ["all"],
                            "secrets": ["all"]
                        }
                    },
                    { ... }
                ]
            },
            "secrets": {
                "value": [
                    {
                        "secretName": "ConnectionString",
                        "secretValue": "SecureString1"
                    },
                    { ... }
                ]
            }
        }
    }
</code></pre>

<h4><strong>Deployment</strong></h4>

<p>The ARM template along with the parameter file can be deployed in different ways - <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-group-template-deploy/">PowerShell, Azure CLI, REST API, Visual Studio or from Azure Portal</a>. Using PowerShell we can deploy as below. The <em><a href="https://msdn.microsoft.com/en-us/library/mt679014.aspx">Test-AzureRmResourceGroupDeployment</a></em> cmdlet tests if the template file and parameter file are in correct format. This is mostly useful when authoring the template. <em><a href="https://msdn.microsoft.com/en-us/library/mt603823.aspx">New-AzureRmResourceGroupDeployment</a></em> deploys using the given template file and parameters.</p>

<pre><code class="powershell">Test-AzureRmResourceGroupDeployment -ResourceGroupName SharedGroup -TemplateFile .\azuredeploy.json 
        -TemplateParameterFile .\azuredeploy.parameters.json -Verbose
New-AzureRmResourceGroupDeployment -ResourceGroupName SharedGroup -TemplateFile .\azuredeploy.json
         -TemplateParameterFile .\azuredeploy.parameters.json -Verbose
</code></pre>

<p><a href="http://armviz.io/#">ARM Template Visualizer</a> (ArmViz) is a visual way of editing and managing ARM templates and can be useful when dealing with a large number of resource deployments in a template. Also check out some <a href="https://azure.microsoft.com/en-us/documentation/articles/best-practices-resource-manager-design-templates/">Good practices for designing templates</a>. Most of the template code above is <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-manager-template-keyvault/">based off this example here</a>. <strike>I will try to push this template into the <a href="https://github.com/Azure/azure-quickstart-templates">Azure Quickstart Templates</a> but meanwhile it is <a href="https://github.com/rahulpnath/Blog/tree/master/KeyVault%20ARM%20Template">available here</a>.</strike> The ARM template is available with the <a href="https://azure.microsoft.com/en-us/documentation/templates/201-key-vault-secret-create/">Azure Quickstart Templates</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Managing Azure Key Vault over the REST API]]></title>
    <link href="http://rahulpnath.com/blog/managing-azure-key-vault-over-the-rest-api/"/>
    <updated>2016-05-25T06:23:39+00:00</updated>
    <id>http://rahulpnath.com/blog/managing-azure-key-vault-over-the-rest-api</id>
    <content type="html"><![CDATA[<p>Creating and managing Azure Key Vault was mostly supported through PowerShell cmdlets <a href="http://www.rahulpnath.com/blog/getting-started-with-azure-key-vault/">initially</a>, but there are multiple ways of achieving this now - REST API, <a href="http://www.rahulpnath.com/blog/how-the-deprecation-of-switch-azuremode-affects-azure-key-vault/">PowerShell</a>, CLI or <a href="http://www.rahulpnath.com/blog/managing-azure-key-vaults-using-azure-resource-manager-arm-templates/">ARM templates</a>. In this post, we will look into how we can use the REST API to create and manage a Key Vault.</p>

<h3>Azure Resource Manager API</h3>

<p>The <a href="https://msdn.microsoft.com/en-AU/library/azure/dn790568.aspx">Azure Resource Manager API</a> provides programmatic access to manage Azure services that support <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-group-overview/">Resource Manager</a>. Since Key Vault supports Resource Manager, we will be using it. Any requests to the API must be authenticated and can be done using an Azure AD application. Most of the steps to create an AD application are same as we saw when creating an AD application to <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">Authenticate a Client Application with Azure Key Vault</a>. From the &lsquo;<em>permissions to other applications</em>&rsquo; tab in portal (as shown below), we can give the application access to Management API&rsquo;s.</p>

<p>To get the token to access the Management API resource (<em><a href="https://management.azure.com">https://management.azure.com</a> </em>), I use the <a href="https://www.nuget.org/packages/Microsoft.IdentityModel.Clients.ActiveDirectory">ADAL library</a> with the required data. All the information that needs to be passed to the ADAL library is available under the AD application in the azure portal (as shown below).</p>

<pre><code class="csharp">string token = await GetAccessToken(
                "https://login.microsoftonline.com/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX",
                "https://management.azure.com/",
                string.Empty);
 ...

private async Task&lt;string&gt; GetAccessToken(string authority, string resource, string scope)
{
    var adCredential = new ClientCredential(APPLICATION_ID, APPLICATION_SECRET);
    var authenticationContext = new AuthenticationContext(authority);
    return (await authenticationContext.AcquireTokenAsync(resource, adCredential)).AccessToken;
}
</code></pre>

<blockquote><p><em>Earlier authentication requests were served from <a href="https://login.windows.net">https://login.windows.net</a> (authority URL) which is <a href="https://blogs.technet.microsoft.com/ad/2015/03/06/simplifying-our-azure-ad-authentication-flows/">now updated</a> to <a href="https://login.microsoftonline.com">https://login.microsoftonline.com</a> .</em></p></blockquote>

<p><img src="/images\service_management_adAccess.png" class="center" alt="AD Application access to Azure Service Management API"></p>

<h3>Key Vault Management Client</h3>

<p>The <a href="https://www.nuget.org/packages/Microsoft.Azure.Management.KeyVault/">Microsoft.Azure.Management.KeyVault</a> NuGet package, provides capabilities to connect to the Management API&rsquo;s and manage the Vaults. With the NuGet reference added I can use the <em><a href="https://github.com/Azure/azure-sdk-for-net/blob/master/src/ResourceManagement/KeyVaultManagement/KeyVaultManagement/Generated/KeyVaultManagementClient.cs">KeyVaultManagementClient</a></em>.</p>

<blockquote><p><em>Much of the SDK code is generated  using <a href="https://github.com/azure/autorest">Autorest</a>, from the REST API&rsquo;s metadata spec&rsquo;s in Swagger format.</em></p></blockquote>

<p>With the Azure Subscription Id and the token from the previous step a TokenCloudCredentials is created that is used to connect the Key Vault Management Client.</p>

<pre><code class="csharp">string token = await GetAccessToken(
    "https://login.microsoftonline.com/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX",
    "https://management.azure.com/",
    string.Empty);
var tokenCredentials = new TokenCloudCredentials(SUBSCRIPTION_ID, token);
var keyVaultManagementClient = new KeyVaultManagementClient(tokenCredentials);
</code></pre>

<p>Key Vaults exists under a Resource Group and for it to be accessible using the AD application authenticated token, we need to grant permission to the application. Just like we managed <a href="http://www.rahulpnath.com/blog/managing-user-permissions-for-key-vault/">User Permissions for Key Vault</a> we can give the AD application access to the Resource Group. We can do this from the new portal (as shown in the other post) or using the <em>New-AzureRmRoleAssignment</em> PowerShell cmdlet. <em>Get-AzureRmADServicePrincipal</em> is used o get the ObjectId of an existing application passing the application name as SearchString. I have yet not found a better way to find the application ObjectId. Please drop a comment if you know of any.</p>

<pre><code class="powershell">Get-AzureRmADServicePrincipal  -SearchString 'AD Application Name'
New-AzureRmRoleAssignment -ObjectId &lt;AD Application Object Id&gt;
     -RoleDefinitionName Reader -ResourceGroupName SharedGroup
</code></pre>

<h3>Creating New Key Vault</h3>

<p>We have all the required permissions setup, to create a key vault using the KeyVaultManagament client library. Using this is straightforward as shown below.
The <em><a href="https://github.com/Azure/azure-content/blob/master/articles/resource-manager-template-keyvault.md#sku">Sku</a></em> is used to specify <a href="https://azure.microsoft.com/en-us/pricing/details/key-vault/">Key vault service tier</a> - &lsquo;Standard&rsquo; or &lsquo;Premium&rsquo;. For HSM backed keys it is Premium. Family on Sku object takes in a hardcoded value of &lsquo;A&rsquo;. <em><a href="https://github.com/Azure/azure-content/blob/master/articles/resource-manager-template-keyvault.md#propertiesaccesspolicies-object">AccessPolicies</a></em> specify the AD object identifier of user or application that can access the vault. In this case, I am adding the current AD application with full (<a href="https://github.com/Azure/azure-content/blob/master/articles/resource-manager-template-keyvault.md#propertiesaccesspoliciespermissions-object"><em>all</em></a>) access to Keys and Secrets. Adding an access policy in same as using the <a href="https://msdn.microsoft.com/en-us/library/mt603625.aspx"><em>Set-AzureRmKeyVaultAccessPolicy</em></a>.</p>

<pre><code class="csharp">var parameters = new VaultCreateOrUpdateParameters()
{
    Location = "southeast asia",
    Properties = new VaultProperties()
    {
        Sku = new Sku { Family = "A", Name = "Standard" },
        TenantId = Guid.Parse(TENANT_ID),
        AccessPolicies = new List&lt;AccessPolicyEntry&gt;() {
            new AccessPolicyEntry
                    {
                        TenantId = Guid.Parse(TENANT_ID),
                        ObjectId = Guid.Parse(AD_OBJECT_ID),
                        PermissionsToKeys = new string[] { "all" },
                        PermissionsToSecrets = new string[] { "all" }
                    }
        }
    }
};

var vaultFromCode = await keyVaultManagementClient.Vaults
        .CreateOrUpdateAsync("SharedGroup", "VaultFromCode", parameters);
</code></pre>

<h3>Managing Existing Key Vaults</h3>

<p><strong>Update a Key Vault</strong></p>

<p>When updating an existing Key Vault, the full state (<em>VaultCreateOrUpdateParameters</em>) must be passed back and not just the update. To add a new <em>AccessPolicyEntry</em>, the existing policy entry values must also be passed back. In the code below, I get the existing state of the Key Vault using the <em>Get</em> and use the current vault properties to add in the new AccessPolicyEntry.</p>

<pre><code class="csharp">var keyVault = (await keyVaultManagementClient.Vaults
   .GetAsync("SharedGroup", "VaultFromCode")).Vault;
            parameters = new VaultCreateOrUpdateParameters();
            parameters.Location = keyVault.Location;
            parameters.Properties = keyVault.Properties;
            parameters.Properties.AccessPolicies.Add(

   new AccessPolicyEntry
   {
       TenantId = Guid.Parse(TENANT_ID),
       ObjectId = Guid.Parse("AD Object IDentifier"),
       PermissionsToKeys = new string[] { "get" },
       PermissionsToSecrets = new string[] { "get" }
   }
            );
await keyVaultManagementClient.Vaults.CreateOrUpdateAsync("SharedGroup", "VaultFromCode", parameters);
</code></pre>

<p><strong>Delete a Key Vault</strong>
<code>csharp
await keyVaultManagementClient.Vaults.DeleteAsync("SharedGroup", "VaultFromCode");
</code></p>

<p>Hope this helps you manage Azure Key Vault using the REST API.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PFX Certificate in Azure Key Vault]]></title>
    <link href="http://rahulpnath.com/blog/pfx-certificate-in-azure-key-vault/"/>
    <updated>2016-03-18T12:21:03+00:00</updated>
    <id>http://rahulpnath.com/blog/pfx-certificate-in-azure-key-vault</id>
    <content type="html"><![CDATA[<p><a href="http://perspecsys.com/" class="center" title="Image By Perspecsys Photos, from https://www.flickr.com/photos/111692634@N04/15855489588"><img class="center" alt="Security" src="/images\pfx_security.jpg" /></a></p>

<p>You can use PFX certificate&rsquo;s along with Azure Key Vault in multiple ways, depending on your use case. You can import the PFX as a Key into Key Vault and use it just like you would use any other key or save it as a Secret and retrieve it as required. In this post I will explain how this is done.</p>

<p>Before I get into more details let&rsquo;s take a moment to understand better the different file types used and <a href="http://stackoverflow.com/questions/2292495/what-is-the-difference-between-a-cer-pvk-and-pfx-file">what they represent</a>.</p>

<ul>
<li><p><strong>CER</strong>: Contains the public part of the certificate and usually distributed outside.</p></li>
<li><p><strong>PVK</strong>: Contains the Private key and securely stored</p></li>
<li><p><strong>PFX</strong>: Usually has public, private keys, other certificate chains and password protected.</p></li>
</ul>


<p>To create a test certificate for this sample I will use <em>makecert</em> and <em>pvktopfx</em> utilities. Alternatively, you could also use any existing certificate.</p>

<pre><code class="text">makecert -sv mykey.pvk -n "cn=Certificate Key" CertificateKey.cer -b 03/03/2016 -e 06/05/2017 -r -sky exchange
pvk2pfx -pvk mykey.pvk -spc CertificateKey.cer -pfx CertificateKey.pfx -po test
</code></pre>

<blockquote><p>The <em>-sky exchange</em> sets the Subject Key Type to Exchange and allows encrypting/decrypting values using the certificate.</p></blockquote>

<p>The <em>makecert</em> creates the CER and PVK, the public/private key files which gets combined into a single PFX file using <em>pvktopfx</em>.</p>

<h3>Using the PFX Certificate to Encrypt and Decrypt</h3>

<p>PFX files along with CER files allows to encrypt/decrypt data without the need for Key Vault. You can share the public key, CER, to your clients, who can then use it to encrypt data before sending it to the server. Using the private key, available in PFX, the server can decrypt this data</p>

<pre><code class="csharp">// Client
byte[] encryptedData;
// You can also use the PFX here as it contains the private key
var publicCertificate = new X509Certificate2(@"C:\CertificateKey.cer"); 
using (var cryptoProvider = publicCertificate.PublicKey.Key as RSACryptoServiceProvider)
{
    var byteData = Encoding.Unicode.GetBytes(textToEncrypt);
    encryptedData = cryptoProvider.Encrypt(byteData, true);
}

//Server
var privateCertificate = new X509Certificate2(@"C:\CertificateKey.pfx", "test");
using (var cryptoProvider = privateCertificate.PrivateKey as RSACryptoServiceProvider)
{
    var decryptedData = cryptoProvider.Decrypt(encryptedData, true);
    var decryptedText = Encoding.Unicode.GetString(decryptedData);
}
</code></pre>

<h3>Creating a Key in Key Vault from PFX file</h3>

<p>Now that I am able to use the PFX file (which essentially is a software-protected key) to encrypt/decrypt data, I will upload this to the Azure Key Vault so that it stays secure there. If you are new to Azure Key Vault and want to get started check my <a href="http://www.rahulpnath.com/blog/category/azure-key-vault/">other posts</a>.</p>

<p>To upload the PFX to Key Vault, you can use the <em><a href="https://msdn.microsoft.com/en-us/library/dn868048.aspx">Add-AzureKeyVaultKey</a></em> PowerShell cmdlet and specify the PFX file path and password.</p>

<pre><code class="powershell">$securepfxpwd = ConvertTo-SecureString –String 'test' –AsPlainText –Force
Add-AzureKeyVaultKey -VaultName 'rahulkeyvault' -Name 'KeyFromCert' -KeyFilePath 'c:\CertificateKey.pfx' -KeyFilePassword $securepfxpwd
</code></pre>

<p>Using the unique key identifier, I can now access this key from PowerShell or using the Web API. You can still distribute the public key, CER, to your clients for encrypting the data and use the Azure Key Vault API to decrypt the data. Or use the Azure Key Vault to encrypt and decrypt the data.</p>

<pre><code class="csharp">var keyIdentifier = "https://rahulkeyvault.vault.azure.net:443/keys/KeyFromCert/";

// Client Remains the same or use the Key Vault Client
var encryptedResult = await keyClient.EncryptAsync(keyIdentifier, "RSA-OAEP", byteData);

// Server
var decryptedData = await keyClient.DecryptAsync(keyIdentifier, "RSA-OAEP", certED);
var decryptedText = Encoding.Unicode.GetString(decryptedData.Result);
</code></pre>

<p>The PFX file uploaded to the Key Vault is just like any other key vault key, the only difference being you give the public and private key. Once the key is created in Key Vault, the private part of the key stays secure within the Key Vault and is not accessible outside (except from the original PFX/PVK file).</p>

<h3>Storing PFX file as a Secret</h3>

<p>PFX files can also be stored as Secrets in Key Vault which allows you to retrieve and re-create the certificate as required. To add the certificate as a secret you can use the below PowerShell script (taken from <a href="http://stackoverflow.com/questions/33728213/how-to-store-pfx-certificate-in-azure-key-vault">here</a>).</p>

<pre><code class="powershell">$pfxFilePath = 'C:\CertificateKey.pfx'
$pwd = 'test'
$flag = [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable
$collection = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2Collection 
$collection.Import($pfxFilePath, $pwd, $flag)
$pkcs12ContentType = [System.Security.Cryptography.X509Certificates.X509ContentType]::Pkcs12
$clearBytes = $collection.Export($pkcs12ContentType)
$fileContentEncoded = [System.Convert]::ToBase64String($clearBytes)
$secret = ConvertTo-SecureString -String $fileContentEncoded -AsPlainText –Force
$secretContentType = 'application/x-pkcs12'
Set-AzureKeyVaultSecret -VaultName 'rahulkeyvault' -Name 'PfxFile' -SecretValue $Secret -ContentType $secretContentType
</code></pre>

<p>The script exports the certificate to a byte array and converts it to Base64 string representation and saves it to Key Vault as Secret using the <a href="https://msdn.microsoft.com/en-us/library/dn868050.aspx">Set-AzureKeyVaultSecret</a> PowerShell cmdlet. You can export the certificate along with the password if required, so that when you recreate the certificate file, it will be password protected.</p>

<p>To retrieve and re-create the certificate you can either use PowerShell or API as shown below</p>

<pre><code class="powershell">$secretRetrieved = Get-AzureKeyVaultSecret -VaultName 'rahulkeyvault' -Name 'PfxFile'
$pfxBytes = [System.Convert]::FromBase64String($secretRetrieved.SecretValueText)
</code></pre>

<pre><code class="csharp">var secretRetrieved = await keyClient.GetSecretAsync(secretIdentifier);
var pfxBytes = Convert.FromBase64String(secretRetrieved.Value);
File.WriteAllBytes(@"C:\cert\ADTestVaultApplicationNew.pfx", pfxBytes);

// or recreate the certificate directly
var certificate = new X509Certificate2(pfxBytes);
</code></pre>

<p>You can use the PFX certificate as earlier as a file or a certificate object. These are the various ways that you can use PFX certificated along with Key Vault.</p>

<p>Hope this helps!</p>
]]></content>
  </entry>
  
</feed>
