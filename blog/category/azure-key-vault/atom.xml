<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: azure key vault | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/azure-key-vault/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2018-06-19T00:02:44+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Azure Key Vault As A Connected Service in Visual Studio 2017]]></title>
    <link href="http://rahulpnath.com/blog/azure-key-vault-as-a-connected-service-in-visual-studio-2017/"/>
    <updated>2018-06-15T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/azure-key-vault-as-a-connected-service-in-visual-studio-2017</id>
    <content type="html"><![CDATA[<p>Visual Studio (VS) now supports adding <a href="https://rahulpnath.com/blog/category/azure-key-vault/">Azure Key Vault</a> as a <a href="https://docs.microsoft.com/en-us/azure/key-vault/vs-key-vault-add-connected-service">Connected Service</a>, for Web Projects ( ASP.NET Core or any ASP.NET project). Enabling this from the Connected Service makes it easier for you to get started with Azure Key Vault. Below are the prerequisites to use the Connected Service feature</p>

<blockquote><p><a href="https://docs.microsoft.com/en-us/azure/key-vault/vs-key-vault-add-connected-service#prerequisites">Prerequisites</a></p>

<ul>
<li>An Azure subscription. If you do not have one, you can sign up for a free account.</li>
<li>Visual Studio 2017 version 15.7 with the Web Development workload installed. Download it now.</li>
<li>An ASP.NET 4.7.1 or ASP.NET Core 2.0 web project open.</li>
</ul>
</blockquote>

<p><img class =" center" src="/images/keyVault_connectedService.png" alt="Visual Studio, Azure Key Vault Connected Services" /></p>

<p>When selecting &lsquo;Secure Secrets with Azure Key Vault&rsquo; option from the list of Connected Services provided it takes you to a new page within Visual Studio with your Azure Subscription associated with Visual Studio Account and gives you the ability to add a Key Vault to it. VS does generate some defaults for the Vault Name, Resource Group, Location and the Pricing Tier which you can edit as per your requirement. Once you confirm to the <em>Add</em> the Key Vault, VS provisions the Key Vault with the selected configuration and modifies some things in your project.</p>

<ul>
<li><a href="https://docs.microsoft.com/en-us/azure/key-vault/vs-key-vault-aspnet-what-happened">Changes Made to your ASP.NET project</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/key-vault/vs-key-vault-aspnet-core-what-happened">Changes made to your ASP.NET Core project</a></li>
</ul>


<p><img class =" center" src="/images/keyVault_connectedService_createKeyVault.png" alt="Visual Studio, Azure Key Vault Connected Services" /></p>

<p>In short, VS adds</p>

<ul>
<li>a bunch of NuGet packages to access Azure Key Vault</li>
<li>Adds in the Keyvault Url details</li>
<li>In ASP.NET Web project VS modifies the configuration file to add in the AzureKeyVaultConfigBuilder as shown below.</li>
</ul>


<pre><code class="xml Web.config">&lt;configuration&gt;
&lt;configSections&gt;
&lt;section
      name="configBuilders"
      type="System.Configuration.ConfigurationBuildersSection, System.Configuration, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"
      restartOnExternalChanges="false"
      requirePermission="false" /&gt;
&lt;/configSections&gt;
&lt;configBuilders&gt;
&lt;builders&gt;
&lt;add
      name="AzureKeyVault"
      vaultName="webapplication-47-dev-kv"
      type="Microsoft.Configuration.ConfigurationBuilders.AzureKeyVaultConfigBuilder, Microsoft.Configuration.ConfigurationBuilders.Azure, Version=1.0.0.0, Culture=neutral"
      vaultUri="https://WebApplication-47-dev-kv.vault.azure.net" /&gt;
&lt;/builders&gt;
&lt;/configBuilders&gt;
</code></pre>

<p>To start using Azure Key Vault from your application we first need to add some Secrets to the Key Vault created by Visual Studio. You can add a secret to the portal using multiple ways, the most straightforward being <a href="https://rahulpnath.com/blog/managing-key-vault-through-azure-portal/">using the Azure Portal</a>. Once you add the Secret to the Key Vault, update the configuration file with the Secret names. Below is how you would do for an ASP.NET Web Project. (<em>MySecret</em> and <em>VersionedSecret</em> keys)</p>

<div class="alert alert-warning">
Make sure to add <b>configBuilders=&#8221;AzureKeyVault&#8221;</b> to the appSettings tag. This tells the Configuraion Manager to use the configured AzureKeyVaultConfigBuilder
</div>


<pre><code class="xml">&lt;appSettings configBuilders="AzureKeyVault"&gt;
      &lt;add key="webpages:Version" value="3.0.0.0" /&gt;
      &lt;add key="webpages:Enabled" value="false" /&gt;
      &lt;add key="ClientValidationEnabled" value="true" /&gt;
      &lt;add key="UnobtrusiveJavaScriptEnabled" value="true" /&gt;
      &lt;add key="MySecret" value="dummy1"/&gt;
      &lt;add key="VersionedSecret" value="dummy2"/&gt;
&lt;/appSettings&gt;
</code></pre>

<p>The values <em>dummy*</em> are just dummy values and will be overridden at runtime from the Secret Values created in the Key Vault. If the Secret with the corresponding name does not exist in Key Vault, then the <em>dummy</em> values will be used.</p>

<h3>Authentication</h3>

<p>When VS creates the Vault, it adds in the user logged into VS to the Access Policies list. When running the application, the AzureKeyVaultConfigBuilder uses the same details to authenticate with the Key Vault.</p>

<blockquote><p>If you are not logged in as the same user or not logged in at all the provider will not be able to authenticate with the Key Vault and will fallback to use the dummy values in the configuration file. Alternatively you could specify <a href="https://docs.microsoft.com/en-us/azure/key-vault/service-to-service-authentication#connection-string-support">connection option avaiable for AzureServiceTokenProvider</a></p></blockquote>

<p><img class =" center" src="/images/keyVault_connectedService_AccessPolicies.png" alt="Visual Studio, Azure Key Vault Connected Services" /></p>

<h3>Secrets and Versioning</h3>

<p>The <a href="https://github.com/aspnet/MicrosoftConfigurationBuilders/tree/master/src/Azure">AzureKeyVaultConfigBuilder</a> requests to get all the Secrets in the Key Vault at application startup using the <a href="https://docs.microsoft.com/en-us/rest/api/keyvault/getsecrets/getsecrets">Secrets endoint</a>. This call returns all the Secrets in the Key Vault. For whatever keys in the AppSettings that has a match with a Secret in the vault, a request is made to get the <a href="https://docs.microsoft.com/en-us/rest/api/keyvault/getsecret/getsecret">Secret details</a>, which returns the actual Secret value for the keys. Below are the traces of the calls going out captured using <a href="https://rahulpnath.com/blog/fiddler-free-web-debugging-proxy/">Fiddler</a>.</p>

<p><img class =" center" src="/images/keyVault_connectedService_requests.png" alt="AzureKeyVaultConfigBuilder Fiddler Traces " /></p>

<p>It looks like at the moment the AzureKeyVaultConfigBuilder get only the latest version of the Secrets. As you can tell from one of my Secret names (VersionedSecret), I have created two versions for the Secret, and the config builder picks the latest version. I don&rsquo;t see a way right now whereby I can specify a specific secret version.</p>

<p>The Visual Studio Connected Services makes it easy to get started with Azure Key Vault and move your secrets to a more secure store, than having it around in your <a href="https://rahulpnath.com/blog/keeping-sensitive-configuration-data-out-of-source-control/">configuration files</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Authenticating with Azure Key Vault Using Managed Service Identity]]></title>
    <link href="http://rahulpnath.com/blog/authenticating-with-azure-key-vault-using-managed-service-identity/"/>
    <updated>2017-10-18T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/authenticating-with-azure-key-vault-using-managed-service-identity</id>
    <content type="html"><![CDATA[<p><strong><em>How do you secure the access keys to the Key Vault itself?</em></strong>.</p>

<p>If you use ClientId/Secret to authenticate with a key vault, then you are likely to end up having these in the web.config file (<a href="http://www.rahulpnath.com/blog/keeping-sensitive-configuration-data-out-of-source-control/">there still are ways around</a>) which is what we initially set out to avoid, by using Azure Key Vault. The recommended approach till now was to use certificate-based authentication so that you need to have only the thumbprint id of the certificate in the web.config and you can deploy the certificate along with the application. If you are not familiar with either way of authenticating with Key Vault, then check out this <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">article</a>. With the Secret or certificate-based authentication, we also run into the problem of credentials expiring which in turn can lead to application downtime.</p>

<p>Managed Service Identity (MSI) solves this problem by allowing an Azure App Service, Azure Virtual Machines or Azure Functions to connect to Key Vault (and a few other services) without any explicit credentials in the code.</p>

<blockquote><p><em><a href="https://docs.microsoft.com/en-us/azure/active-directory/msi-overview">Managed Service Identity</a> (MSI) makes solving this problem simpler by giving Azure services an automatically managed identity in Azure Active Directory (Azure AD). You can use this identity to authenticate to any service that supports Azure AD authentication, including Key Vault, without having any credentials in your code.</em></p></blockquote>

<p>MSI can be enabled through the Azure Portal. E.g., to enable MSI for App Service, the portal has an option as shown below.</p>

<p><img src="/images/keyvault_managed_service_identity.png" class="center" alt="Enable Managed Service Identity for Azure App Service" /></p>

<p>Once enabled we can add an access policy in the key vault to give permissions to the Azure App service. Search by the app service name and assign the required access policies.</p>

<p>For an application to access the key vault, we need to use <em>AzureServiceTokenProvider</em> from <a href="https://www.nuget.org/packages/Micros">Microsoft.Azure.Services.AppAuthentication</a> NuGet package. Instead of using the ClientCredential or ClientAssertionCertificate to acquire the token, we will use AzureServiceTokenProvider to acquire the token for us.</p>

<pre><code class="csharp">var azureServiceTokenProvider = new AzureServiceTokenProvider();
var keyVaultClient = new KeyVaultClient(new KeyVaultClient.AuthenticationCallback(azureServiceTokenProvider.KeyVaultTokenCallback));
</code></pre>

<p><em>The <a href="https://azure.microsoft.com/en-us/resources/samples/app-service-msi-keyvault-dotnet/">AzureServiceTokenProvider</a> class tries the following methods to get an access token:-</em></p>

<ol>
<li><em>Managed Service Identity (MSI) - for scenarios where the code is deployed to Azure, and the Azure resource supports MSI.</em></li>
<li><em>Azure CLI (for local development) - Azure CLI version 2.0.12 and above supports the get-access-token option. AzureServiceTokenProvider uses this option to get an access token for local development.</em></li>
<li><em>Active Directory Integrated Authentication (for local development). To use integrated Windows authentication, your domain’s Active Directory must be federated with Azure Active Directory. Your application must be running on a domain-joined machine under a user’s domain credentials.</em></li>
</ol>


<h3>Local Development</h3>

<p>For the AzureServiceTokenProvider to work locally we need to install the <a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest">Azure CLI</a> and also setup an environment variable - <em>AzureServicesAuthConnectionString</em>. Depending on whether you want to use ClientId/Secret or ClientId/Certificate-based authentication the value for the environment variable changes.</p>

<pre><code class="text">AzureServicesAuthConnectionString to RunAs=App;AppId=AppId;TenantId=TenantId;AppKey=Secret.
Or
RunAs=App;AppId=AppId;TenantId=TenantId;CertificateThumbprint=Thumbprint;CertificateStoreLocation=CurrentUser
</code></pre>

<p><img src="/images/kkeyvault_msi_tenantId.png" class="center" alt="Get Tenant Id and AppId" /></p>

<p>As shown above, you can get the TenantId and AppId from the App Registrations page in the Azure portal. Clicking on the Endpoints button reveals a list of URL&rsquo;s which has the TenantId GUID. The AppId is displayed against each of the AD application. Once you set the environment variable, the application will be able to connect to Key Vault without any additional configuration entries in web/app config.</p>

<p>Azure Managed Service Identity makes it easier to connect to Key Vault and removes the need of having any sensitive information in the application configuration file. It also helps remove the overhead of renewing the certificate/secrets used to connect to the Vault. One less thing to worry about the application!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Signing a PDF File Using Azure Key Vault]]></title>
    <link href="http://rahulpnath.com/blog/signing-a-pdf-file-using-azure-key-vault/"/>
    <updated>2017-07-18T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/signing-a-pdf-file-using-azure-key-vault</id>
    <content type="html"><![CDATA[<p><em>How to sign a PDF using Azure Key Vault?</em> - This is one of the questions that I often get regarding Azure Key Vault. In this post, we will explore how to sign a PDF using a certificate in Azure Key Vault. Signing a PDF has various aspects to it which are covered in depth in the white paper - <a href="http://developers.itextpdf.com/books#digsig">Digital Signatures for PDF Documents</a>. We will be using the <a href="http://itextpdf.com/">iText library</a> to sign the PDF. iText is available as a <a href="https://www.nuget.org/packages/itext7/">Nuget package library</a>. The below image shows the elements that composes a digital signature on the left and actual contents on the right.</p>

<p><img src="/images/adobe_signature.png" alt="Digitally Signed PDF Contents" /></p>

<h3>Signing with a Local Certificate</h3>

<p>When the certificate (along with the private key) is available locally, signing the PDF is straightforward. You can load the certificate as an X509Certificate from the local certificate store using the <a href="https://stackoverflow.com/questions/11115511/how-to-find-certificate-by-its-thumbprint-in-c-sharp">thumbprint</a>. Make sure that the certificate is installed with the Exportable option as shown below.</p>

<p><img src="/images/certificate_exportable.png" alt="Exportable certificate" /></p>

<p>The <a href="http://itextsupport.com/apidocs/itext5/latest/com/itextpdf/text/pdf/security/PrivateKeySignature.html">PrivateKeySignature</a> is an implementation of IExteralSignature that can be used to sign the PDF when the private key is available. The below code signs the <em>Hello World.pdf</em> using the certificate from the local store and saves that as <em>Local Key.pdf</em>.</p>

<pre><code class="csharp">private static void SignPdfWithLocalCertificate()
{
    var certificate = GetCertificateLocal();
    var privateKey = DotNetUtilities.GetKeyPair(certificate.PrivateKey).Private;
    var externalSignature = new PrivateKeySignature(privateKey, "SHA-256");
    SignPdf(certificate, externalSignature, "Local Key.pdf");
}

private static void SignPdf(X509Certificate2 certificate, IExternalSignature externalSignature, string signedPdfName)
{
    var bCert = DotNetUtilities.FromX509Certificate(certificate);
    var chain = new Org.BouncyCastle.X509.X509Certificate[] { bCert };

    using (var reader = new PdfReader("Hello World.pdf"))
    {
        using (var stream = new FileStream(signedPdfName, FileMode.OpenOrCreate))
        {
            var signer = new PdfSigner(reader, stream, false);
            signer.SignDetached(externalSignature, chain, null, null, null, 0, PdfSigner.CryptoStandard.CMS);
        }
    }
}
</code></pre>

<h3>Certificates in Azure Key Vault</h3>

<p>You can <a href="http://www.rahulpnath.com/blog/manage-certificates-in-azure-key-vault/">manage certificates in Azure Key Vault</a> as a first class citizen. Azure Key Vault supports creating new or uploading existing certificates into the vault. Key Vault provides an option to specify whether the private portion of the certificate is exportable or not. Let us see how we can use the certificate from the vault in both these scenarios.</p>

<h4><strong>Exportable Certificate</strong></h4>

<p>To create a self-signed certificate in the vault use the below PowerShell script. In this case, the private key is exportable. Executing the below script adds a self-signed certificate into the vault.</p>

<pre><code class="powershell">$certificatepolicy = New-AzureKeyVaultCertificatePolicy   -SubjectName "CN=www.rahulpnath.com"   -IssuerName Self   -ValidityInMonths 12
Add-AzureKeyVaultCertificate -VaultName "VaultFromCode" -Name "TestCertificate" -CertificatePolicy $certificatepolicy
</code></pre>

<p><img src="/images/keyvault_getazurekeyvaultcertificate.png" class="center" alt="Key Vault Certificate" /></p>

<p>Creating a certificate, in turn, creates three objects in the vault - Certificate, Key, and Secret. The certificate represents the certificate just created, the Key represents the private part of the certificate, and the Secret has the certificate in PFX format (just as if you had uploaded a <a href="http://www.rahulpnath.com/blog/pfx-certificate-in-azure-key-vault/">PFX as a Secret</a>). Since the certificate created above is exportable, the Secret contains the Private portion of the key as well. To recreate the certificate locally in memory, we use the below code</p>

<pre><code class="csharp">public static async Task&lt;X509Certificate2&gt; GetCertificateKeyVault(string secretIdentifier)
{
    var client = GetKeyVaultClient();
    var secret = await client.GetSecretAsync(secretIdentifier);

    var certSecret = new X509Certificate2(
        Convert.FromBase64String(secret.Value),
        string.Empty,
        X509KeyStorageFlags.Exportable);

    return certSecret;
}
</code></pre>

<p>The certificate is encoded as Base64String in the Secret. We create an in-memory representation of the certificate and mark it as <em>Exportable</em>. This certificate can be used the same way as the local certificate. Since the private key is part of it, the PrivateKeySignature can still be used to sign.</p>

<h4><strong>Non Exportable Certificate</strong></h4>

<p>To create a non-exportable certificate when creating the certificate use <a href="https://docs.microsoft.com/en-us/powershell/module/azurerm.keyvault/new-azurekeyvaultcertificatepolicy?view=azurermps-4.1.0"><em>KeyNotExportable</em> flag</a> flag as below.</p>

<pre><code class="powershell">$certificatepolicy = New-AzureKeyVaultCertificatePolicy   -SubjectName "CN=www.rahulpnath.com"   -IssuerName Self   -ValidityInMonths 12 -KeyNotExportable 
Add-AzureKeyVaultCertificate -VaultName "VaultFromCode" -Name "TestCertificateNE" -CertificatePolicy $certificatepolicy
</code></pre>

<p>Executing this creates three objects in the vault as above. But since we marked the secret as non-exportable, the Secret will not have the private part of the key. We can create an in-memory representation of the certificate, but we cannot use the PrivateKeySignature as the certificate does not have the private key. We need to use the Key created along with the certificate to <em>Sign</em> the PDF bytes. For this we need a custom implementation of <em>IExternalSignature</em> - KeyVaultSignature.</p>

<pre><code class="csharp">public class KeyVaultSignature : IExternalSignature
{
    private KeyVaultClient keyClient;
    private string keyIdentifier;

    public KeyVaultSignature(KeyVaultClient client, string keyIdentifier)
    {
        keyClient = client;
        this.keyIdentifier = keyIdentifier;
    }
    public string GetEncryptionAlgorithm()
    {
        return "RSA";
    }

    public string GetHashAlgorithm()
    {
        return "SHA-256";
    }

    public byte[] Sign(byte[] message)
    {
        var hasher = new SHA256CryptoServiceProvider();
        var digest = hasher.ComputeHash(message);

        return keyClient
            .SignAsync(
                keyIdentifier,
                Microsoft.Azure.KeyVault.WebKey.JsonWebKeySignatureAlgorithm.RS256,
                digest)
            .Result.Result;
    }
}
</code></pre>

<p>KeyVaultSignature uses the key vault library to connect to the vault and use the specified key to sign the passed in PDF bytes. Since the key is the private part of the certificate, it will be validated by the public key. Below code shows how to use the KeyVaultSignature in the signing process.</p>

<pre><code class="csharp">private static async Task SignPdfWithNonExportableCertificateInKeyVault()
{
    var client = GetKeyVaultClient();
    var exportableSecretIdentifier = "https://vaultfromcode.vault.azure.net:443/secrets/TestCertificateNE";
    var certificate = await GetCertificateKeyVault(exportableSecretIdentifier);

    var keyIdentifier = "https://vaultfromcode.vault.azure.net:443/keys/TestCertificateNE/65d27605fdf74eb2a3f807827cd756e1";
    var externalSignature = new KeyVaultSignature(client, keyIdentifier);

    SignPdf(certificate, externalSignature, "Non Exportable Key Vault.pdf");
}
</code></pre>

<p>Once you install and trust the public portion of the certificates, you can see the green tick, indicating that the PDF is verified and signed.</p>

<p><img src="/images/pdf_signed.png" alt="Signed PDF" /></p>

<p>The sample code for all three scenarios is available <a href="https://github.com/rahulpnath/Blog/tree/master/PDFSign">here</a>. I have used ClientId/Secret to authenticate with Key Vault for the sample code. If you are using this in a production environment, I will recommend using <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">certificate to authenticate with Key Vault</a>. iText supports creating PDF stamps and more features in the signing process, which is well documented. Hope this helps you to secure your PDF files.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Azure Key Vault From Node.js]]></title>
    <link href="http://rahulpnath.com/blog/azure-key-vault-from-node-dot-js/"/>
    <updated>2017-06-12T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/azure-key-vault-from-node-dot-js</id>
    <content type="html"><![CDATA[<p><img src="/images/nodejs_keyvault.png" alt="Azure Key Vault from Node js" class="center" /></p>

<p>If you develop on Node.js, you can use the <a href="https://github.com/Azure/azure-sdk-for-node">Azure SDK for Node</a> that makes it easy to consume and manage Microsoft Azure Services. In this post let&rsquo;s explore how to use the node SDK to connect to Azure Key Vault and interact with the vault objects. If you are new to key vault check out my <a href="http://www.rahulpnath.com/blog/category/azure-key-vault/">other posts here to get started</a>.</p>

<p>The <a href="https://www.npmjs.com/package/azure-keyvault">azure-keyvault</a> npm (node package manager) package allows accessing keys, secrets, and certificates on Azure Key Vault. It required Node.js version 6.x.x or higher. You can get the <a href="https://nodejs.org/en/">latest Node.js version here</a>.</p>

<blockquote><p><strong>Package Features</strong></p>

<ul>
<li><p><em>Manage keys: create, import, update, delete, backup, restore, list and get.</em></p></li>
<li><p><em>Key operations: sign, verify, encrypt, decrypt, wrap, unwrap.</em></p></li>
<li><p><em>Secret operations: set, get, update and list.</em></p></li>
<li><p><em>Certificate operations: create, get, update, import, list, and manage contacts and issuers.</em></p></li>
</ul>
</blockquote>

<p>It is easy to setup a new project and execute code using Node. The ease of setup is one of the things that I liked about node. To try out the Key Vault package, you can start fresh in a new folder and create a javascript file - <em>main.js</em> (you can name it anything you want).</p>

<p>The following packages are <em>required</em> to connect to the vault and authenticate. The <em><a href="https://www.npmjs.com/package/azure-keyvault">azure-keyvault</a></em> package as we saw above provides capabilities to interact with the vault. The <a href="https://www.npmjs.com/package/adal-node"><em>adal-node</em></a> is the Windows Active Directory Authentication Library for Node. The package makes it easy to authenticate to AAD to access AAD protected web resources. Applications using key vault need to <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">authenticate using a token from an Azure AD Application</a>.</p>

<pre><code class="js">const KeyVault = require('azure-keyvault');
const { AuthenticationContext } = require('adal-node')
</code></pre>

<h4><strong>Authenticate Using ClientId and Secret</strong></h4>

<p>Create the Azure AD application and the Secret key as shown in <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">this post</a>. Grab the ClientId and Secret for authentication from the node application.</p>

<pre><code class="js">const clientId = "CLIENT ID";
const secret = "SECRET";

var secretAuthenticator = function (challenge, callback) {

    var context = new AuthenticationContext(challenge.authorization);
    return context.acquireTokenWithClientCredentials(
        challenge.resource,
        clientId,
        secret,
        function (err, tokenResponse) {
            if (err) throw err;

            var authorizationValue = tokenResponse.tokenType + ' ' + tokenResponse.accessToken;
            return callback(null, authorizationValue);
        });
};
</code></pre>

<p>To access the vault, we need to create an instance of the KeyVaultClient object which taken in a Credentials as shown below. The KeyVaultClient has different methods exposes to interact with keys, secrets, and certificates in the vault. For e.g. To retrieve a secret from the vault the <em>getSecret</em> method is used passing in the secret identifier.</p>

<pre><code class="js">const secretUrl = "https://rahulkeyvault.vault.azure.net/secrets/ApiKey/b56396d7a46f4f848481de2e149ef069";
var credentials = new KeyVault.KeyVaultCredentials(secretAuthenticator);
var client = new KeyVault.KeyVaultClient(credentials);

client.getSecret(secretUrl, function (err, result) {
    if (err) throw err;

    console.log(result);
});
</code></pre>

<h4><strong>Authenticate Using ClientId and Certificate</strong></h4>

<p>To authenticate using ClientId and Certificate the AuthenticationContext exposes a function <em>acquireTokenWithClientCertificate</em> which takes in the certificate (pem format) and the certificate thumbprint. If you already have a certificate go ahead and use that. If not create a new test certificate as shown below</p>

<pre><code class="bash">makecert -sv mykey.pvk -n "cn=AD Test Vault Application" ADTestVaultApplication.cer -b 03/03/2017 -e 06/05/2018 -r
pvk2pfx -pvk mykey.pvk -spc ADTestVaultApplication.cer -pfx ADTestVaultApplication.pfx -po test
</code></pre>

<p>Create a new AD application and set it to use certificate authentication. Assign the application permissions to access the key vault.</p>

<pre><code class="powershell">$certificateFilePath = "C:\certificates\ADTestVaultApplication.cer"
$certificate = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
$certificate.Import($certificateFilePath)
$rawCertificateData = $certificate.GetRawCertData()
$credential = [System.Convert]::ToBase64String($rawCertificateData)
$startDate= [System.DateTime]::Now
$endDate = $startDate.AddYears(1)
$adApplication = New-AzureRmADApplication -DisplayName "CertAdApplication" -HomePage  "http://www.test.com" -IdentifierUris "http://www.test.com" -CertValue $credential  -StartDate $startDate -EndDate $endDate

$servicePrincipal = New-AzureRmADServicePrincipal -ApplicationId $adApplication.ApplicationId

Set-AzureRmKeyVaultAccessPolicy -VaultName 'RahulKeyVault' -ServicePrincipalName $servicePrincipal.ServicePrincipalNames[0] -PermissionsToSecrets all -PermissionToKeys all 
</code></pre>

<p>To convert the pvk file into the pem format that is required by adal-node to authenticate with the AD application use the below command.</p>

<pre><code class="bash">openssl rsa -inform pvk -in mykey.pvk -outform pem -out mykey.pem
</code></pre>

<p>Using the pem encoded certificate private key, we can authenticate with the vault as shown below.</p>

<pre><code class="js">function getPrivateKey(filename) {
    var privatePem = fs.readFileSync(filename, { encoding: 'utf8' });
    return privatePem;
}

var certificateAuthenticator = function (challenge, callback) {
    var context = new AuthenticationContext(challenge.authorization);

    return context.acquireTokenWithClientCertificate(
        challenge.resource,
        clientId,
        getPrivateKey("mykey.pem"),
        "CERTIFICATE THUMBPRINT",
        function (err, tokenResponse) {
            if (err) throw err;

            var authorizationValue = tokenResponse.tokenType + ' ' + tokenResponse.accessToken;
            return callback(null, authorizationValue);
        }
    )
};
</code></pre>

<p>Using the <em>certificateAuthenticator</em> is the same as using the <em>secretAuthenticator</em>, by passing it to <em>KeyVaultCredentials</em></p>

<pre><code class="js">var credentials = new KeyVault.KeyVaultCredentials(certificateAuthenticator);
var client = new KeyVault.KeyVaultClient(credentials);

client.getSecret(secretUrl, function (err, result) {
    if (err) throw err;

    console.log(result);
});
</code></pre>

<p>To run the application first run <em>npm install</em> to install all the required packages and then execute the js file using <em>node main.js</em>. It fetches the secret value from the key vault using the certificate or secret authenticator. Hope this helps you to get started with Azure Key Vault from Node.js.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Azure Key Vault From Azure Functions - Certificate Based Authentication]]></title>
    <link href="http://rahulpnath.com/blog/azure-key-vault-from-azure-functions-certificate-based-authentication/"/>
    <updated>2017-05-25T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/azure-key-vault-from-azure-functions-certificate-based-authentication</id>
    <content type="html"><![CDATA[<p>In the previous post we saw how to connect to <a href="/blog/azure-key-vault-from-azure-functions/">Azure Key Vault from Azure Functions</a>. We used the <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">Application Id and Secret to authenticate with the Azure AD Application</a>. Since the general recommendation is to use certificate-based authentication, in this post, we will see how we can use certificates to authenticate from within an Azure Function.</p>

<p>First, we need to create an Azure AD application and set it up to use certificate-based authentication. Create a new service principal for the AD application and associate that with the Azure Key Vault. Authorize the AD application with the permissions required. In this case, I am providing all access to keys and secrets.</p>

<pre><code class="powershell">$certificateFilePath = "C:\certificates\ADTestVaultApplication.cer"
$certificate = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
$certificate.Import($certificateFilePath)
$rawCertificateData = $certificate.GetRawCertData()
$credential = [System.Convert]::ToBase64String($rawCertificateData)
$startDate= [System.DateTime]::Now
$endDate = $startDate.AddYears(1)
$adApplication = New-AzureRmADApplication -DisplayName "CertAdApplication" -HomePage  "http://www.test.com" -IdentifierUris "http://www.test.com" -CertValue $credential  -StartDate $startDate -EndDate $endDate

$servicePrincipal = New-AzureRmADServicePrincipal -ApplicationId $adApplication.ApplicationId

Set-AzureRmKeyVaultAccessPolicy -VaultName 'RahulKeyVault' -ServicePrincipalName $servicePrincipal.ServicePrincipalNames[0] -PermissionsToSecrets all -PermissionToKeys all 
</code></pre>

<p>Create an Azure Function App under your subscription as shown below. You can also use the same application created in the previous post (if you did create one).</p>

<p><img src="/images/azureFunction_newFunctionApp.png" alt="Azure Function New App" class="center" /></p>

<p>In the Function Apps page, select the app just created. Add a new function like in the last post. Selecting the Function App shows the available set of actions. Under the <em>Platform Features</em> tab we can upload the SSL certificates first and then update the Application Certificates to make the certificate available for the function.</p>

<p><img src="/images/azureFunction_PlatformFeatures.png" alt="Azure Function Platform Features" class="center" /></p>

<p>Upload the certificate by selecting it from your folder system.</p>

<p><img src="/images/azureFunction_addCertificate.png" alt="Azure Function Upload Certificate" class="center" /></p>

<p>For the certificate to be available for use in the Azure Functions an entry should be present in Application Settings. Under <em>Application Settings</em> in the <em>Platform Features</em> tab add App settings key and value - <em>WEBSITE_LOAD_CERTIFICATES</em> and the certificate thumbprint This makes the certificate available for consumption within the function. Multiple thumbprints can be specified comma separated if required.</p>

<p><img src="/images/azureFunction_AppSetting.png" alt="Azure Function Certificates App Settings" class="center" /></p>

<p>Using a certificate to authenticate with the Key Vault is the same as we have <a href="http://www.rahulpnath.com/blog/authenticating-a-client-application-with-azure-key-vault/">seen before</a>.</p>

<pre><code class="csharp">using System;
using Microsoft.Azure.KeyVault;
using Microsoft.IdentityModel.Clients.ActiveDirectory;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;

private const string applicationId = "AD Application ID";
private const string certificateThumbprint = "Certificate Thumbprint";

public async static Task Run(TimerInfo myTimer, TraceWriter log)
{
    var keyClient = new KeyVaultClient(async (authority, resource, scope) =&gt;
{
    var authenticationContext = new AuthenticationContext(authority, null);
    X509Certificate2 certificate;
    X509Store store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
    try
    {
        store.Open(OpenFlags.ReadOnly);
        X509Certificate2Collection certificateCollection = store.Certificates.Find(X509FindType.FindByThumbprint, certificateThumbprint, false);
        if (certificateCollection == null || certificateCollection.Count == 0)
        {
            throw new Exception("Certificate not installed in the store");
        }

        certificate = certificateCollection[0];
    }
    finally
    {
        store.Close();
    }

    var clientAssertionCertificate = new ClientAssertionCertificate(applicationId, certificate);
    var result = await authenticationContext.AcquireTokenAsync(resource, clientAssertionCertificate);
    return result.AccessToken;
});

    var secretIdentifier = "https://rahulkeyvault.vault.azure.net/secrets/mySecretName";
    var secret = await keyClient.GetSecretAsync(secretIdentifier);

    log.Info($"Secret Value: {secret}"); 
}
</code></pre>

<p>Make sure you add in the <em>project.json</em> as seen in the <a href="/blog/azure-key-vault-from-azure-functions/">previous post</a> to enable the required NuGet packages. The Azure function now uses the certificate to authenticate with Key Vault and retrieve the secret.</p>

<p>Hope this helps!</p>
]]></content>
  </entry>
  
</feed>
