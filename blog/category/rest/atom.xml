<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rest | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/rest/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2018-12-14T19:37:07+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Not All That Returns JSON is RESTful: Understanding HATEOAS]]></title>
    <link href="http://rahulpnath.com/blog/not-all-that-returns-json-is-restful-understanding-hateoas/"/>
    <updated>2014-11-10T01:38:56+00:00</updated>
    <id>http://rahulpnath.com/blog/not-all-that-returns-json-is-restful-understanding-hateoas</id>
    <content type="html"><![CDATA[<p>Though <a href="http://en.wikipedia.org/wiki/Representational_state_transfer">REST</a> has been around for a very long time, it never came into highlight as RPC/SOAP was what used commonly when building services, abstracting away all the goodness of the underlying protocol(mostly HTTP) and building messages over it, to perform client-server communication. HTTP, an Application layer protocol was used just as a transport protocol, tunneling these messages through them.</p>

<p>It&rsquo;s not long back that we saw a new technology stack come up in ASP.Net, which redefined the way we were building services - <a href="http://www.rahulpnath.com/blog/wcf-to-asp-net-web-api/">WCF to Web API</a>. This was a major shift from the RPC/SOAP style of programming to the REST architectural pattern. The main things that changed as for a developer was to start returning JSON/XML instead of SOAP messages, use HTTP verbs for performing actions instead of the explicitly defined contracts and use a http client to invoke the services instead of a proxy. Thats where we (at least I) were or rather are at. But was this really what we wanted to achieve?</p>

<p><a href="http://geek-and-poke.com/geekandpoke/2013/6/14/insulting-made-easy" class="center" title="It's not RESTful, Image by geekandpoke"><img src="http://rahulpnath.com/images/not_restful.png" class="center" alt="It's not RESTful, Image by geekandpoke"></a></p>

<p>REST was originally introduced by <a href="http://roy.gbiv.com/">Roy Fielding</a> in his <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">dissertation</a> and this is how he had seen it.</p>

<blockquote><p>Representational State Transfer (REST) architectural style for distributed hypermedia systems, describing the software engineering principles guiding REST and the interaction constraints chosen to retain those principles, while contrasting them to the constraints of other architectural styles. REST is a hybrid style derived from several of the network-based architectural styles combined with additional constraints that define a uniform connector interface.</p></blockquote>

<p>We, as developers, have totally missed <strong>hypermedia</strong> and it is rarely spoken about along with REST. In fact Roy himself has called this out loud - <a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">REST APIs must be hypertext-driven</a>.</p>

<p><strong>Hypermedia and Why it is important</strong></p>

<p>The World Wide Web is the best example for hypermedia and why it is really important, because we just have a single browser that can understand all web pages of the world and not browsers for each and every web site. We send across Hyper Text(HTML) which the browser understands and uses to render the page. In this case the servers that generate these hypermedia messages(HTML) are &lsquo;smart&rsquo; enough to understand the state of the page and respond back with only the allowed actions/links back. This is the same thing that we would want our API&rsquo;s also to do - drive the application&rsquo;s state, than having the client drive the state of the application.</p>

<p>If we look at todays api&rsquo;s, we see that they return plain data and we have smart clients that are aware of the links to each resource and when and how to reach out to them. The client controls the state of the application and how to navigate through the application. An application developer would read the api documentation on what the links are for each of the actions and then hard code these details/urls into the client application. The client knows too much about the api and its structure which makes it very tightly coupled with the service, breaking it for even the slightest of change in the server.</p>

<p><strong>Hypermedia As The Engine Of Application State(HATEOAS)</strong></p>

<p>Now we really know that we do not want smart clients, at least not clients this smart as this makes it very difficult for the api to evolve. The only thing that we can now make smarter is the messages that we send across - make them hypermedia. It should just not be data but also have related links, actions and maybe also the details on how the links can be reached. The links should reflect the applications state and drive what actions are allowed for that particular state.</p>

<p>Let us take an example on how a message would be in a non-hypermedia api and a RESTful api.</p>

<pre><code class="json Smart Client Messages">{
  "account": {
    "name": "Rest",
    "accountnumber": "12345",
    "balance": "6000.00"
  }
}
</code></pre>

<pre><code class="json HATEOAS Messages">{
  "account": {
    "name": "Rest",
    "accountnumber": "9963",
    "balance": "6000.00",
    "link": [
      {
        "rel": "self",
        "href": "/account/9963",
        "method": "get"
      },
      {
        "rel": "deposit",
        "href": "/account/9963/deposit",
        "method": "post"
      },
      {
        "rel": "withdraw",
        "href": "/account/9963/withdraw",
        "method": "post"
      }
    ]
  }
}
</code></pre>

<p>As we see the first one returns just pure JSON data and leaves everything to the client to decide on whether deposit/withdraw etc are possible and if at all they are how to reach them. In this case our &lsquo;smart client&rsquo;, would check the account balance and then decide on to allow deposit/withdraw only if there are sufficient funds. In the second case for the hypermedia messages, the server returns the allowed actions for the current account and also returns on how to perform these actions. So the server decides the possible actions for a given state of the account and the client would just render these out. The client all it would be interested is in the relations, indicated by the &lsquo;rel&rsquo; attribute to decide on to show the required UI. The <a href="https://developer.paypal.com/docs/integration/direct/paypal-rest-payment-hateoas-links/">Paypal api</a> is Hypermedia driven and is a good reference to understand more of this in detail.</p>

<p><strong>HATEOAS and Documentation</strong></p>

<p>One of the most popular discussion that you see around is that, &lsquo;Oh we still need api documentation and developers still need them to develop for your api. So what are we really achieving&rsquo;</p>

<blockquote><p><strong>HATEOAS is not about avoiding documentation.</strong></p></blockquote>

<p>It just is not. We still need a documentation to detail out what the rel&rsquo;s are and how to reach them and what they mean. But you don&rsquo;t need to put out explicit url&rsquo;s saying that this is where you need to reach for this particular action. There are a lot of relations that are already <a href="http://www.iana.org/assignments/link-relations/link-relations.xhtml">standardized</a>, and for anything specific to the api can be documented. Also the state of the application is driven by the server and not by consuming client.</p>

<p><strong>Client and Server updates</strong></p>

<p>Following the HATEOAS approach might end us with having even smarter clients which could automatically upgrade to a newer server version without any code change. Let&rsquo;s take an example of a social media site like Facebook which has two options today for any comment or post - Share and Like. If these were shown interpreting the links as provided from the server, we could easily add in a new option Dislike, in the server response and it would have automatically show up in the UI without any code change. This might not be true always but can definitely be an option.</p>

<blockquote><p>Smart messages gives us Smarter clients</p></blockquote>

<p><strong>Hypermedia Types</strong></p>

<p>Links are an integral part of hypermedia, but JSON/XML formats that are popular today, does not inherently support links.There are a couple of new media types that has emerged that provides support for hypermedia formats: HAL, JSON-LD, Collection+JSON, SIREN. A good discussion comparing these available options is available <a href="http://sookocheff.com/posts/2014-03-11-on-choosing-a-hypermedia-format/">here</a>.</p>

<p><a href="http://martinfowler.com/articles/richardsonMaturityModel.html">Richardson Maturity Model</a> is a good model while thinking about REST and can help us while building services.</p>

<p>Level 0 - The Swamp of POX<br/>
Level 1 - Resources<br/>
Level 2 - HTTP Verbs<br/>
Level 3 - Hypermedia Controls</p>

<p>Though Level 3 is no litmus test for being RESTful, you are at least in clear sight of where we all want to be. It provides a step by step way in designing and achieving REST. Are you already building Hypermedia driven api&rsquo;s? If not, hope this at least makes you to give a thought the next time you develop an api.</p>

<p>Additional Resources:</p>

<ul>
<li><p><a href="http://www.amazon.com/gp/product/0596805829/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0596805829&amp;linkCode=as2&amp;tag=rahulpnath-20&amp;linkId=DWVB6DWLT4IA2H3E">Rest In Practice: Hypermedia and Systems Architecture </a></p></li>
<li><p><a href="http://www.amazon.com/gp/product/1449358063/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1449358063&amp;linkCode=as2&amp;tag=rahulpnath-20&amp;linkId=QVBLKISYQTJ7HY2R">RESTful Web APIs</a></p></li>
<li><p><a href="http://www.amazon.com/gp/product/1449337716/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1449337716&amp;linkCode=as2&amp;tag=rahulpnath-20&amp;linkId=TD7FYXTI77G4P2GF">Designing Evolvable Web APIs with ASP.NET</a></p></li>
<li><p><a href="https://delicious.com/rahulpnath/hypermedia">Blogs and other links</a>
<a href="http://www.codeproject.com" style="display:none" rel="tag">CodeProject</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows 8 Series - Incremental Loading]]></title>
    <link href="http://rahulpnath.com/blog/windows-8-series-incremental-loading/"/>
    <updated>2012-10-28T14:41:31+00:00</updated>
    <id>http://rahulpnath.com/blog/windows-8-series-incremental-loading</id>
    <content type="html"><![CDATA[<p>Fast and fluid experience is one of the most important characteristics of a Windows 8 application. As the data becomes larger , it might not be always possible to get the entire data loaded before hand.We might want to have a incremental or sequential data loading so that the user has a better experience.
While developing windows 8 this can be easily achieved by using <a href="http://msdn.microsoft.com/en-us/library/windows/apps/Hh701916">ISupportIncrementalLoading</a>
interface which would load the data incrementally.The class that implements this should also implement the <a href="http://msdn.microsoft.com/en-us/library/system.collections.ilist.aspx">IList</a> and <a href="http://msdn.microsoft.com/en-us/library/system.collections.specialized.inotifycollectionchanged.aspx">INotifyColectionChanged</a>. A sample on how to implement this interface can be seen <a href="http://msdn.microsoft.com/en-us/library/windows/apps/Hh701916">here</a>.
Implementing these over and over for different data sources that you would want to load incrementally might soon become tedious and repetitive.So why not make up some generic classes that you could abstract away the task of loading the data incrementally. That&rsquo;s exactly what we would be looking into here.</p>

<p>First lets get the class that implements <a href="http://msdn.microsoft.com/en-us/library/windows/apps/Hh701916">ISupportIncrementalLoading</a>, IList and INotifyCollectionChanged. To keep things simple lets inherit from ObservableCollection,which in turn inherits the latter 2 interfaces</p>

<pre><code class="csharp">    public class IncrementalSource&lt;T, K&gt; : ObservableCollection&lt;K&gt;, ISupportIncrementalLoading
        where T: class
    {
        private string Query { get; set; }
        private int VirtualCount { get; set; }
        private int CurrentPage { get; set; }
        private IPagedSource&lt;T,K&gt; Source { get; set; }
        private int rpp { get; set; }

        public IncrementalSource(string query, Func&lt;T, IPagedResponse&lt;K&gt;&gt; GetPagedResponse)
        {
            this.Source = new PagedSourceLoader&lt;T, K&gt;(GetPagedResponse);
            this.VirtualCount = int.MaxValue;
            this.CurrentPage = 0;
            this.Query = query;
        }

        #region ISupportIncrementalLoading

        public bool HasMoreItems
        {
            get { return this.VirtualCount &gt; this.CurrentPage * (rpp == 0 ? 10 :rpp); }
        }

        public IAsyncOperation&lt;LoadMoreItemsResult&gt; LoadMoreItemsAsync(uint count)
        {
            CoreDispatcher dispatcher = Window.Current != null ? Window.Current.Dispatcher : Windows.ApplicationModel.Core.CoreApplication.MainView.CoreWindow.Dispatcher;
            if (count &gt; 50 || count &lt;= 0)
            {
                // default load count to be set to 50
                count = 50;
            }

            return Task.Run&lt;LoadMoreItemsResult&gt;(
                async () =&gt;
                {

                    IPagedResponse&lt;K&gt; result = await this.Source.GetPage(string.Format(this.Query,count), ++this.CurrentPage, (int)count);

                    this.VirtualCount = result.VirtualCount;
                    if (rpp == 0)
                    {
                        rpp = result.rpp;
                    }

                    await dispatcher.RunAsync(
                        CoreDispatcherPriority.Normal,
                        () =&gt;
                        {
                            foreach (K item in result.Items)
                                this.Add(item);
                        });

                    return new LoadMoreItemsResult() { Count = (uint)result.Items.Count() };

                }).AsAsyncOperation&lt;LoadMoreItemsResult&gt;();
        }

        #endregion
    }
</code></pre>

<p>Before going into the details of the code, lets understand what this class is going to do for us. We need to load data in a paged fashion from a large datasource. So we would generally be dealing with two types of object – one the type of object(<strong><em>K</em></strong>) whose list we are trying to load incrementally. Another one the type of object(<strong><em>T</em></strong>) that represents each paged request result. This object would ideally contain a property to hold list of objects of type K, the total number of items that the datasource would give us,so that we know how many pages we need to request for and also a property indicating the current page. Each datasource might return us these required properties in different property names and types. So we have a class to hold these data together for us, PagedResponse which implements IPagedResponse</p>

<pre><code class="csharp">    public interface IPagedResponse&lt;T&gt;
    {
        IEnumerable&lt;T&gt; Items { get; }
        int VirtualCount { get; }
        int rpp { get; set; } // rpp - requests per page
    }




    public class PagedResponse&lt;K&gt; : IPagedResponse&lt;K&gt;
    {
        public PagedResponse(IEnumerable&lt;K&gt; items, int virtualCount,int itemsPerPage)
        {
            this.Items = items;
            this.VirtualCount = virtualCount;
            rpp = itemsPerPage;
        }

        public int VirtualCount { get; private set; }
        public int rpp { get;  set; }
        public IEnumerable&lt;K&gt; Items { get; private set; }
    }
</code></pre>

<p>That said lets see the  <em>IncremetnalSource</em> class. It takes in the object type <strong><em>T </em></strong>and <strong><em>K.</em></strong>The constructor takes in the url where the datasource can be found.The Func&lt;T, IPagedResponse<K>> parameter represents a function that takes in the return type of the call to the url as a parameter and returns the PagedResponse type. In other words that function converts the paged request call type to the type that we use to represent it, IPagedResponse.See a sample below.</p>

<pre><code class="csharp">private PagedResponse&lt;Photo&gt; RootObjectResponse(RootObject rootObject)
{
    return new PagedResponse&lt;Photo&gt;(rootObject.photos, rootObject.total_items, rootObject.photos != null ? rootObject.photos.Count : 0);
}
</code></pre>

<p>Now we need to make the call to the datasource url. This might return us data in different formats, most popularly json or xml. So we would always want to abstract away the loading of data to another class so that we don’t get tied up with the data formats in <em>IncrementalSource.</em></p>

<p>IPagedSource&lt;T,K> will do this for us. A sample implementation of this is <em>PagedSourceLoader </em>that handles for json return type is below</p>

<pre><code class="csharp">    public interface IPagedSource&lt;R,K&gt;
    {
        Task&lt;IPagedResponse&lt;K&gt;&gt; GetPage(string query, int pageIndex, int pageSize);
    }




    public class PagedSourceLoader&lt;T,K&gt; : IPagedSource&lt;T,K&gt;
        where T:class 
    {
        private Func&lt;T, IPagedResponse&lt;K&gt;&gt; getPagedResponse;
        public PagedSourceLoader(Func&lt;T, IPagedResponse&lt;K&gt;&gt; GetPagedResponse)
        {
            getPagedResponse = GetPagedResponse;
        }

        #region IPagedSource

        public async Task&lt;IPagedResponse&lt;K&gt;&gt; GetPage(string query, int pageIndex, int pageSize)
        {
            query += "&amp;page="+pageIndex;
            HttpClient client = new HttpClient();
            HttpResponseMessage response = await client.GetAsync(query);
            var data = await response.Content.ReadAsStreamAsync();
            DataContractJsonSerializer json = new DataContractJsonSerializer(typeof(T));
            T dat = json.ReadObject(data) as T;
            return getPagedResponse(dat);
        }

        #endregion
    }
</code></pre>

<p>As you see above the <em>PagedSourceLoader</em> gets the json from the datasource url and converts to the type that we are interested in . You could always replace this class to use any other data format as you would want. Mostly you would just want one implementation for <em>IPagedSource&lt;T,K>, </em>as your data source would always return you the same data format. In case not you could inject that too into the <em>IncrementalSource</em> class.</p>

<p>I have a sample <a href="http://sdrv.ms/RdPtdL">here</a> that incrementally loads the photos from a photo site <a href="http://500px.com/flow">500px</a>. You would need to register for an to get the consumer key,which should hardly take some time <a href="http://500px.com/settings/applications?from=developers">here</a>.</p>

<p><img src="/windows8_incremental_loading.png" alt="windows8 incremental loading" /></p>

<p><a href="https://github.com/rahulpnath/Blog/tree/master/Windows8%20-%20IncrementalLoading">Download the sample source code</a></p>

<p>Keep a sample of the source code for yourself in case you wanted this specific version. I might refine this to a more usable library with couple of default <em>PagedSourceLoader.</em></p>

<p><strong>References:
</strong><a href="http://www.silverlightplayground.org/post/2012/06/10/Metro-Incrementally-load-GridView-and-ListView-with-ISupportIncrementalLoading.aspx">Metro: Incrementally load GridView and ListView with ISupportIncrementalLoading</a></p>

<p>Feel free to reuse it if you find it useful and drop a comment to refine it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started with ASP.NET Web Api]]></title>
    <link href="http://rahulpnath.com/blog/getting-started-with-asp-net-web-api/"/>
    <updated>2012-08-22T06:38:11+00:00</updated>
    <id>http://rahulpnath.com/blog/getting-started-with-asp-net-web-api</id>
    <content type="html"><![CDATA[<p>A web api is to expose your application’s programming interface over the web,using the HTTP interface.This makes the api accessible from any device that can make HTTP calls.With the wide range of devices that’s available nowadays,Web Api would be the best way to reach out to all of them.Web Api helps you to open up your application to other developers and encourage them to build device specific application.</p>

<p>Since Web Api uses HTTP,this can be accessed from any device that supports HTTP.A brief glance through the <a href="http://www.w3.org/Protocols/HTTP/1.1/rfc2616.pdf">HTTP spec</a> would be good for a better understanding on the capabilities of HTTP.The web was mostly used for human-to-machine conversations and we never felt the need of these API’s.But increasingly with different devices and applications talking with each other,machine-to-machine conversations is on the rise,making the <a href="http://www.programmableweb.com/">web programmable</a>.</p>

<p>We will be building a web api for a Cafeteria(over many blog posts) that is looking out to have a web presence,so that they can reach out easily to their customers on various devices.The cafeteria has lots of food items and beverages and they are looking for a solution where there customers can see all these items from their mobile/laptops and order these items and collect them from the counter.In this blog post we would be concentrating only on viewing/managing the food dishes/beverages and we would be building on the solution in later posts
Let’s get started building our Web API.!!</p>

<p>Fire up your Visual Studio.Get the <a href="http://www.asp.net/mvc/mvc4">ASP.NET MVC4</a> installed before that.I am having <a href="http://www.microsoft.com/visualstudio/11/en-us">VS2012</a> which has it by default.</p>

<p>Create a New Project: File –> New Project –> ASP.NET MVC4 Web Application.Enter your path and solution name and pressing Ok will give you another screen where you can select what kind of template you want to use.For this we would be using Web Api template.</p>

<p><img src="/web_api_visual_studio_template.png" alt="wep_api_visual_studio_template" /></p>

<p>On pressing Ok Visual Studio will create you a set of default controllers and views to start with.Build and run to verify that we have all set up correctly.You should be seeing a nice welcome screen if everything is fine.</p>

<p><img src="/web_api_default_template_welcome_screen.png" alt="web_api_default_template_welcome_screen" /></p>

<p>If you see in the solution explorer in Visual Studio,you notice that you already have 2 Controllers that are  created by the default template.A ‘<em>HomeController’</em> that derives from <em>Controller</em> which is your default MVC controller that just rendered out the beautiful page that you just saw above and a ‘<em>ValuesController’</em> that derives from <em>ApiController </em>which is actually our web api controller.</p>

<p>Web Api also uses routes to map URI’s to controller actions.But the difference with MVC route is that,here we have no actions specified in the route value.The HTTP method becomes the action.So your controller would have functions with the same names as the HTTP verbs(GET,PUT,POST,DELETE).If you don’t like these function names then there are attributes too that you can use to mark your own function names.We will see all this in our code.</p>

<p>The default route that is created for Web Api can be found in the <em>App_Start/WebApiConfig  _
<code>csharp
config.Routes.MapHttpRoute(
name: "DefaultApi",
routeTemplate: "api/{controller}/{id}",
defaults: new { id = RouteParameter.Optional }
);
</code>
Now that you have seen the API route,lets try invoking the </em>ValuesController <em>that got created automatically.Following the route that is specified above we need to prefix the controller with an </em>api/.<em>This is just to keep a distinction between the normal MVC controllers and the API controllers.So for the </em>ValuesController<em> we would need to invoke it with ‘</em>api/values<em>’.
To issue a GET on the controller,issue the request using the web browser as shown below.It should return you the values(‘value1’ &amp; ‘value2’ as returned in the GET of the </em>ValuesController_) in json format,as that is the default formatter that is used.</p>

<p><img src="/web_api_request_response_fiddler.png" alt="web_api_request_response_fiddler" /></p>

<p>To check the remaining of HTTP actions we would need to write the implementations for those functions as the <em>ValuesController </em>does not have that implemented.</p>

<p>So lets get back to the Cafeteria business.We will create a model to represent the FoodDishes that the cafeteria has to offer.For now we will just have a id,name and description field in the model.
&#8220;` csharp
public class FoodDish
{
public int FoodDishId { get; set; }</p>

<p>[Required]
public string FoodDishName { get; set; }</p>

<p>public string Description { get; set; }
}
&#8220;`
Note the ‘<em>[Required]</em>’ attribute on the property FoodDishName.This ensures that a value is always present for that property.This is similar to the validation in MVC.A list of supported attributes can be found <a href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.aspx">here</a>
Visual Studio will do most of  the job in creating out the controllers and the data context’s for us,with just a couple of clicks.To group the WEB API controllers together lets create a folder under the Controllers folder named ‘<em>api</em>’. This is just for a convention and is not mandatory.Right Click on the newly created ‘<em>api’ </em>folder and say Add –> Controller</p>

<p>Give the controller name as ‘FoodDishesController’.From the template drop down select the ‘API Controller with read/write actions,using Entity Framework’ option.This is what is automatically going to put out the all the code that we would required.Select the ModelClass that we created,<em>FoodDish.</em>(If you don&rsquo;t see the class in the models, build the solution before adding new controller).For the DataContext select ‘<em><New Data Context…></em>’ and enter <em>FoodDishesContext.</em>Refer the image below.</p>

<p><img src="/web_api_controller_scaffolding_dialog.png" alt="web_api_controller_scaffolding_dialog" /></p>

<p>On clicking Add,the controller gets created successfully and also the database connections are setup automatically using <a href="http://weblogs.asp.net/scottgu/archive/2010/07/16/code-first-development-with-entity-framework-4.aspx">EF Code First approach</a>.Let’s take a deeper look into the Controller that has got created.
You notice that all the methods in the controller has one of the HTTP verb prefixed.ASP.NET WEB API is intelligent enough to understand this naming convention too.So if you don’t like just the http verbs as function name you can use this approach too.Below image shows the possible combinations of function naming.You can use anyone that suites you.</p>

<p><img src="/web_api_method_definitions.png" alt="web_api_method_definitions" /></p>

<p>The WEB API is all set to be tested.To issues a GET,same as we did before,from the browser hit the ‘<em>/api/FoodDishes</em>’.The first request might take up some time to return as Entity Framework needs to set up the database.But in sometime you should get back the json result.But this time it would be a blank one as are yet to add any food dishes to the database.For that we need to do a POST to the <em>FoodDishes </em>controller.For this we will be using <a href="http://www.fiddler2.com/fiddler2/"><em>Fiddler</em></a><em>,</em>which is an excellent tool for web debugging.You should be getting to download it for free from <a href="http://www.fiddler2.com/fiddler2/version.asp">here</a>.
In Fiddler select the Composer tab and enter in the details that is required.Make the HTTP action as POST,enter the ValuesController URI,specify the <em>Content-Type</em> as ‘<em>application/json</em>’<em>  </em>and also provide the sample data as shown in the image below.</p>

<p><img src="/web_api_request_headers_fiddler.png" alt="web_api_request_headers_fiddler" /></p>

<p>On clicking execute you should be seeing an entry in fiddler with HTTP status code 201,indicating that the entry has been successfully created.In the response you can see the location of this newly created food dish and how to reach that.For me it is at ‘_<a href="http://localhost:61150/api/FoodDishes/1_">http://localhost:61150/api/FoodDishes/1_</a>&lsquo;.So we have successfully created a new fooddish.</p>

<p><img src="/web_api_response_fiddler.png" alt="web_api_response_fiddler" /></p>

<p>Now to see the newly created dish you can either use a GET on ‘/api/FoodDishes’ to get all the food dishes or GET on /api/FoodDishes/1’ to get the specific Food dish.
Now this can be accessed from any device that supports issuing HTTP calls and you have your first WEB API ready,which just does a <a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> over your FoodDishes.</p>

<p>Lets take a deeper look in the controller,to see how all this is happening.Will look into the GET and POST here in this post as DELETE and PUT would be then easy to follow.
The GET method that visual studio scaffolded for us,just returns the requested fooddish from the database.If the food item does not exists it returns a ‘NotFound’/404 error.Notice that here we are using HTTP’s error code’s so that client can easily understand the error.
&#8220;` csharp
public FoodDish GetFoodDish(int id)
{
FoodDish fooddish = db.FoodDishes.Find(id);
if (fooddish == null)
{
throw new HttpResponseException(Request.CreateResponse(HttpStatusCode.NotFound));
}</p>

<p>return fooddish;
}
<code>
The POST method,checks if the new fooddish entered is valid.In our case we have FoodDishName as a required attribute,so as long as that property is present the ModelState.IsValid would be true.If you have additional validation attributes those would be checked too.If the state is valid then the item is inserted into the database and in the response we write the Location where this new fooddish can be accessed from.This location is what we saw above in the fiddler response.If the ModelState is not valid we sent a BadRequest,so that client can recheck the data send.We can send customized error messages too back to the client,so that the client understands where exactly the issue is.I will be covering validation,authentication and error reporting in a separate post,as that calls for a deeper explanation
</code>csharp
[HttpPost]
public HttpResponseMessage CreateNewFoodDish(FoodDish fooddish)
{
if (ModelState.IsValid)
{
db.FoodDishes.Add(fooddish);
db.SaveChanges();</p>

<p>HttpResponseMessage response = Request.CreateResponse(HttpStatusCode.Created, fooddish);
response.Headers.Location = new Uri(Url.Link(&ldquo;DefaultApi&rdquo;, new { id = fooddish.FoodDishId }));
return response;
}
else
{
return Request.CreateResponse(HttpStatusCode.BadRequest);
}
}
&#8220;`
DELETE and PUT is very similar and should be easy to understand.</p>

<p>So we have our first WEB API exposed and accessible to everyone from a wide range of devices or different technology.This can be consumed for a website or a mobile or slate etc.To put it simple from any device that supports HTTP.
This should help you get started on with ASP.NET web api.There are a lot more features in ASP.Net Web api like Formatters,Odata support,hosting etc. I would be covering these too in other blog posts.There are a lot of design considerations that need to be taken on while developing API’s.There are a lot of good resource that can help you with tackling down it.I have mentioned a few below in the resources section.</p>

<p>Happy Coding !</p>

<p><strong>Resources:
</strong>None of them are specific to ASP.NET Web Api,but they should help you to get the bigger picture and also help you in designing good Web API.</p>

<ol>
<li><p><a href="http://www.w3.org/Protocols/HTTP/1.1/rfc2616.pdf">HTTP Spec</a></p></li>
<li><p><a href="http://shop.oreilly.com/product/0636920021575.do">REST Api Design Rulebook</a></p></li>
<li><p><a href="http://shop.oreilly.com/product/9780596805838.do">REST in Practice Hypermedia and Systems Architecture</a></p></li>
<li><p><a href="http://shop.oreilly.com/product/9780596529260.do">RESTful Web Services</a></p></li>
<li><p><a href="http://shop.oreilly.com/product/0636920020530.do">Building Hypermedia APIs with HTML5 and Node</a></p></li>
<li><p><a href="http://info.apigee.com/Portals/62317/docs/web%20api.pdf">Web API Design</a></p></li>
</ol>

]]></content>
  </entry>
  
</feed>
