<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: web api | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/web-api/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2018-11-05T00:02:47+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Enable Cross-Origin Requests (CORS) in ASP.Net Web API Using CorsOptions]]></title>
    <link href="http://rahulpnath.com/blog/enable-cross-origin-requests-cors-in-asp-dot-net-web-api-using-corsoptions/"/>
    <updated>2018-08-14T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/enable-cross-origin-requests-cors-in-asp-dot-net-web-api-using-corsoptions</id>
    <content type="html"><![CDATA[<p>I was setting up an API at one of the client&rsquo;s place recently and found that currently, they allow any origin to hit their API by setting the <a href="https://msdn.microsoft.com/en-us/library/dn450212(v=vs.113).aspx">CorsOptions.AllowAll</a> options. In this post, we will look at how to set the CORS options and restrict it to only the domains that you want your API to be accessed from.</p>

<h3>What is Cross-Origin Resource Sharing (CORS)</h3>

<p>Cross-Origin Resource Sharing is a way to relax the browsers <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">Same-Origin Policy</a> whereby to tell a browser to let a web application running at one origin (domain) have permission to access selected resources from a server at a different origin. By specifying the CORS header you instruct the browser to allow all allowed domains to access your resource. Most of the time for the API endpoints you want to be explicit on the hosts that can access your API. By setting CORS, you are only restricting/allowing cross-domain access originating from a browser. <strong>Setting CORS should not be mistaken for a Security feature</strong> whereby you are restricting access from any other sources. Any requests that are formed outside of the browser like using Postman, Fiddler, etc. can still make to your API and you need appropriate authorization/authentication to make sure you are not exposing data to unintended people.</p>

<p><img src="/images/cors.png" alt="Cross-Origin Request" class="center" ></p>

<h3>Enabling in Web API</h3>

<p>In Web API there are multiple ways that you can set CORS.</p>

<ul>
<li><a href="https://www.nuget.org/packages/Microsoft.Owin.Cors/">Microsoft.Owin.Cors</a></li>
<li><a href="https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Cors">Microsoft.AspNet.WebApi.Cors</a><br/>
<em>This adds <em>System.Web.Http.Cors.dll</em> assembly to your project so can be a bit of confusion if you are looking around for the DLL in the solution</em></li>
</ul>


<p>In the below snippet I am using the <em>Microsoft.Owin.Cors</em> pipeline to setup CORS for the API. The code first reads the application configuration file to get a list of semicolon (;) separated hostnames which are added to the list of allowed origins in the <a href="https://docs.microsoft.com/en-us/previous-versions/aspnet/web-frameworks/dn726408(v=vs.118)">CorsPolicy</a>. By setting the corsOptions with <em>UseCors</em> extension method, the policy gets applied to all the requests coming through the website.</p>

<pre><code class="csharp">var allowedOriginsConfig = ConfigurationManager.AppSettings["origins"];
var allowedOrigins = allowedOriginsConfig
    .Split(new[] { ";" }, StringSplitOptions.RemoveEmptyEntries);

var corsPolicy = new CorsPolicy()
{
    AllowAnyHeader = true,
    AllowAnyMethod = true,
    SupportsCredentials = true
};
foreach (var origin in allowedOrigins)
    corsPolicy.Origins.Add(origin);

var policyProvider = new CorsPolicyProvider()
{
    PolicyResolver = (context) =&gt; Task.FromResult(corsPolicy)
};
var corsOptions = new CorsOptions()
{
    PolicyProvider = policyProvider
};

app.UseCors(corsOptions);
</code></pre>

<h3>Setting Multiple CORS Policy</h3>

<p>If you want to have different CORS policies based on different Controllers/route path, you can use the <em>Map</em> function to set up the CorsOptions for specific route paths. In the below example we apply a different CorsOptions to all routes that match <em>&lsquo;/api/SpecificController&rsquo;</em> and defaults to another for all other requests.</p>

<pre><code class="csharp">app.Map(
    "/api/SpecificController",
    (appbuilder) =&gt; appbuilder.UseCors(corsOptions2));
...
app.UseCors(corsOptions1);
</code></pre>

<h3>CORS â‰  Security</h3>

<p>CORS is a way to relax the Cross-Origin Policy and in no way should be seen as a security feature. By setting CORS headers what we are saying is to allow all the additional domains in the headers also to be able to access the resource from a browser environment. However setting this, does not restrict access to your API&rsquo;s from other sources like Postman, Fiddler or from any non-browser environments. Even within browser environments, older versions of Flash allows modifying and spoofing of request headers. Ensure that you are using CORS for the correct reasons and not assume that it is providing you security against unauthorized access.</p>

<p>Hope this allows you to setup CORS on your API&rsquo;s!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Not All That Returns JSON is RESTful: Understanding HATEOAS]]></title>
    <link href="http://rahulpnath.com/blog/not-all-that-returns-json-is-restful-understanding-hateoas/"/>
    <updated>2014-11-10T01:38:56+00:00</updated>
    <id>http://rahulpnath.com/blog/not-all-that-returns-json-is-restful-understanding-hateoas</id>
    <content type="html"><![CDATA[<p>Though <a href="http://en.wikipedia.org/wiki/Representational_state_transfer">REST</a> has been around for a very long time, it never came into highlight as RPC/SOAP was what used commonly when building services, abstracting away all the goodness of the underlying protocol(mostly HTTP) and building messages over it, to perform client-server communication. HTTP, an Application layer protocol was used just as a transport protocol, tunneling these messages through them.</p>

<p>It&rsquo;s not long back that we saw a new technology stack come up in ASP.Net, which redefined the way we were building services - <a href="http://www.rahulpnath.com/blog/wcf-to-asp-net-web-api/">WCF to Web API</a>. This was a major shift from the RPC/SOAP style of programming to the REST architectural pattern. The main things that changed as for a developer was to start returning JSON/XML instead of SOAP messages, use HTTP verbs for performing actions instead of the explicitly defined contracts and use a http client to invoke the services instead of a proxy. Thats where we (at least I) were or rather are at. But was this really what we wanted to achieve?</p>

<p><a href="http://geek-and-poke.com/geekandpoke/2013/6/14/insulting-made-easy" class="center" title="It's not RESTful, Image by geekandpoke"><img src="http://rahulpnath.com/images/not_restful.png" class="center" alt="It's not RESTful, Image by geekandpoke"></a></p>

<p>REST was originally introduced by <a href="http://roy.gbiv.com/">Roy Fielding</a> in his <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">dissertation</a> and this is how he had seen it.</p>

<blockquote><p>Representational State Transfer (REST) architectural style for distributed hypermedia systems, describing the software engineering principles guiding REST and the interaction constraints chosen to retain those principles, while contrasting them to the constraints of other architectural styles. REST is a hybrid style derived from several of the network-based architectural styles combined with additional constraints that define a uniform connector interface.</p></blockquote>

<p>We, as developers, have totally missed <strong>hypermedia</strong> and it is rarely spoken about along with REST. In fact Roy himself has called this out loud - <a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">REST APIs must be hypertext-driven</a>.</p>

<p><strong>Hypermedia and Why it is important</strong></p>

<p>The World Wide Web is the best example for hypermedia and why it is really important, because we just have a single browser that can understand all web pages of the world and not browsers for each and every web site. We send across Hyper Text(HTML) which the browser understands and uses to render the page. In this case the servers that generate these hypermedia messages(HTML) are &lsquo;smart&rsquo; enough to understand the state of the page and respond back with only the allowed actions/links back. This is the same thing that we would want our API&rsquo;s also to do - drive the application&rsquo;s state, than having the client drive the state of the application.</p>

<p>If we look at todays api&rsquo;s, we see that they return plain data and we have smart clients that are aware of the links to each resource and when and how to reach out to them. The client controls the state of the application and how to navigate through the application. An application developer would read the api documentation on what the links are for each of the actions and then hard code these details/urls into the client application. The client knows too much about the api and its structure which makes it very tightly coupled with the service, breaking it for even the slightest of change in the server.</p>

<p><strong>Hypermedia As The Engine Of Application State(HATEOAS)</strong></p>

<p>Now we really know that we do not want smart clients, at least not clients this smart as this makes it very difficult for the api to evolve. The only thing that we can now make smarter is the messages that we send across - make them hypermedia. It should just not be data but also have related links, actions and maybe also the details on how the links can be reached. The links should reflect the applications state and drive what actions are allowed for that particular state.</p>

<p>Let us take an example on how a message would be in a non-hypermedia api and a RESTful api.</p>

<pre><code class="json Smart Client Messages">{
  "account": {
    "name": "Rest",
    "accountnumber": "12345",
    "balance": "6000.00"
  }
}
</code></pre>

<pre><code class="json HATEOAS Messages">{
  "account": {
    "name": "Rest",
    "accountnumber": "9963",
    "balance": "6000.00",
    "link": [
      {
        "rel": "self",
        "href": "/account/9963",
        "method": "get"
      },
      {
        "rel": "deposit",
        "href": "/account/9963/deposit",
        "method": "post"
      },
      {
        "rel": "withdraw",
        "href": "/account/9963/withdraw",
        "method": "post"
      }
    ]
  }
}
</code></pre>

<p>As we see the first one returns just pure JSON data and leaves everything to the client to decide on whether deposit/withdraw etc are possible and if at all they are how to reach them. In this case our &lsquo;smart client&rsquo;, would check the account balance and then decide on to allow deposit/withdraw only if there are sufficient funds. In the second case for the hypermedia messages, the server returns the allowed actions for the current account and also returns on how to perform these actions. So the server decides the possible actions for a given state of the account and the client would just render these out. The client all it would be interested is in the relations, indicated by the &lsquo;rel&rsquo; attribute to decide on to show the required UI. The <a href="https://developer.paypal.com/docs/integration/direct/paypal-rest-payment-hateoas-links/">Paypal api</a> is Hypermedia driven and is a good reference to understand more of this in detail.</p>

<p><strong>HATEOAS and Documentation</strong></p>

<p>One of the most popular discussion that you see around is that, &lsquo;Oh we still need api documentation and developers still need them to develop for your api. So what are we really achieving&rsquo;</p>

<blockquote><p><strong>HATEOAS is not about avoiding documentation.</strong></p></blockquote>

<p>It just is not. We still need a documentation to detail out what the rel&rsquo;s are and how to reach them and what they mean. But you don&rsquo;t need to put out explicit url&rsquo;s saying that this is where you need to reach for this particular action. There are a lot of relations that are already <a href="http://www.iana.org/assignments/link-relations/link-relations.xhtml">standardized</a>, and for anything specific to the api can be documented. Also the state of the application is driven by the server and not by consuming client.</p>

<p><strong>Client and Server updates</strong></p>

<p>Following the HATEOAS approach might end us with having even smarter clients which could automatically upgrade to a newer server version without any code change. Let&rsquo;s take an example of a social media site like Facebook which has two options today for any comment or post - Share and Like. If these were shown interpreting the links as provided from the server, we could easily add in a new option Dislike, in the server response and it would have automatically show up in the UI without any code change. This might not be true always but can definitely be an option.</p>

<blockquote><p>Smart messages gives us Smarter clients</p></blockquote>

<p><strong>Hypermedia Types</strong></p>

<p>Links are an integral part of hypermedia, but JSON/XML formats that are popular today, does not inherently support links.There are a couple of new media types that has emerged that provides support for hypermedia formats: HAL, JSON-LD, Collection+JSON, SIREN. A good discussion comparing these available options is available <a href="http://sookocheff.com/posts/2014-03-11-on-choosing-a-hypermedia-format/">here</a>.</p>

<p><a href="http://martinfowler.com/articles/richardsonMaturityModel.html">Richardson Maturity Model</a> is a good model while thinking about REST and can help us while building services.</p>

<p>Level 0 - The Swamp of POX<br/>
Level 1 - Resources<br/>
Level 2 - HTTP Verbs<br/>
Level 3 - Hypermedia Controls</p>

<p>Though Level 3 is no litmus test for being RESTful, you are at least in clear sight of where we all want to be. It provides a step by step way in designing and achieving REST. Are you already building Hypermedia driven api&rsquo;s? If not, hope this at least makes you to give a thought the next time you develop an api.</p>

<p>Additional Resources:</p>

<ul>
<li><p><a href="http://www.amazon.com/gp/product/0596805829/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0596805829&amp;linkCode=as2&amp;tag=rahulpnath-20&amp;linkId=DWVB6DWLT4IA2H3E">Rest In Practice: Hypermedia and Systems Architecture </a></p></li>
<li><p><a href="http://www.amazon.com/gp/product/1449358063/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1449358063&amp;linkCode=as2&amp;tag=rahulpnath-20&amp;linkId=QVBLKISYQTJ7HY2R">RESTful Web APIs</a></p></li>
<li><p><a href="http://www.amazon.com/gp/product/1449337716/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1449337716&amp;linkCode=as2&amp;tag=rahulpnath-20&amp;linkId=TD7FYXTI77G4P2GF">Designing Evolvable Web APIs with ASP.NET</a></p></li>
<li><p><a href="https://delicious.com/rahulpnath/hypermedia">Blogs and other links</a>
<a href="http://www.codeproject.com" style="display:none" rel="tag">CodeProject</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ASP.NET Web API and External Login - Authenticating with Social Networks]]></title>
    <link href="http://rahulpnath.com/blog/asp-dot-net-web-api-and-external-login-authenticating-with-social-networks/"/>
    <updated>2014-09-10T19:29:35+00:00</updated>
    <id>http://rahulpnath.com/blog/asp-dot-net-web-api-and-external-login-authenticating-with-social-networks</id>
    <content type="html"><![CDATA[<p>The ASP.NET Web API project created from the default template in Visual Studio 2013 comes with an option to choose the Authentication method. The &lsquo;Individual User Accounts&rsquo; option of authorization will allow users of your API to authenticate using exisitng their exisitng social networks(Facebook, Twitter, Google or Microsoft). This is a very useful feature and also speeds up the signing process, as there is little or no input required from the user and also one less password less to remember. All these social logins uses <a href="http://oauth.net/">OAuth</a> to provide authorized access to their services, and there are exisitng Owin adapters for these social networks. You could very well write a custom owin adapter to plug new authorization providers.</p>

<blockquote><p>In this post we will see how we can enable Facebook login for your API when <strong><em>the client and api are hosted on seperate domains</em></strong>.</p></blockquote>

<p>We will start off with the default template for the Web API, created by Visual Studio 2013 for Web API(File->New Project->ASP.NET Web Application->Web API with Authentication set to Individual User Accounts)</p>

<p><img src="/web_api_authentication_vs_template.png" alt="Visual Studio 2013 Web Api Template" /></p>

<p>The Account Controller has all the methods that is required for a client to authenticate with the api and get the token to access protected resources. We will go through the calls that the client app would need to perform a successful authentication. I have updated the owin nuget packages to use the latest Owin 3.0.0 packages.</p>

<p><strong>1. Getting the supported Authentication providers</strong></p>

<p>The client in it login screen would be showing the allowed authorization providers along with the normal username/password login option. The <em>ExternalLogins</em> endpoint returns all the supported external authentication providers. The supported list of providers can be added in <em>Startup.Auth.cs</em></p>

<pre><code class="csharp">app.UseFacebookAuthentication(appId: "APPID", appSecret: "APPSECRET");
</code></pre>

<p>The application id and secret can be obtained by registering for an application with the corresponding provider. For facebook you can do that <a href="https://developers.facebook.com/">here</a>. You would also need to configure the web api endpoint as a website platform when obtaining the api keys. Now on querying the endoint the client will get back the endpoint that it needs to hit when an authentication with Facebook is required. A redirect url is to be passsed along with the request, to which the api will redirect to after succesfull authentication with the token. By default email is not received from facebook, but you can override this behaviour by providing some extra options when registering the provider as shown below. The OnAuthenticated method on the FacebookProvider gets called once the user is authenticated with facebook. At this point you can get the Email details explicitly and add it to the claims.</p>

<pre><code class="csharp">var facebookProvider = new FacebookAuthenticationProvider()
{
    OnAuthenticated = (context) =&gt;
        {
            // Add the email id to the claim
            context.Identity.AddClaim(new Claim(ClaimTypes.Email, context.Email));
            return Task.FromResult(0);
        }
};
var options = new FacebookAuthenticationOptions()
              {
                  AppId = "AppId",
                  AppSecret = "AppSecret",
                  Provider = facebookProvider
              };
options.Scope.Add("email");
app.UseFacebookAuthentication(options);
</code></pre>

<p>You can also get the facebook token if required from the context and which can be used in the database to update information to facebook on behalf of the user.</p>

<p><strong>2. Making a request to an Authentication provider</strong></p>

<p>Now that we have got the list of supported list of providers, we can make the request to the required provider from the client. This is simply done by navigating to the url obtained for the corresponding provider in the previous request, i.e to the <em>ExternalLogin</em> endpoint. If the user is already authenticated (detected via cookie), then the user is redirected to the redirect url provided in above step. If the user is not authenticated then the login page of the corresponding provider will be shown and after a successfull login the redirection will happen. The token that is received here is the custom token that gets generated by the web-api and should not be mistaken for the authorization server&rsquo;s(facebook) token itself.</p>

<p>The owin middleware abstracts away the interaction with the authorization server, Facebook in our case here. On successfull login in facebook, it redirects to &lsquo;<em><a href="https://katanaproject.codeplex.com/SourceControl/latest#src/Microsoft.Owin.Security.Facebook/FacebookAuthenticationOptions.cs">/signin-facebook</a></em> along with the facebook token. We can get the username or email from the claims provided by the authentication server that can then be passed back to the client for registering the user in the next step. The <em>ExternalLoginData</em> class get the data from the claims. I have modified this to use the new Email property that we have added. To return this email address to the client, we need to override the method as shown below in ApplicationOAuthProvider</p>

<pre><code class="csharp">public override Task AuthorizationEndpointResponse(OAuthAuthorizationEndpointResponseContext context)
{
    //  Add the claims to the return url
    foreach (var claim in context.Identity.Claims)
    {
        if (claim.Type == ClaimsIdentity.DefaultNameClaimType)
        {
            context.AdditionalResponseParameters.Add("username", claim.Value);
        }
        else if (claim.Type == ClaimTypes.Email)
        {
            context.AdditionalResponseParameters.Add("email", claim.Value);
        }
    }
    return base.AuthorizationEndpointResponse(context);
}
</code></pre>

<p>The above method adds in the additional response parameters that gets embedded in the redirect url to the client.</p>

<p><strong>3. Register user</strong></p>

<p>Now that the user is successfully authenticated with the authorization provider and we have a token, we need to register the user into our database, as we dont want to go to facebook to verify the identity for each and every request. The client can call into <em>RegisterExternal</em> method to register the user into our system. It expects us to pass a email/username for the external authenticated user, which we would have already got from the redirect url parameters. Now the external authenticated user is a valid user in our system and is allowed to make authenticated calls to the api.For the call to RegisterExternal we need to add the token that we got as part of the redirecturl as part of the Authorization header.</p>

<pre><code class="javascript">var registerUser = function () {
    $.ajax({
        url: config.apiBaseUrl + 'api/Account/RegisterExternal',
        data: { 'Email': email, 'Name' : email},
        method: 'POST',
        xhrFields: {
            withCredentials: true
        },
        beforeSend: function(xhr) {
            xhr.setRequestHeader('Authorization','Bearer ' + token);
        },
        success: function(data) {
            // Navigate to the user page
            window.location = "#user";
        },
        failure: function(data) {
            alert('Registration failed' + data.toString());
        }
    });
</code></pre>

<p>On successfull registeration we can get the User details by calling to the UserInfo endpoint.</p>

<pre><code class="javascript">var userInfoUrl = config.apiBaseUrl + "api/Account/UserInfo";
$.ajax({
  url: userInfoUrl,
  success: function(data) {
    window.location = "#";
  },
  beforeSend: function(xhr) {
    xhr.setRequestHeader("Authorization", "Bearer " + config.token);
  }
});
</code></pre>

<p>We can mofify the models to handle more information as required by our api. We could save the token in a local storage and retrieve it whenever a user visits the site back again. The same is the approach for integrating with the other social networks that we have. The sample using the facebook provider is availabe <a href="https://github.com/rahulpnath/Blog/tree/master/WebApiAuthentication">here</a>.
<a href="http://www.codeproject.com" style="display:none" rel="tag">CodeProject</a></p>
]]></content>
  </entry>
  
</feed>
