<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: refactoring | Rahul Nath]]></title>
  <link href="http://rahulpnath.com/blog/category/refactoring/atom.xml" rel="self"/>
  <link href="http://rahulpnath.com/"/>
  <updated>2018-03-30T00:01:32+00:00</updated>
  <id>http://rahulpnath.com/</id>
  <author>
    <name><![CDATA[Rahul Nath]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Refactoring to Composite Pattern]]></title>
    <link href="http://rahulpnath.com/blog/refactoring-to-composite-pattern/"/>
    <updated>2017-04-13T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/refactoring-to-composite-pattern</id>
    <content type="html"><![CDATA[<p>I often come across functions that do multiple things. Many times such functions have a common pattern where multiple sections within the function use the same parameters for calculations. The results from these different code sections within the function are either separated by conditionals (if, switch, etc.) or combined using various arithmetic operators. The most obvious refactoring in such scenarios is to move the code sections into different functions within the same class. Having it in separate functions keeps the code readable. But on closer observation, such functions can be moved into different classes, keeping each of these code sections as the only responsibility.</p>

<h3>Identifying the Refactoring</h3>

<p>Within a function when a similar pattern of code repeats, it could be refactored into multiple classes and composed to give the same functionality. Let us take a simple example of a function where we are validating an Account object based on different criteria. The various criteria end up as conditionals within the function. This function can soon get big and difficult to manage. It also makes it harder to test. If you are adding more validations to this class over a period you are violating the Open-Closed Principle (OCP), the O in <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">SOLID</a>. Depending on the level of abstraction that we are looking at, the class also violates the Single Responsibility Principle(SRP), the S in SOLID. The function handles validations based on different criteria.</p>

<pre><code class="csharp">public List&lt;string&gt; Validate(Account account)
{
    var result = new List&lt;string&gt;();

    if (string.IsNullOrEmpty(account.Email))
        result.Add("No email");
    else if (!IsValidEmailFormat(account.Email))
        result.Add("Email not valid");

    if (account.BillingDetails == null)
        result.Add("Billing Details does not exists");

    ...

    return result;
}
</code></pre>

<h3>The Composite Pattern</h3>

<p><a href="https://en.wikipedia.org/wiki/Composite_pattern">Composite pattern</a> is appropriate when the client ignores the difference between the composition of objects and individual objects. The pattern helps developers to maintain the complexity of the code and also separate out class responsibilities.</p>

<blockquote><p><em>Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly</em></p></blockquote>

<p><img alt="Composite Pattern" src="/images/composite_pattern.png" /></p>

<h3>Refactoring</h3>

<p>In the Account validation above, the function checks for an email and validates the format, checks for valid billing details, etc. The validations could also extend on to users attached to the account and check if there is at least one user, the user has email, phone number, etc. Each of these validations can be moved into separate classes and composed together in one class so that they are all executed when an account needs to be validated. You can see a tree like hierarchy forming here, and the actual validation is composed of all these validations</p>

<p><img alt="Account Validation hierarchy" src="/images/composite_pattern_validation.png" /></p>

<p>The actual C# code looks like this after the refactoring.</p>

<pre><code class="csharp">public interface IValidateAccount
{
    IEnumerable&lt;string&gt; Validate(Account account);
}

public class AccountValidators : IValidateAccount
{
    public readonly IEnumerable&lt;IValidateAccount&gt; Validators;
    public AccountValidators()
    {
        Validators = new List&lt;IValidateAccount&gt;()
        {
          new AccountHasEmailValidator(),
          new AccountEmailIsValidValidator(),
          new AccountHasBillingDetailsValidator()
          ... // Add more validators
        };
    }
    public IEnumerable&lt;string&gt; Validate(Account account)
    {
        return Validators.SelectMany(validator =&gt; validator.Validate(account));
    }
}

public class AccountHasEmailValidator : IValidateAccount
{
    public IEnumerable&lt;string&gt; Validate(Account account)
    {
        if (account != null &amp;&amp; string.IsNullOrEmpty(account.Email))
            yield return "No email";
    }
}

public class AccountEmailIsValidValidator : IValidateAccount
{
    public IEnumerable&lt;string&gt; Validate(Account account)
    {
        if (account != null &amp;&amp; account.Email != null &amp;&amp; !IsValidEmail(account.Email))
            yield return "Email not valid";
    }
}
</code></pre>

<p>After the refactoring, we have separate classes for each of the validation rules. The <em>AccountValidators</em> class composes all the other validators and provides the same uniform interface for the consumers to validate an account. It calls on to all the Validators iteratively and invokes the Validate method on them. You can use Dependency Injection to inject in all validators to this class if you are not comfortable hard-wiring them. The IoC container can be setup using <a href="http://www.rahulpnath.com/blog/ioc-registration-by-convention/">registration by convention</a>, which prevents the needs for explicit registration for any new validators.</p>

<p>One other worry that I have seen common when moving to such a pattern is that - <em>We now have a lot more classes. Does that not affect the performance?</em>. If you are following SOLID principles to the core and want to maintain loose coupling in your code then creating more classes is something you cannot avoid. We do not want any
<a href="http://wiki.c2.com/?GodClass">God Classes</a> in our code and the first step towards it is to split them into different classes.</p>

<blockquote><p><em>If an Object Oriented language cannot handle the creation of many classes and objects then why should we be using it in the first place?</em></p>

<p>-<em><a href="https://vimeo.com/68378923">Big Object Graphs Up Front, Mark Seemann</a></em></p></blockquote>

<p>The composition can be complex conditions as in the case below. For, e.g., let&rsquo;s say we need to execute a different kind of algorithm to calculate based on a property.</p>

<pre><code class="csharp">public class AccountCalculator : ICalculate
{
    public AccountCalculator(ICalculate calculate1, ICalculate calculate2, ICalculate calculate3)
    {
        ...
    }

    public int Calculate(Account account)
    {
        if(account.PropertyExists)
            return calculate1.Calculate();
        else
              return calculate2.Calculate() + calculate3.Calculate();
    }
}
</code></pre>

<p>The above composition makes it easy to test the composed parts and the composition separately. It also helps keep the tests simple and easy to understand. The code is separated into maintainable classes and each criteria can be modified independently.</p>

<p>Composite Pattern is a useful technique to keep code maintainable and readable. Identifying the pattern is a bit of a challenge, but the more you see it the more familiar you will be. Hope this helps!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduce Tests when Fixing Bugs]]></title>
    <link href="http://rahulpnath.com/blog/introduce-tests-when-fixing-bugs/"/>
    <updated>2016-09-26T00:00:00+00:00</updated>
    <id>http://rahulpnath.com/blog/introduce-tests-when-fixing-bugs</id>
    <content type="html"><![CDATA[<p><em>When creating a subscription for a client, the calculated number of months was off by one at times</em> - This was a bug reported from production application that I was currently working on. Though, not a blocker, it was creating enough issues for the end users that it required a hotfix. One of my friends picked this issue up and started working on it. A while later, while I was checking the status of that bug I noticed him playing around with  <a href="https://www.linqpad.net/">Linqpad</a>. He was testing a method to calculate the number of months between two dates with different values.</p>

<p><a href="https://www.flickr.com/photos/toomore/23066277453" class="center" title="Image By Toomore Chiang, from https://www.flickr.com/photos/toomore/23066277453"><img src="/images\testing.jpg" class="center" alt="Testing"></a></p>

<p>We often test our code elsewhere because it&rsquo;s coupled with other code making it difficult to test at the source itself. The fact that we need to test an isolated part of a larger piece of code is a &lsquo;<a href="https://en.wikipedia.org/wiki/Code_smell">Code smell</a>&rsquo;. There possibly is a class or method that can be extracted and unit tested separately.</p>

<blockquote><p><em>Having to test code elsewhere other than the source is a Smell. Look for a method or class waiting to be extracted</em></p></blockquote>

<p>In this specific case, below is how the code that calculates month difference between two dates looked like. As you can see below, the code is coupled with the newAccount, which in turn is coupled with a few other entities that I have omitted. Added to this, this method existed in an MVC controller, which had other dependencies.</p>

<pre><code class="csharp Existing Code">...
var date1 = newAccount.StartDate;
var date2 = newAccount.EndDate;
int monthsApart = Math.Abs(12 * (date1.Year - date2.Year) + date1.Month - date2.Month) - 1;
decimal daysInMonth1 = DateTime.DaysInMonth(date1.Year, date1.Month);
decimal daysInMonth2 = DateTime.DaysInMonth(date2.Year, date2.Month);
decimal dayPercentage = ((daysInMonth1 - date1.Day) / daysInMonth1)
                      + (date2.Day / daysInMonth2);
var months = (int)Math.Ceiling(monthsApart + dayPercentage);
...
</code></pre>

<p>This explains why it was easier to copy this code across and test it in Linqpad. It was difficult to construct the whole hierarchy of objects and to test this. So the easiest thing to fix the bug in is to test elsewhere and fit back in its original place.</p>

<h3>Extract Method Refactoring</h3>

<p>This is one of the scenario where <a href="http://refactoring.com/catalog/extractMethod.html">Extract Method</a> Refactoring fits in best. According to the definition</p>

<blockquote><p><em>You have a code fragment that can be grouped together. <strong>Turn the fragment into a method whose name explains the purpose of the method.</strong></em></p></blockquote>

<p>Extract Method Refactoring is also referred in <a href="http://www.amazon.com/gp/product/0131177052/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0131177052&amp;linkCode=as2&amp;tag=rahulpnath-20&amp;linkId=TTKEEYQLEMTOXPPQ">Working Effectively With Legacy Code</a> and <a href="http://www.amazon.com/gp/product/0131495054/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0131495054&amp;linkCode=as2&amp;tag=rahulpnath-20&amp;linkId=XR55UAOEPPMVMFK3">xUnit Test Patterns</a> (to refactor test code).  It helps separate logic from rest of the object hierarchy and test individually. In this scenario, we can extract the logic to calculate the number of months between two dates into a separate method.</p>

<p>For <a href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd">Test driving</a> the extracted method, all I do initially is to extract the method. As the method purely depends on its passed in parameters and not on any instance variables, I mark it as a static method. This removes the dependency from the MVC controller class parameters and the need to construct them in the tests . The test cases includes the failed &lsquo;off by one&rsquo; case (<em>(&ldquo;25-Aug-2017&rdquo;, &ldquo;25-Feb-2018&rdquo;, 6)</em>). With tests that pass and fail it&rsquo;s now safe to make changes to the extracted method to fix the failing cases.</p>

<pre><code class="csharp Tests">[Theory]
[InlineData("10-Feb-2016", "10-Mar-2016", 1)]
[InlineData("10-Feb-2016", "11-Mar-2016", 2)]
[InlineData("10-Feb-2015", "11-Mar-2016", 14)]
[InlineData("01-Feb-2015", "01-Mar-2015", 1)]
[InlineData("21-Sep-2016", "22-Sep-2016", 1)]
[InlineData("25-Aug-2017", "25-Feb-2018", 6)]
[InlineData("12-Aug-2016", "15-Mar-2019", 32)]
public void MonthsToReturnsExpectedMonths(
    string date1,
    string date2,
    int expected)
{
    var actual = SubscriptionController.MonthsTo(DateTime.Parse(date1), DateTime.Parse(date2));
    Assert.Equal(expected, actual);
}
</code></pre>

<p>More than the algorithm used to solve the original issue what is more important is in identifying such scenarios and extracting them as a method. Make the least possible change to make it testable and fix step by step.</p>

<blockquote><p><em>Whenever there are code fragments that depend only on a subset of properties of your class or function inputs, it could be extracted into a separate method.</em></p></blockquote>

<pre><code class="csharp Extracted method after Refactoring.">public static int MonthsTo(DateTime date1, DateTime date2)
{
    int months = Math.Abs(12*(date1.Year - date2.Year) + date1.Month - date2.Month);
    if (date2.Date.Day &gt; date1.Date.Day)
        months = months + 1;

    return months;
}
</code></pre>

<h3>Introduce Value Object</h3>

<p>Now that we have fixed the bug and have tests covering the different combinations, let&rsquo;s see if this method can live elsewhere and make it reusable. The start date and end date on account always go together and is a domain concept that can be extracted out as an &lsquo;Account Term Range&rsquo;. It can be represented as a DateRange <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Value Object</a>. We can then introduce a method in the DateRange Value Object to return the number of months in the range. This makes the function reusable and also <a href="http://www.rahulpnath.com/blog/refactoring-to-improve-readability-separating-business-language-and-programming-language-semantics/">code more readable</a>. I made the original refactored method as an extension method on DateTime and used it from DateRange Value Object.</p>

<pre><code class="csharp Encapsulate into Value Object">public static class DateTimeExtensions 
{
    public static int MonthsTo(this DateTime date1, DateTime date2)
    {
        int months = Math.Abs(12*(date1.Year - date2.Year) + date1.Month - date2.Month);
        if (date2.Date.Day &gt; date1.Date.Day)
            months = months + 1;

        return months;
    }
}

public class DateRange
{
    public DateTime StartDate { get; private set; }
    public DateTime EndDate { get; private set; }

    public DateRange(DateTime startDate, DateTime endDate)
    {
        // Ignoring null checks
        if (endDate &lt; startDate)
            throw new ArgumentException("End Date cannot be less than Start Date");

        this.StartDate = startDate;
        this.EndDate = endDate;
    }

    public int GetMonths()
    {
        return StartDate.MonthsTo(EndDate);
    }
}
... // Rest of Value Object Code to override Equals and GetHashCode
</code></pre>

<p>If you are new to TDD or just getting started with tests, introducing tests while fixing bugs is a good place to start. This might also help make code decoupled and readable. Try <a href="http://www.rahulpnath.com/blog/is-code-coverage-a-lie/">covering a fix with tests</a> the next time you fix a bug!</p>

<h4><strong>References</strong></h4>

<div>
    <div class="row">
        <div class="col-sm-6 col-md-3">
            <div class="thumbnail">
                <a href="http://www.amazon.com/gp/product/0131495054/ref=as_li_tl?ie=UTF8&camp=1789&creative=390957&creativeASIN=0131495054&linkCode=as2&tag=rahulpnath-20&linkId=XR55UAOEPPMVMFK3">
                    <img src="http://rahulpnath.com/images/books_xunit.jpg" data-holder-rendered="true" style="display: block;">
                </a>
            </div>
        </div>
        <div class="col-sm-6 col-md-3">
            <div class="thumbnail">
                <a href="http://www.amazon.com/gp/product/0321503627/ref=as_li_tl?ie=UTF8&camp=1789&creative=390957&creativeASIN=0321503627&linkCode=as2&tag=rahulpnath-20&linkId=TR6UCCVP6CMGBBZQ">
                    <img src="http://rahulpnath.com/images/books_goos.jpeg" data-holder-rendered="true" style="display: block;">
                </a>
            </div>
        </div>
        <div class="col-sm-6 col-md-3">
            <div class="thumbnail">
                <a href="http://www.amazon.com/gp/product/0131177052/ref=as_li_tl?ie=UTF8&camp=1789&creative=390957&creativeASIN=0131177052&linkCode=as2&tag=rahulpnath-20&linkId=TTKEEYQLEMTOXPPQ">
                    <img src="http://rahulpnath.com/images/books_welc.jpg" data-holder-rendered="true" style="display: block;">
                </a>
            </div>
        </div>
    </div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Refactoring to Improve Readability - Separating Business Language and Programming Language Semantics]]></title>
    <link href="http://rahulpnath.com/blog/refactoring-to-improve-readability-separating-business-language-and-programming-language-semantics/"/>
    <updated>2016-07-18T04:52:35+00:00</updated>
    <id>http://rahulpnath.com/blog/refactoring-to-improve-readability-separating-business-language-and-programming-language-semantics</id>
    <content type="html"><![CDATA[<p>Often we write ourselves or come across code that has both business language and the programming language semantics mixed together. This makes it very hard to reason about the code and also fix any issues. It&rsquo;s easier to read code that is composed of different smaller individual functions doing a single thing.</p>

<p>If you follow the <em>One Level of Abstraction per Function Rule</em> or the <em>Stepdown Rule</em> as mentioned in the book <a href="http://www.amazon.com/gp/product/0132350882/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0132350882&amp;linkCode=as2&amp;tag=rahulpnath-20&amp;linkId=CVCVZFAR5SBYVMJW">Clean Code</a> (I <a href="http://www.rahulpnath.com/blog/language-agnostic-books-for-every-developer-2/">recommend reading it</a> if you have not already), it is easier to keep the business and programming language semantics separate.</p>

<blockquote><p><em>We want the code to read like a top-down narrative. We want every function to be followed by those at the next level of abstraction so that we can read the program, descending one level of abstraction at a time as we read down the list of functions. Making the code read like a top-down set of TO paragraphs is an effective technique for
keeping the abstraction level consistent.</em></p></blockquote>

<p>Recently while fixing a bug in one of the applications that I am currently working on, I came across a code with the business and programming language semantics mixed together. This made it really hard to understand the code and fixing it. So I decided to refactor it a bit before fixing the bug.</p>

<p> <a href="http://www.slideshare.net/kvg452/the-art-of-readable-code-31322040">
<img class="center" src="/images/readable_code.jpg" alt="Code should be readable" />
</a></p>

<p>The application is a subscription based service for renting books, videos, games etc. and enabled customers to have different subscription plans and terms. Currently, we are migrating away from the custom built billing module that the application uses to a SAAS based billing provider to make invoicing and billing easy and manageable. In code, a <em>Subscription</em> holds a list of <em>SubscriptionTerm</em> items, that specifies the different terms that a customer has for the specific subscription. A term typically has a start date, an optional end date and a price for that specific term. A null end date indicates that the subscription term is valid throughout the customer lifetime in the system.</p>

<pre><code class="csharp">public class Subscription
{
    public List&lt;SubscriptionTerm&gt; Terms { get; set; }
}

public class SubscriptionTerm
{
    public int Id { get; set; }
    public double Price { get; set; }
    public DateTime StartDate { get; set; }
    public DateTime? EndDate { get; set; }
}
</code></pre>

<p>But in the new system to which we are migrating to, does not support subscription terms that overlap each other with a different price. This had to be data fixed manually in the source system, so we decided to perform a validation step before the actual migration. The code below does exactly that and was working fine until we started seeing that for cases where there were more than one SubscriptionTerm without an end date and also when end date of one was the start date of another, there were no validation errors shown.</p>

<pre><code class="csharp">public bool Validate(Subscription subscription)
{
    var hasOverlappingItems = false;
    foreach (var term in subscription.Terms)
    {
        var otherTerms = subscription.Terms.Where(a =&gt; a.Price != term.Price);
        if (otherTerms.Any())
        {
            if (
                (!term.EndDate.HasValue &amp;&amp; otherTerms.Any(a =&gt; term.StartDate &lt; a.EndDate)) ||
                (otherTerms.Where(a =&gt; !a.EndDate.HasValue).Any(a =&gt; a.StartDate &lt; term.EndDate)) ||
                (otherTerms.Any(a =&gt; term.StartDate &lt;= a.EndDate &amp;&amp; a.StartDate &lt;= term.EndDate))
            )
            {
                hasOverlappingItems = true;
                break;
            }
        }
    }

    return hasOverlappingItems;
}
</code></pre>

<p>The code, as you can see is not that readable and difficult to understand, which increases the chances of me breaking something else while trying to fix it. There were no tests covering this validator, which made it even harder to change it. While the algorithm itself to find overlappings can be improved (maybe a topic for another blog post), we will look into how we can refactor this existing code to improve its readability.</p>

<blockquote><p><em>Code is read more than written, so it&rsquo;s much better to have code optimized for reading</em></p></blockquote>

<h3>Creating the Safety Net</h3>

<p>The first logical thing to do in this case is to protect us with test cases so that any changes made does not break existing functionality.  I came up with the below test cases (<em>test data shown does not cover all cases</em>), to cover the different possible cases that this method can take.</p>

<pre><code class="csharp">[InlineData("10-Jan-2016", "10-Feb-2016", 1, "11-Feb-2016", "10-Dec-2016", 2, false)]
[InlineData("10-Jan-2015", "10-Feb-2015", 1, "20-Jan-2015", "1-Feb-2016", 2, true)]
public void ValidateReturnsExpected(
    string startDate1, string endDate1, double price1,
    string startDate2, string endDate2, double price2,
    bool expected )
{
    // Fixture setup
    var subscription = new Subscription();
    var term1 = createTerm(startDate1, endDate1, price1);
    var term2 = createTerm(startDate2, endDate2, price2);
    subscription.Terms.Add(term1);
    subscription.Terms.Add(term2);
    // Exercise system
    var sut = new OverlappingSubscriptionTermWithConflictingPriceValidator();
    var actual = sut.Validate(subscription);
    // Verify outcome
    Assert.Equal(expected, actual);
    // Teardown
}
</code></pre>

<p>All tests pass, except for those where there were issues in the destination system and I was about to fix.</p>

<h3>Refactoring for Readability</h3>

<p>Now that I have some tests to back me up for the changes that I am to make, I feel more confident to do the refactoring. Looking at the original validator code, all I see is <strong>DATETIME</strong> - There is a lot of manipulation of dates that is happening, which strongly indicates there is some abstraction waiting to be pulled out. We had seen in, <a href="http://www.rahulpnath.com/blog/thinking-beyond-primitive-values-value-objects/">Thinking Beyond Primitive Values: Value Objects</a>, that any time we use a primitive type, we should think more about the choice of type. We saw that properties that co-exist (like DateRange) should be pulled apart as Value Objects. The StartDate and EndDate in SubscriptionTerm fall exactly into that category.</p>

<pre><code class="csharp">public class DateRange
{
    public DateTime StartDate { get; private set; }

    public DateTime? EndDate { get; private set; }

    public DateRange(DateTime startDate, DateTime? endDate)
    {
        if (endDate.HasValue &amp;&amp; endDate.Value &lt; startDate)
            throw new ArgumentException("End date cannot be less than start Date");

        StartDate = startDate;
        EndDate = endDate;
    }
}
</code></pre>

<p>Since these properties are used in a lot of other places, I did not want to make a breaking change, by deleting the existing properties and adding in a new DateRange class. So I chose to add a new read-only property <em>TermPeriod</em> to SubscriptionTerm which returns a DateRange, constructed from it&rsquo;s Start and End dates, as shown below.</p>

<pre><code class="csharp">public DateRange TermPeriod
{
    get
    {
        return new DateRange(StartDate, EndDate);
    }
}
</code></pre>

<p>From the existing validator code, what we are essentially trying to check is if there are any SubscriptionTerms for a subscription that overlaps, i.e if one TermPeriod falls in the range of another. Introducing a method, <em>IsOverlapping</em> on DateRange to check if it overlaps with another DateRange seems logical at this stages. Adding a few tests cases to protect myself here to implement the IsOverlapping method in DateRange class. I also added in the tests to cover the failure scenarios that were seen before.</p>

<pre><code class="csharp Tests for IsOverlapping">[InlineData("10-Jan-2016", "10-Feb-2016", "11-Feb-2016", "10-Dec-2016", false)]
[InlineData("10-Jan-2015", "10-Feb-2015", "20-Jan-2015", "1-Feb-2016", true)]
[InlineData("10-Jan-2015", null, "20-Jan-2016", null,  true)]
[InlineData("28-Jan-16", "10-Mar-16", "10-Mar-16", null, true)]
public void OverlappingDatesReturnsExpected(
    string startDateTime1,
    string endDateTime1,
    string startDateTime2,
    string endDateTime2,
    bool expected)
{
    // Fixture setup
    var range1 = CreateDateRange(startDateTime1, endDateTime1);
    var range2 = CreateDateRange(startDateTime2, endDateTime2);
    // Exercise system
    var actual = range1.IsOverlapping(range2);
    // Verify outcome
    Assert.Equal(expected, actual);
    // Teardown
}
</code></pre>

<pre><code class="csharp IsOverlapping in DateRange">public bool IsOverlapping(DateRange dateRange)
{
    if (!EndDate.HasValue &amp;&amp; !dateRange.EndDate.HasValue)
        return true;

    if (!EndDate.HasValue)
        return StartDate &lt;= dateRange.EndDate;

    if (!dateRange.EndDate.HasValue)
        return dateRange.StartDate &lt;= EndDate;

    return StartDate &lt;= dateRange.EndDate
        &amp;&amp; dateRange.StartDate &lt;= EndDate;
}
</code></pre>

<p>Given two DateRange&rsquo;s I can now tell if they overlap or not, which now can be used to check if two SubscriptionTerms overlap. I just need to check if their TermPeriod&rsquo;s overlap. The validator code is now much more easy to understand.</p>

<pre><code class="csharp IsOverlapping in SubscriptionTerm">public bool IsOverlapping(SubscriptionTerm term)
{
    return TermPeriod.IsOverlapping(term.TermPeriod);
}
</code></pre>

<pre><code class="csharp Validator after Refactoring">public bool Validate(Subscription subscription)
{
    foreach (var term in subscription.Terms)
    {
        var termsWithDifferentPrice = subscription.Terms.Where(a =&gt; a.Price != term.Price);
        return termsWithDifferentPrice
            .Any(a =&gt; a.IsOverlapping(term));
    }

    return false;
}
</code></pre>

<p>The code now reads as a set of TO Paragraphs as mentioned in the book <a href="http://www.amazon.com/gp/product/0132350882/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0132350882&amp;linkCode=as2&amp;tag=rahulpnath-20&amp;linkId=CVCVZFAR5SBYVMJW">Clean Code</a>.</p>

<blockquote><p><em>To check if a subscription is valid, check if the subscription has overlapping SubscriptionTerms with a conflicting price. To check if two subscriptions are overlapping, check if their subscription term periods overlap each other. To check if two term periods overlap check if start date of one is before the end date of other</em></p></blockquote>

<p>Readability of code is an important aspect and should be something that we strive towards for. The above just illustrates an example of why readability of code is important and how it helps us on a longer run. It makes maintaining code really easy. Following some basic guidelines like One Level of Abstraction per Function, allows us to write more readable code. Separating code into different small readable functions covers just one aspect of Readability, there are a lot of other practices mentioned in the book <a href="http://shop.oreilly.com/product/9780596802301.do">The Art of Readable Code</a>. The sample code with all the tests and validator is available <a href="https://github.com/rahulpnath/Blog/tree/master/Refactoring/RefactoringForReadability">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Refactoring to Improve Testability: Extracting Dependencies]]></title>
    <link href="http://rahulpnath.com/blog/refactoring-to-improve-testability-extracting-dependencies/"/>
    <updated>2016-04-03T03:14:28+00:00</updated>
    <id>http://rahulpnath.com/blog/refactoring-to-improve-testability-extracting-dependencies</id>
    <content type="html"><![CDATA[<p><a href="https://pixabay.com/en/code-data-programming-code-944504/" class="center" title="Image By Lawrence Monk, from https://pixabay.com/en/code-data-programming-code-944504/"><img src="/images\coding.jpg" class="center" alt="Refactoring"></a></p>

<p>In the earlier post, <a href="http://rahulpnath.com/blog/refactoring-to-improve-testability-removing-unnecessary-dependencies/">Removing Unnecessary Dependencies</a>, we saw how having an unnecessary dependency hinders testability. In this post we will see just the opposite of that - extracting functionality out of a class and creating another class to separate responsibilities, making it easier to test and adhere to <a href="https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html">Single Responsibility Principle</a>(SRP).</p>

<blockquote><p><em>Violating Single Responsibility Principle makes writings tests harder.</em></p></blockquote>

<p>Some of the common tests smell (from XUnit Test Patterns by Gerard Meszaros, <a href="http://www.rahulpnath.com/blog/language-agnostic-books-for-every-developer-2/">a recommended read</a>) that helps me to find these dependencies are <a href="http://xunitpatterns.com/Hard%20to%20Test%20Code.html">Hard-To-Test Code</a> and <a href="http://xunitpatterns.com/Fragile%20Test.html">Fragile Tests</a>. In this post we will explore the refactoring with the help of an example - I have to process usages (anything like electricity, internet, water etc.) for a list of locations aggregated over for a day. There is a repository where the last processed date for the location is stored, and whenever this process runs we have to process for all the days from the last processed date till the current day.</p>

<p>The existing code looks like below, which loops through a list of locations passed in, fetches the last processed date from a repository , gets all the days to be processed till today (<em>DateTime.Now.Date</em>) and processes them for all the days.</p>

<pre><code class="csharp">public class LocationsUsagesCalculator
{
    ILocationUsages locationUsages;
    IUsageRepository usageRepository;

    public void ProcessUsagesForLocations(IEnumerable&lt;Location&gt; locations)
    {
        foreach (var location in locations)
        {
            ProcessUsagesForLocation(location);
        }
    }

    private void ProcessUsagesForLocation(Location location)
    {
        DateTime lastProcessedDate = usageRepository.GetLastProcessedDateForLocation(location);
        IEnumerable&lt;DateTime&gt; datesToProcess = GetAllDaysTillTodayFromDate(lastProcessedDate);
        foreach (var dateToProcess in datesToProcess)
        {
            ProcessUsagesForLocationOnDate(location, dateToProcess);
        }
    }

    private void ProcessUsagesForLocationOnDate(Location location, DateTime dateToProcess)
    {
        locationUsages.ProcessUsagesForLocationOnDate(location, dateToProcess);
    }

    private IEnumerable&lt;DateTime&gt; GetAllDaysTillTodayFromDate(DateTime lastProcessedDate)
    {
        var dateCounter = lastProcessedDate.Date.AddDays(1);
        while (dateCounter &lt;= DateTime.Now.Date)
        {
            yield return dateCounter;
            dateCounter = dateCounter.AddDays(1);
        }
    }
}
</code></pre>

<h3>Testability Issues with Current Design</h3>

<p>The code is self-explanatory and does what&rsquo;s expected. But what interests us more is the test code for this. From a test perspective we need to make sure
that for all locations, usages gets processed for the pending days. Direct cases when last processed day is a day before, a couple of days before and different for each location are some of the likely scenarios. Let&rsquo;s see one of the cases where the last processed day is a few days before for all locations</p>

<pre><code class="csharp">[Theory, AutoMoqData]
public void ProcessUsagesWithCoupleOfDaysBeforeAsLastProcessedProcessesAllDaysTillTodayForEachLocation(
   [Frozen]Mock&lt;ILocationUsages&gt; locationUsages,
   [Frozen]Mock&lt;IUsageRepository&gt; usageRepository,
   IEnumerable&lt;Location&gt; locations,
   LocationsUsagesCalculator sut)
{
    var days = 3;
    var threeDaysBefore = DateTime.Now.AddDays(-days);
    usageRepository
        .Setup(a =&gt; a.GetLastProcessedDateForLocation(It.IsAny&lt;Location&gt;()))
        .Returns(threeDaysBefore);

    sut.ProcessUsagesForLocations(locations);

    var expectedDates = Enumerable.Range(1, days).Select(a =&gt; threeDaysBefore.Date.AddDays(a));

    foreach (var location in locations)
        foreach (var date in expectedDates)
            locationUsages
                .Verify(a =&gt; a.ProcessUsagesForLocationOnDate(location, date), Times.Once());
}
</code></pre>

<p>Clearly this is not the kind of tests that I want to write! It has a lot of setup code and even some logics to generate <em>expectedDates</em>. Let&rsquo;s see the various dependencies that the SUT has:</p>

<ul>
<li>ProcessUsagesForLocationOnDate on ILocationUsages</li>
<li>GetLastProcessedDateForLocation on IUsageRepository</li>
<li>List of locations that it&rsquo;s processing</li>
<li>Last processed date for each location</li>
<li>Dates pending processing as of today</li>
</ul>


<p>We clearly see that this one class does a lot more things than what its name suggests. Let&rsquo;s see how we can refactor this to improve our test code and manage the dependencies better.</p>

<h3>Refactoring the Code</h3>

<p>Finding all the dates till a given date (today in this case) is not this classes responsibility and can easily be pulled out. Since the SUT depends on <em>IUsageRepository</em> just to calculate the dates I can pull that out along with the refactoring. I have created a new interface, <em>IUsageDatesCalculator</em>, to return all the days pending process. With this interface, the test code looks a bit more clear and easier to write.</p>

<pre><code class="csharp">[Theory, Tests.AutoMoqData]
public void ProcessUsagesProcessesForAllLocationForPendingDays(
    IEnumerable&lt;DateTime&gt; datesToProcess,
    [Frozen]Mock&lt;ILocationUsages&gt; locationUsages,
    [Frozen]Mock&lt;IUsageDatesCalculator&gt; usageDatesCalculator,
    IEnumerable&lt;Location&gt; locations,
    LocationsUsagesCalculator sut)
{
    usageDatesCalculator
        .Setup(a =&gt; a.GetDatesToCalculate(It.IsAny&lt;Location&gt;()))
        .Returns(datesToProcess);

    sut.ProcessUsagesForLocations(locations);

    foreach (var location in locations)
        foreach (var date in datesToProcess)
        locationUsages
            .Verify(a =&gt; a.ProcessUsagesForLocationOnDate(location, date), Times.Once());
}
</code></pre>

<p>This looks better and easy to write - we do not have to write any code in the test to generate the expected dates. All I need is a list of dates (no matter is what order) and I need to make sure that process calls all of those. We would also pull out a separate interface to process for a location, instead of a list of locations. This will further remove the need to loop through the locations list in the test.</p>

<h3>DateTime and Tests</h3>

<p>Both in the original code and the refactored code, the logic that generates the dates to be processed depends on <em>DateTime.Now</em> for getting the current date. Though this looks perfectly fine, it makes testing harder. In the original test code, I had to generate expected dates based on today (system time).</p>

<p>It&rsquo;s a good practice to inject a Time Provider into the consumer so that you can mock the value of Now(today) for tests. <a href="https://msdn.microsoft.com/en-us/library/system.datetime.now(v=vs.110).aspx">DateTime.Now</a> is a static dependency on a class property and makes it hard for tests.
Even using a <a href="http://stackoverflow.com/a/2425739/1948745">static TimeProvider</a> and having overrides to set mocks for testing is not advised (also mentioned by Seemann in the <a href="http://stackoverflow.com/questions/2425721/unit-testing-datetime-now/2425739#comment38623763_2425739">comments</a>), as it creates problems for parallel tests execution.</p>

<blockquote><p><em>Inject a Time Provider into the consumer. Do not depend on any static time provider (including DateTime.Now)</em></p></blockquote>

<p>Refactoring the dependency with current time using a inject interface, <em>ITimeProvider</em>, makes setting the current day easy as shown in the tests below. I can now hard code my expected dates into the test code and not depend on a runtime generated list.</p>

<pre><code class="csharp">[Theory]
[InlineAutoMoqData("2016-04-02","2016-03-29", "2016-03-30,2016-03-31,2016-04-01,2016-04-02")]
[InlineAutoMoqData("2016-04-02", "2016-04-02", "")]
[InlineAutoMoqData("2016-04-02", "2016-04-01", "2016-04-02")]
public void GetDatesToCalculateReturnsExpectedDates(
    string todayString, 
    string lastProcessedDayString,
    string expectedDaysString,
    [Frozen]Mock&lt;ITimeProvider&gt; timeProvider,
    [Frozen]Mock&lt;IUsageRepository&gt; usageRepository,
    Location dummyLocation,
    UsageDatesCalculator sut)
{
    var expected = expectedDaysString
        .Split(new string[] { "," }, StringSplitOptions.RemoveEmptyEntries)
        .Select(a =&gt; DateTime.Parse(a));
    var lastProcessedDay = DateTime.Parse(lastProcessedDayString);
    var today = DateTime.Parse(todayString);

    timeProvider.Setup(a =&gt; a.Now).Returns(today.Date);
    usageRepository
        .Setup(a =&gt; a.GetLastProcessedDateForLocation(It.IsAny&lt;Location&gt;()))
        .Returns(lastProcessedDay);

    var actual = sut.GetDatesToCalculate(dummyLocation).ToList();

    Assert.Equal(expected, actual);
}
</code></pre>

<p>We have refactored various dependencies that the original code had and made it more testable. Testing is easier and <a href="https://pragprog.com/magazines/2012-01/unit-tests-are-first">repeatable</a>. Whenever writing tests become difficult - stop, think and refactor!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Refactoring Test Code: Removing Constructor Dependency]]></title>
    <link href="http://rahulpnath.com/blog/refactoring-test-code-removing-constructor-dependency/"/>
    <updated>2016-03-31T04:18:03+00:00</updated>
    <id>http://rahulpnath.com/blog/refactoring-test-code-removing-constructor-dependency</id>
    <content type="html"><![CDATA[<p><a href="https://www.flickr.com/photos/toomore/23066277453" class="center" title="Image By Toomore Chiang, from https://www.flickr.com/photos/toomore/23066277453"><img src="/images\testing.jpg" class="center" alt="Testing"></a></p>

<p>In the earlier post, <a href="http://rahulpnath.com/blog/refactoring-to-improve-testability-removing-unnecessary-dependencies/">Removing Unnecessary Dependencies</a>, we saw how having an unnecessary dependency hinders testability. In this post we will see how the test code changed by the refactoring we did for removing the unnecessary dependency and explore ways to control these changes.</p>

<h3>Impact on Tests by the Refactoring</h3>

<p>The refactoring in the last post involved a change in the updating the constructor signature to take in a string value instead of an interface. This broke a lot of our tests and forced us to change all constructor usages with the below code.</p>

<pre><code class="csharp">var anonymousName = "Anonymous Name";
myService = new MyService(otherDependency, anonymousName);
</code></pre>

<p>When seen in isolation, this is not much a change, but as the number of tests grows it becomes a pain. This definitely does not feel right. Breaking tests forces us out of <a href="http://xunitpatterns.com/test%20first%20development.html">Test-First Development</a> and reduces the confidence in the tests and in the code.</p>

<blockquote><p><em>The idea behind TDD was <a href="http://www.jamesshore.com/Blog/Red-Green-Refactor.html">Red-Green-Refactor</a>. But if tests break when Refactoring, then why follow TDD at all?</em></p></blockquote>

<h3>Refactoring Tests</h3>

<p>Ideally, we should write tests that do not break when we refactor, so that it helps us to use the same tests over the refactored code. Let&rsquo;s see how we can improve the test code to prevent tests from breaking, when we refactor to <a href="http://rahulpnath.com/blog/refactoring-to-improve-testability-removing-unnecessary-dependencies/">remove unnecessary dependency</a>. Below is the original code (<em>rewritten into xUnit and Moq, as I prefer that</em>) with the dependency on IAppSettings (which we will change it to string later)</p>

<pre><code class="csharp">[Fact]
public void PerformOperationsShouldReturnTrue()
{
    var otherDependency = new Mock&lt;IMyOtherDependency&gt;();
    var appSettings = new Mock&lt;IAppSettings&gt;();
    appSettings.Setup(a =&gt; a["app.name"]).Returns("My Test Application");
    var myService = new MyService(otherDependency, appSettings);

    var result = myService.PerformOperations();

    otherDependency.Verify(a =&gt; a.UtilityMethod(), Times.Once());
    Assert.True(result);
}
</code></pre>

<p>Let&rsquo;s analyze the test code for the dependencies that it has:</p>

<ul>
<li><em>UtilityMethod</em> of IMyOtherDependency</li>
<li><em>app.name</em> configuration value from IAppSettings</li>
<li><em>Constructor</em> of <a href="http://xunitpatterns.com/SUT.html">System Under Test</a>(SUT) - MyService</li>
<li><em>PerformOperations</em> of SUT which is getting tested</li>
</ul>


<p>The test by itself verifies that calling <em>PerformOperations</em> returns true and UtilityMethod gets called once. It is not dependent on the value (&lsquo;My Test Application&rsquo;) returned by appSettings. The only need is that it should return some (dummy) value when asked for &lsquo;app.name&rsquo;. Assuming that there are multiple tests in this class that does the same setup of IAppSettings to return a dummy value you can start smelling <em>Cut-and-Paste code reuse for fixture setup</em>.</p>

<blockquote><p><em>Rule of Three: “The first time you do something, you just do it. Second time you do something similar, you wince at the duplication, but you do the duplicate thing anyway. The third time you do something similar, you refactor.”</em></p></blockquote>

<p>The <a href="https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming">Rule of Three</a> is applicable even when writing test code and we should always keep an eye for duplication. <strong>It is easy to get lost in the thought that it&rsquo;s just test code and does not hurt to copy paste</strong>. Code duplication in test code does hurt and it hurts the most when you refactor production code.</p>

<p>So lets Refactor applying the <a href="http://www.refactoring.com/catalog/">various techniques</a> that we know of!</p>

<h4><strong><a href="http://www.refactoring.com/catalog/extractMethod.html">Extract Method</a></strong></h4>

<p><em>You have a code fragment that can be grouped together. Turn the fragment into a method whose name explains the purpose of the method.</em></p>

<p>Since we only depend on the <em>IMyOtherDependency</em> and the SUT instance instantiated with that, we can extract SUT creation with a given instance of IMyOtherDependency as below.</p>

<pre><code class="csharp">[Fact]
public void PerformOperationsShouldReturnTrue()
{
    var otherDependency = new Mock&lt;IMyOtherDependency&gt;();
    var myService = GetMyServiceWithMyOtherDependency(otherDependency);

    var result = myService.PerformOperations();

    otherDependency.Verify(a =&gt; a.UtilityMethod(), Times.Once());
    Assert.True(result);
}

private MyService GetMyServiceWithMyOtherDependency(Mock&lt;IMyOtherDependency&gt; otherDependency)
{
    var appSettings = new Mock&lt;IAppSettings&gt;();
    appSettings.Setup(a =&gt; a["app.name"]).Returns("My Test Application");
    var myService = new MyService(otherDependency, appSettings);
    return myService;
}
</code></pre>

<p>This starts taking us towards <strong><a href="http://martinfowler.com/bliki/ObjectMother.html">Object Mother Pattern</a></strong>. It looks good to start with and might work well if all we have is the same <a href="http://xunitpatterns.com/Fixture%20Setup%20Patterns.html">fixture setup</a>. But if we have a different kind of fixture setup, with more dependency and combinations of setup, we will soon have a lot of similar creational methods with different combinations of parameters  - <em>GetMyServiceWithMyOtherDependencyAndAppSettings,GetMyServiceWithAppSettings</em> etc. The problem with having different methods is that all of them are dependent on the SUT constructor and set the same properties, leading to code duplication again.</p>

<h4><strong><a href="http://www.refactoring.com/catalog/extractClass.html">Extract Class</a></strong></h4>

<p><em>You have one class doing work that should be done by two. Create a new class and move the relevant fields and methods from the old class into the new class.</em></p>

<p>With these new creational methods the test class is having more responsibility than it should actually have, so let&rsquo;s extract these creation methods into <em>MyServiceBuilder</em> class to see if we can further solve the problem.</p>

<pre><code class="csharp">public class MyServiceBuilder
{
    public IAppSettings AppSettings { get; private set; }
    public IMyOtherDependency OtherDependency { get; private set; }

    public MyServiceBuilder()
    {
        var appsettingsMock = new Mock&lt;IAppSettings&gt;();
        appsettingsMock.Setup(a =&gt; a["app.name"]).Returns("My Test Application");
        AppSettings = appsettingsMock.Object;
        OtherDependency = new Mock&lt;IMyOtherDependency&gt;().Object;
    }

    public MyService Build()
    {
        return new MyService(OtherDependency, AppSettings);
    }

    public MyServiceBuilder WithAppSettings(IAppSettings appSettings)
    {
        AppSettings = appSettings;
        return this;
    }

    public MyServiceBuilder WithOtherDependency(IMyOtherDependency otherDependency)
    {
        OtherDependency = otherDependency;
        return this;
    }
}
</code></pre>

<p>This takes us to <strong><a href="http://www.natpryce.com/articles/000714.html">Test Data Builder Pattern</a></strong> and as we notice we have reduced the dependency on the MyService constructor to just one and only place where we need to change if the constructor signature changes. Since the <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">Cyclomatic Complexity</a> of <em>MyServiceBuilder</em> is one it is fine not to write tests for it   . Using the new builder class our original test case now looks like below.</p>

<pre><code class="csharp">[Fact]
public void PerformOperationsShouldReturnTrue()
{
    var otherDependency = new Mock&lt;IMyOtherDependency&gt;();
    var myService = new MyServiceBuilder().WithOtherDependency(otherDependency.Object).Build();

    var result = myService.PerformOperations();

    otherDependency.Verify(a =&gt; a.UtilityMethod(), Times.Once());
    Assert.True(result);
}
</code></pre>

<p>Now the test is just dependent on the objects that it needs. If all the test use <em>MyServiceBuilder</em>, we can now easily refactor to <a href="http://rahulpnath.com/blog/refactoring-to-improve-testability-removing-unnecessary-dependencies/">Remove the Unnecessary Dependency</a> on IAppSettings, by just changing the <em>MyServiceBuilder</em> to use a string property. We will also need to change tests that use the <em>WithAppSettings</em> method which is expected, as those tests are dependent on the app settings value in the first place and so the tests definitely need to be re-written.</p>

<h3>Generic Test Data Builder</h3>

<p>We could have essentially stopped at the above step, but then we realize that it is too much work to create a Test Data Builder class for each of the production code classes that we have. It takes a lot out of the <a href="http://keysleft.com/">finite number of keystrokes left in your hands</a> and you definitely don&rsquo;t want to waste that in typing redundant code. This is where we can use
<a href="https://github.com/AutoFixture/AutoFixture">AutoFixture</a>, that is an open source library for .NET that helps reduce the <a href="http://xunitpatterns.com/Four%20Phase%20Test.html">Setup</a>/<a href="http://c2.com/cgi/wiki?ArrangeActAssert">Arrange</a> phase. Using <a href="http://blog.ploeh.dk/2010/10/08/AutoDataTheorieswithAutoFixture/">AutoData Theories with AutoFixture</a> our test case now looks like below.</p>

<pre><code class="csharp">[Theory, AutoMoqData]
public void PerformOperationsShouldReturnTrue(
    [Frozen]Mock&lt;IMyOtherDependency&gt; otherDependency,
    MyService myService)
{
    var result = myService.PerformOperations();

    otherDependency.Verify(a =&gt; a.UtilityMethod(), Times.Once());
    Assert.True(result);
}
</code></pre>

<p>The test code does not have any dependency on the constructor of the SUT and a change in constructor signature does not affect our tests at all. We can refactor <em>MyService</em> and use the same tests as long as the functionality served by the class remains the same. Constructors are implementation details and it&rsquo;s better to keep tests independent of it. This keeps our test code clean and more robust!</p>
]]></content>
  </entry>
  
</feed>
